"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/choices.js";
exports.ids = ["vendor-chunks/choices.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/choices.js/public/assets/scripts/choices.js":
/*!******************************************************************!*\
  !*** ./node_modules/choices.js/public/assets/scripts/choices.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("\n/*! choices.js v10.2.0 | Â© 2022 Josh Johnson | https://github.com/jshjohnson/Choices#readme */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(window, function() {\n    return /******/ function() {\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = {\n            /***/ 282: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_660__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.clearChoices = exports1.activateChoices = exports1.filterChoices = exports1.addChoice = void 0;\n                var constants_1 = __nested_webpack_require_660__(883);\n                var addChoice = function(_a) {\n                    var value = _a.value, label = _a.label, id = _a.id, groupId = _a.groupId, disabled = _a.disabled, elementId = _a.elementId, customProperties = _a.customProperties, placeholder = _a.placeholder, keyCode = _a.keyCode;\n                    return {\n                        type: constants_1.ACTION_TYPES.ADD_CHOICE,\n                        value: value,\n                        label: label,\n                        id: id,\n                        groupId: groupId,\n                        disabled: disabled,\n                        elementId: elementId,\n                        customProperties: customProperties,\n                        placeholder: placeholder,\n                        keyCode: keyCode\n                    };\n                };\n                exports1.addChoice = addChoice;\n                var filterChoices = function(results) {\n                    return {\n                        type: constants_1.ACTION_TYPES.FILTER_CHOICES,\n                        results: results\n                    };\n                };\n                exports1.filterChoices = filterChoices;\n                var activateChoices = function(active) {\n                    if (active === void 0) {\n                        active = true;\n                    }\n                    return {\n                        type: constants_1.ACTION_TYPES.ACTIVATE_CHOICES,\n                        active: active\n                    };\n                };\n                exports1.activateChoices = activateChoices;\n                var clearChoices = function() {\n                    return {\n                        type: constants_1.ACTION_TYPES.CLEAR_CHOICES\n                    };\n                };\n                exports1.clearChoices = clearChoices;\n            /***/ },\n            /***/ 783: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_2877__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.addGroup = void 0;\n                var constants_1 = __nested_webpack_require_2877__(883);\n                var addGroup = function(_a) {\n                    var value = _a.value, id = _a.id, active = _a.active, disabled = _a.disabled;\n                    return {\n                        type: constants_1.ACTION_TYPES.ADD_GROUP,\n                        value: value,\n                        id: id,\n                        active: active,\n                        disabled: disabled\n                    };\n                };\n                exports1.addGroup = addGroup;\n            /***/ },\n            /***/ 464: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_3694__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.highlightItem = exports1.removeItem = exports1.addItem = void 0;\n                var constants_1 = __nested_webpack_require_3694__(883);\n                var addItem = function(_a) {\n                    var value = _a.value, label = _a.label, id = _a.id, choiceId = _a.choiceId, groupId = _a.groupId, customProperties = _a.customProperties, placeholder = _a.placeholder, keyCode = _a.keyCode;\n                    return {\n                        type: constants_1.ACTION_TYPES.ADD_ITEM,\n                        value: value,\n                        label: label,\n                        id: id,\n                        choiceId: choiceId,\n                        groupId: groupId,\n                        customProperties: customProperties,\n                        placeholder: placeholder,\n                        keyCode: keyCode\n                    };\n                };\n                exports1.addItem = addItem;\n                var removeItem = function(id, choiceId) {\n                    return {\n                        type: constants_1.ACTION_TYPES.REMOVE_ITEM,\n                        id: id,\n                        choiceId: choiceId\n                    };\n                };\n                exports1.removeItem = removeItem;\n                var highlightItem = function(id, highlighted) {\n                    return {\n                        type: constants_1.ACTION_TYPES.HIGHLIGHT_ITEM,\n                        id: id,\n                        highlighted: highlighted\n                    };\n                };\n                exports1.highlightItem = highlightItem;\n            /***/ },\n            /***/ 137: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_5522__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.setIsLoading = exports1.resetTo = exports1.clearAll = void 0;\n                var constants_1 = __nested_webpack_require_5522__(883);\n                var clearAll = function() {\n                    return {\n                        type: constants_1.ACTION_TYPES.CLEAR_ALL\n                    };\n                };\n                exports1.clearAll = clearAll;\n                var resetTo = function(state) {\n                    return {\n                        type: constants_1.ACTION_TYPES.RESET_TO,\n                        state: state\n                    };\n                };\n                exports1.resetTo = resetTo;\n                var setIsLoading = function(isLoading) {\n                    return {\n                        type: constants_1.ACTION_TYPES.SET_IS_LOADING,\n                        isLoading: isLoading\n                    };\n                };\n                exports1.setIsLoading = setIsLoading;\n            /***/ },\n            /***/ 373: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_6691__) {\n                var __spreadArray = this && this.__spreadArray || function(to, from, pack) {\n                    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n                        if (ar || !(i in from)) {\n                            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                            ar[i] = from[i];\n                        }\n                    }\n                    return to.concat(ar || Array.prototype.slice.call(from));\n                };\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var deepmerge_1 = __importDefault(__nested_webpack_require_6691__(996));\n                /* eslint-disable @typescript-eslint/no-explicit-any */ var fuse_js_1 = __importDefault(__nested_webpack_require_6691__(221));\n                var choices_1 = __nested_webpack_require_6691__(282);\n                var groups_1 = __nested_webpack_require_6691__(783);\n                var items_1 = __nested_webpack_require_6691__(464);\n                var misc_1 = __nested_webpack_require_6691__(137);\n                var components_1 = __nested_webpack_require_6691__(520);\n                var constants_1 = __nested_webpack_require_6691__(883);\n                var defaults_1 = __nested_webpack_require_6691__(789);\n                var utils_1 = __nested_webpack_require_6691__(799);\n                var reducers_1 = __nested_webpack_require_6691__(655);\n                var store_1 = __importDefault(__nested_webpack_require_6691__(744));\n                var templates_1 = __importDefault(__nested_webpack_require_6691__(686));\n                /** @see {@link http://browserhacks.com/#hack-acea075d0ac6954f275a70023906050c} */ var IS_IE11 = \"-ms-scroll-limit\" in document.documentElement.style && \"-ms-ime-align\" in document.documentElement.style;\n                var USER_DEFAULTS = {};\n                /**\n * Choices\n * @author Josh Johnson<josh@joshuajohnson.co.uk>\n */ var Choices = /** @class */ function() {\n                    function Choices(element, userConfig) {\n                        if (element === void 0) {\n                            element = \"[data-choice]\";\n                        }\n                        if (userConfig === void 0) {\n                            userConfig = {};\n                        }\n                        var _this = this;\n                        if (userConfig.allowHTML === undefined) {\n                            console.warn(\"Deprecation warning: allowHTML will default to false in a future release. To render HTML in Choices, you will need to set it to true. Setting allowHTML will suppress this message.\");\n                        }\n                        this.config = deepmerge_1.default.all([\n                            defaults_1.DEFAULT_CONFIG,\n                            Choices.defaults.options,\n                            userConfig\n                        ], // When merging array configs, replace with a copy of the userConfig array,\n                        // instead of concatenating with the default array\n                        {\n                            arrayMerge: function(_, sourceArray) {\n                                return __spreadArray([], sourceArray, true);\n                            }\n                        });\n                        var invalidConfigOptions = (0, utils_1.diff)(this.config, defaults_1.DEFAULT_CONFIG);\n                        if (invalidConfigOptions.length) {\n                            console.warn(\"Unknown config option(s) passed\", invalidConfigOptions.join(\", \"));\n                        }\n                        var passedElement = typeof element === \"string\" ? document.querySelector(element) : element;\n                        if (!(passedElement instanceof HTMLInputElement || passedElement instanceof HTMLSelectElement)) {\n                            throw TypeError(\"Expected one of the following types text|select-one|select-multiple\");\n                        }\n                        this._isTextElement = passedElement.type === constants_1.TEXT_TYPE;\n                        this._isSelectOneElement = passedElement.type === constants_1.SELECT_ONE_TYPE;\n                        this._isSelectMultipleElement = passedElement.type === constants_1.SELECT_MULTIPLE_TYPE;\n                        this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement;\n                        this.config.searchEnabled = this._isSelectMultipleElement || this.config.searchEnabled;\n                        if (![\n                            \"auto\",\n                            \"always\"\n                        ].includes(\"\".concat(this.config.renderSelectedChoices))) {\n                            this.config.renderSelectedChoices = \"auto\";\n                        }\n                        if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== \"function\") {\n                            var re = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);\n                            this.config.addItemFilter = re.test.bind(re);\n                        }\n                        if (this._isTextElement) {\n                            this.passedElement = new components_1.WrappedInput({\n                                element: passedElement,\n                                classNames: this.config.classNames,\n                                delimiter: this.config.delimiter\n                            });\n                        } else {\n                            this.passedElement = new components_1.WrappedSelect({\n                                element: passedElement,\n                                classNames: this.config.classNames,\n                                template: function(data) {\n                                    return _this._templates.option(data);\n                                }\n                            });\n                        }\n                        this.initialised = false;\n                        this._store = new store_1.default();\n                        this._initialState = reducers_1.defaultState;\n                        this._currentState = reducers_1.defaultState;\n                        this._prevState = reducers_1.defaultState;\n                        this._currentValue = \"\";\n                        this._canSearch = !!this.config.searchEnabled;\n                        this._isScrollingOnIe = false;\n                        this._highlightPosition = 0;\n                        this._wasTap = true;\n                        this._placeholderValue = this._generatePlaceholderValue();\n                        this._baseId = (0, utils_1.generateId)(this.passedElement.element, \"choices-\");\n                        /**\n     * setting direction in cases where it's explicitly set on passedElement\n     * or when calculated direction is different from the document\n     */ this._direction = this.passedElement.dir;\n                        if (!this._direction) {\n                            var elementDirection = window.getComputedStyle(this.passedElement.element).direction;\n                            var documentDirection = window.getComputedStyle(document.documentElement).direction;\n                            if (elementDirection !== documentDirection) {\n                                this._direction = elementDirection;\n                            }\n                        }\n                        this._idNames = {\n                            itemChoice: \"item-choice\"\n                        };\n                        if (this._isSelectElement) {\n                            // Assign preset groups from passed element\n                            this._presetGroups = this.passedElement.optionGroups;\n                            // Assign preset options from passed element\n                            this._presetOptions = this.passedElement.options;\n                        }\n                        // Assign preset choices from passed object\n                        this._presetChoices = this.config.choices;\n                        // Assign preset items from passed object first\n                        this._presetItems = this.config.items;\n                        // Add any values passed from attribute\n                        if (this.passedElement.value && this._isTextElement) {\n                            var splitValues = this.passedElement.value.split(this.config.delimiter);\n                            this._presetItems = this._presetItems.concat(splitValues);\n                        }\n                        // Create array of choices from option elements\n                        if (this.passedElement.options) {\n                            this.passedElement.options.forEach(function(option) {\n                                _this._presetChoices.push({\n                                    value: option.value,\n                                    label: option.innerHTML,\n                                    selected: !!option.selected,\n                                    disabled: option.disabled || option.parentNode.disabled,\n                                    placeholder: option.value === \"\" || option.hasAttribute(\"placeholder\"),\n                                    customProperties: (0, utils_1.parseCustomProperties)(option.dataset.customProperties)\n                                });\n                            });\n                        }\n                        this._render = this._render.bind(this);\n                        this._onFocus = this._onFocus.bind(this);\n                        this._onBlur = this._onBlur.bind(this);\n                        this._onKeyUp = this._onKeyUp.bind(this);\n                        this._onKeyDown = this._onKeyDown.bind(this);\n                        this._onClick = this._onClick.bind(this);\n                        this._onTouchMove = this._onTouchMove.bind(this);\n                        this._onTouchEnd = this._onTouchEnd.bind(this);\n                        this._onMouseDown = this._onMouseDown.bind(this);\n                        this._onMouseOver = this._onMouseOver.bind(this);\n                        this._onFormReset = this._onFormReset.bind(this);\n                        this._onSelectKey = this._onSelectKey.bind(this);\n                        this._onEnterKey = this._onEnterKey.bind(this);\n                        this._onEscapeKey = this._onEscapeKey.bind(this);\n                        this._onDirectionKey = this._onDirectionKey.bind(this);\n                        this._onDeleteKey = this._onDeleteKey.bind(this);\n                        // If element has already been initialised with Choices, fail silently\n                        if (this.passedElement.isActive) {\n                            if (!this.config.silent) {\n                                console.warn(\"Trying to initialise Choices on element already initialised\", {\n                                    element: element\n                                });\n                            }\n                            this.initialised = true;\n                            return;\n                        }\n                        // Let's go\n                        this.init();\n                    }\n                    Object.defineProperty(Choices, \"defaults\", {\n                        get: function() {\n                            return Object.preventExtensions({\n                                get options () {\n                                    return USER_DEFAULTS;\n                                },\n                                get templates () {\n                                    return templates_1.default;\n                                }\n                            });\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Choices.prototype.init = function() {\n                        if (this.initialised) {\n                            return;\n                        }\n                        this._createTemplates();\n                        this._createElements();\n                        this._createStructure();\n                        this._store.subscribe(this._render);\n                        this._render();\n                        this._addEventListeners();\n                        var shouldDisable = !this.config.addItems || this.passedElement.element.hasAttribute(\"disabled\");\n                        if (shouldDisable) {\n                            this.disable();\n                        }\n                        this.initialised = true;\n                        var callbackOnInit = this.config.callbackOnInit;\n                        // Run callback if it is a function\n                        if (callbackOnInit && typeof callbackOnInit === \"function\") {\n                            callbackOnInit.call(this);\n                        }\n                    };\n                    Choices.prototype.destroy = function() {\n                        if (!this.initialised) {\n                            return;\n                        }\n                        this._removeEventListeners();\n                        this.passedElement.reveal();\n                        this.containerOuter.unwrap(this.passedElement.element);\n                        this.clearStore();\n                        if (this._isSelectElement) {\n                            this.passedElement.options = this._presetOptions;\n                        }\n                        this._templates = templates_1.default;\n                        this.initialised = false;\n                    };\n                    Choices.prototype.enable = function() {\n                        if (this.passedElement.isDisabled) {\n                            this.passedElement.enable();\n                        }\n                        if (this.containerOuter.isDisabled) {\n                            this._addEventListeners();\n                            this.input.enable();\n                            this.containerOuter.enable();\n                        }\n                        return this;\n                    };\n                    Choices.prototype.disable = function() {\n                        if (!this.passedElement.isDisabled) {\n                            this.passedElement.disable();\n                        }\n                        if (!this.containerOuter.isDisabled) {\n                            this._removeEventListeners();\n                            this.input.disable();\n                            this.containerOuter.disable();\n                        }\n                        return this;\n                    };\n                    Choices.prototype.highlightItem = function(item, runEvent) {\n                        if (runEvent === void 0) {\n                            runEvent = true;\n                        }\n                        if (!item || !item.id) {\n                            return this;\n                        }\n                        var id = item.id, _a = item.groupId, groupId = _a === void 0 ? -1 : _a, _b = item.value, value = _b === void 0 ? \"\" : _b, _c = item.label, label = _c === void 0 ? \"\" : _c;\n                        var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;\n                        this._store.dispatch((0, items_1.highlightItem)(id, true));\n                        if (runEvent) {\n                            this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {\n                                id: id,\n                                value: value,\n                                label: label,\n                                groupValue: group && group.value ? group.value : null\n                            });\n                        }\n                        return this;\n                    };\n                    Choices.prototype.unhighlightItem = function(item) {\n                        if (!item || !item.id) {\n                            return this;\n                        }\n                        var id = item.id, _a = item.groupId, groupId = _a === void 0 ? -1 : _a, _b = item.value, value = _b === void 0 ? \"\" : _b, _c = item.label, label = _c === void 0 ? \"\" : _c;\n                        var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;\n                        this._store.dispatch((0, items_1.highlightItem)(id, false));\n                        this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {\n                            id: id,\n                            value: value,\n                            label: label,\n                            groupValue: group && group.value ? group.value : null\n                        });\n                        return this;\n                    };\n                    Choices.prototype.highlightAll = function() {\n                        var _this = this;\n                        this._store.items.forEach(function(item) {\n                            return _this.highlightItem(item);\n                        });\n                        return this;\n                    };\n                    Choices.prototype.unhighlightAll = function() {\n                        var _this = this;\n                        this._store.items.forEach(function(item) {\n                            return _this.unhighlightItem(item);\n                        });\n                        return this;\n                    };\n                    Choices.prototype.removeActiveItemsByValue = function(value) {\n                        var _this = this;\n                        this._store.activeItems.filter(function(item) {\n                            return item.value === value;\n                        }).forEach(function(item) {\n                            return _this._removeItem(item);\n                        });\n                        return this;\n                    };\n                    Choices.prototype.removeActiveItems = function(excludedId) {\n                        var _this = this;\n                        this._store.activeItems.filter(function(_a) {\n                            var id = _a.id;\n                            return id !== excludedId;\n                        }).forEach(function(item) {\n                            return _this._removeItem(item);\n                        });\n                        return this;\n                    };\n                    Choices.prototype.removeHighlightedItems = function(runEvent) {\n                        var _this = this;\n                        if (runEvent === void 0) {\n                            runEvent = false;\n                        }\n                        this._store.highlightedActiveItems.forEach(function(item) {\n                            _this._removeItem(item);\n                            // If this action was performed by the user\n                            // trigger the event\n                            if (runEvent) {\n                                _this._triggerChange(item.value);\n                            }\n                        });\n                        return this;\n                    };\n                    Choices.prototype.showDropdown = function(preventInputFocus) {\n                        var _this = this;\n                        if (this.dropdown.isActive) {\n                            return this;\n                        }\n                        requestAnimationFrame(function() {\n                            _this.dropdown.show();\n                            _this.containerOuter.open(_this.dropdown.distanceFromTopWindow);\n                            if (!preventInputFocus && _this._canSearch) {\n                                _this.input.focus();\n                            }\n                            _this.passedElement.triggerEvent(constants_1.EVENTS.showDropdown, {});\n                        });\n                        return this;\n                    };\n                    Choices.prototype.hideDropdown = function(preventInputBlur) {\n                        var _this = this;\n                        if (!this.dropdown.isActive) {\n                            return this;\n                        }\n                        requestAnimationFrame(function() {\n                            _this.dropdown.hide();\n                            _this.containerOuter.close();\n                            if (!preventInputBlur && _this._canSearch) {\n                                _this.input.removeActiveDescendant();\n                                _this.input.blur();\n                            }\n                            _this.passedElement.triggerEvent(constants_1.EVENTS.hideDropdown, {});\n                        });\n                        return this;\n                    };\n                    Choices.prototype.getValue = function(valueOnly) {\n                        if (valueOnly === void 0) {\n                            valueOnly = false;\n                        }\n                        var values = this._store.activeItems.reduce(function(selectedItems, item) {\n                            var itemValue = valueOnly ? item.value : item;\n                            selectedItems.push(itemValue);\n                            return selectedItems;\n                        }, []);\n                        return this._isSelectOneElement ? values[0] : values;\n                    };\n                    Choices.prototype.setValue = function(items) {\n                        var _this = this;\n                        if (!this.initialised) {\n                            return this;\n                        }\n                        items.forEach(function(value) {\n                            return _this._setChoiceOrItem(value);\n                        });\n                        return this;\n                    };\n                    Choices.prototype.setChoiceByValue = function(value) {\n                        var _this = this;\n                        if (!this.initialised || this._isTextElement) {\n                            return this;\n                        }\n                        // If only one value has been passed, convert to array\n                        var choiceValue = Array.isArray(value) ? value : [\n                            value\n                        ];\n                        // Loop through each value and\n                        choiceValue.forEach(function(val) {\n                            return _this._findAndSelectChoiceByValue(val);\n                        });\n                        return this;\n                    };\n                    /**\n   * Set choices of select input via an array of objects (or function that returns array of object or promise of it),\n   * a value field name and a label field name.\n   * This behaves the same as passing items via the choices option but can be called after initialising Choices.\n   * This can also be used to add groups of choices (see example 2); Optionally pass a true `replaceChoices` value to remove any existing choices.\n   * Optionally pass a `customProperties` object to add additional data to your choices (useful when searching/filtering etc).\n   *\n   * **Input types affected:** select-one, select-multiple\n   *\n   * @example\n   * ```js\n   * const example = new Choices(element);\n   *\n   * example.setChoices([\n   *   {value: 'One', label: 'Label One', disabled: true},\n   *   {value: 'Two', label: 'Label Two', selected: true},\n   *   {value: 'Three', label: 'Label Three'},\n   * ], 'value', 'label', false);\n   * ```\n   *\n   * @example\n   * ```js\n   * const example = new Choices(element);\n   *\n   * example.setChoices(async () => {\n   *   try {\n   *      const items = await fetch('/items');\n   *      return items.json()\n   *   } catch(err) {\n   *      console.error(err)\n   *   }\n   * });\n   * ```\n   *\n   * @example\n   * ```js\n   * const example = new Choices(element);\n   *\n   * example.setChoices([{\n   *   label: 'Group one',\n   *   id: 1,\n   *   disabled: false,\n   *   choices: [\n   *     {value: 'Child One', label: 'Child One', selected: true},\n   *     {value: 'Child Two', label: 'Child Two',  disabled: true},\n   *     {value: 'Child Three', label: 'Child Three'},\n   *   ]\n   * },\n   * {\n   *   label: 'Group two',\n   *   id: 2,\n   *   disabled: false,\n   *   choices: [\n   *     {value: 'Child Four', label: 'Child Four', disabled: true},\n   *     {value: 'Child Five', label: 'Child Five'},\n   *     {value: 'Child Six', label: 'Child Six', customProperties: {\n   *       description: 'Custom description about child six',\n   *       random: 'Another random custom property'\n   *     }},\n   *   ]\n   * }], 'value', 'label', false);\n   * ```\n   */ Choices.prototype.setChoices = function(choicesArrayOrFetcher, value, label, replaceChoices) {\n                        var _this = this;\n                        if (choicesArrayOrFetcher === void 0) {\n                            choicesArrayOrFetcher = [];\n                        }\n                        if (value === void 0) {\n                            value = \"value\";\n                        }\n                        if (label === void 0) {\n                            label = \"label\";\n                        }\n                        if (replaceChoices === void 0) {\n                            replaceChoices = false;\n                        }\n                        if (!this.initialised) {\n                            throw new ReferenceError(\"setChoices was called on a non-initialized instance of Choices\");\n                        }\n                        if (!this._isSelectElement) {\n                            throw new TypeError(\"setChoices can't be used with INPUT based Choices\");\n                        }\n                        if (typeof value !== \"string\" || !value) {\n                            throw new TypeError(\"value parameter must be a name of 'value' field in passed objects\");\n                        }\n                        // Clear choices if needed\n                        if (replaceChoices) {\n                            this.clearChoices();\n                        }\n                        if (typeof choicesArrayOrFetcher === \"function\") {\n                            // it's a choices fetcher function\n                            var fetcher_1 = choicesArrayOrFetcher(this);\n                            if (typeof Promise === \"function\" && fetcher_1 instanceof Promise) {\n                                // that's a promise\n                                // eslint-disable-next-line no-promise-executor-return\n                                return new Promise(function(resolve) {\n                                    return requestAnimationFrame(resolve);\n                                }).then(function() {\n                                    return _this._handleLoadingState(true);\n                                }).then(function() {\n                                    return fetcher_1;\n                                }).then(function(data) {\n                                    return _this.setChoices(data, value, label, replaceChoices);\n                                }).catch(function(err) {\n                                    if (!_this.config.silent) {\n                                        console.error(err);\n                                    }\n                                }).then(function() {\n                                    return _this._handleLoadingState(false);\n                                }).then(function() {\n                                    return _this;\n                                });\n                            }\n                            // function returned something else than promise, let's check if it's an array of choices\n                            if (!Array.isArray(fetcher_1)) {\n                                throw new TypeError(\".setChoices first argument function must return either array of choices or Promise, got: \".concat(typeof fetcher_1));\n                            }\n                            // recursion with results, it's sync and choices were cleared already\n                            return this.setChoices(fetcher_1, value, label, false);\n                        }\n                        if (!Array.isArray(choicesArrayOrFetcher)) {\n                            throw new TypeError(\".setChoices must be called either with array of choices with a function resulting into Promise of array of choices\");\n                        }\n                        this.containerOuter.removeLoadingState();\n                        this._startLoading();\n                        choicesArrayOrFetcher.forEach(function(groupOrChoice) {\n                            if (groupOrChoice.choices) {\n                                _this._addGroup({\n                                    id: groupOrChoice.id ? parseInt(\"\".concat(groupOrChoice.id), 10) : null,\n                                    group: groupOrChoice,\n                                    valueKey: value,\n                                    labelKey: label\n                                });\n                            } else {\n                                var choice = groupOrChoice;\n                                _this._addChoice({\n                                    value: choice[value],\n                                    label: choice[label],\n                                    isSelected: !!choice.selected,\n                                    isDisabled: !!choice.disabled,\n                                    placeholder: !!choice.placeholder,\n                                    customProperties: choice.customProperties\n                                });\n                            }\n                        });\n                        this._stopLoading();\n                        return this;\n                    };\n                    Choices.prototype.clearChoices = function() {\n                        this._store.dispatch((0, choices_1.clearChoices)());\n                        return this;\n                    };\n                    Choices.prototype.clearStore = function() {\n                        this._store.dispatch((0, misc_1.clearAll)());\n                        return this;\n                    };\n                    Choices.prototype.clearInput = function() {\n                        var shouldSetInputWidth = !this._isSelectOneElement;\n                        this.input.clear(shouldSetInputWidth);\n                        if (!this._isTextElement && this._canSearch) {\n                            this._isSearching = false;\n                            this._store.dispatch((0, choices_1.activateChoices)(true));\n                        }\n                        return this;\n                    };\n                    Choices.prototype._render = function() {\n                        if (this._store.isLoading()) {\n                            return;\n                        }\n                        this._currentState = this._store.state;\n                        var stateChanged = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items;\n                        var shouldRenderChoices = this._isSelectElement;\n                        var shouldRenderItems = this._currentState.items !== this._prevState.items;\n                        if (!stateChanged) {\n                            return;\n                        }\n                        if (shouldRenderChoices) {\n                            this._renderChoices();\n                        }\n                        if (shouldRenderItems) {\n                            this._renderItems();\n                        }\n                        this._prevState = this._currentState;\n                    };\n                    Choices.prototype._renderChoices = function() {\n                        var _this = this;\n                        var _a = this._store, activeGroups = _a.activeGroups, activeChoices = _a.activeChoices;\n                        var choiceListFragment = document.createDocumentFragment();\n                        this.choiceList.clear();\n                        if (this.config.resetScrollPosition) {\n                            requestAnimationFrame(function() {\n                                return _this.choiceList.scrollToTop();\n                            });\n                        }\n                        // If we have grouped options\n                        if (activeGroups.length >= 1 && !this._isSearching) {\n                            // If we have a placeholder choice along with groups\n                            var activePlaceholders = activeChoices.filter(function(activeChoice) {\n                                return activeChoice.placeholder === true && activeChoice.groupId === -1;\n                            });\n                            if (activePlaceholders.length >= 1) {\n                                choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);\n                            }\n                            choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);\n                        } else if (activeChoices.length >= 1) {\n                            choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);\n                        }\n                        // If we have choices to show\n                        if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {\n                            var activeItems = this._store.activeItems;\n                            var canAddItem = this._canAddItem(activeItems, this.input.value);\n                            // ...and we can select them\n                            if (canAddItem.response) {\n                                // ...append them and highlight the first choice\n                                this.choiceList.append(choiceListFragment);\n                                this._highlightChoice();\n                            } else {\n                                var notice = this._getTemplate(\"notice\", canAddItem.notice);\n                                this.choiceList.append(notice);\n                            }\n                        } else {\n                            // Otherwise show a notice\n                            var dropdownItem = void 0;\n                            var notice = void 0;\n                            if (this._isSearching) {\n                                notice = typeof this.config.noResultsText === \"function\" ? this.config.noResultsText() : this.config.noResultsText;\n                                dropdownItem = this._getTemplate(\"notice\", notice, \"no-results\");\n                            } else {\n                                notice = typeof this.config.noChoicesText === \"function\" ? this.config.noChoicesText() : this.config.noChoicesText;\n                                dropdownItem = this._getTemplate(\"notice\", notice, \"no-choices\");\n                            }\n                            this.choiceList.append(dropdownItem);\n                        }\n                    };\n                    Choices.prototype._renderItems = function() {\n                        var activeItems = this._store.activeItems || [];\n                        this.itemList.clear();\n                        // Create a fragment to store our list items\n                        // (so we don't have to update the DOM for each item)\n                        var itemListFragment = this._createItemsFragment(activeItems);\n                        // If we have items to add, append them\n                        if (itemListFragment.childNodes) {\n                            this.itemList.append(itemListFragment);\n                        }\n                    };\n                    Choices.prototype._createGroupsFragment = function(groups, choices, fragment) {\n                        var _this = this;\n                        if (fragment === void 0) {\n                            fragment = document.createDocumentFragment();\n                        }\n                        var getGroupChoices = function(group) {\n                            return choices.filter(function(choice) {\n                                if (_this._isSelectOneElement) {\n                                    return choice.groupId === group.id;\n                                }\n                                return choice.groupId === group.id && (_this.config.renderSelectedChoices === \"always\" || !choice.selected);\n                            });\n                        };\n                        // If sorting is enabled, filter groups\n                        if (this.config.shouldSort) {\n                            groups.sort(this.config.sorter);\n                        }\n                        groups.forEach(function(group) {\n                            var groupChoices = getGroupChoices(group);\n                            if (groupChoices.length >= 1) {\n                                var dropdownGroup = _this._getTemplate(\"choiceGroup\", group);\n                                fragment.appendChild(dropdownGroup);\n                                _this._createChoicesFragment(groupChoices, fragment, true);\n                            }\n                        });\n                        return fragment;\n                    };\n                    Choices.prototype._createChoicesFragment = function(choices, fragment, withinGroup) {\n                        var _this = this;\n                        if (fragment === void 0) {\n                            fragment = document.createDocumentFragment();\n                        }\n                        if (withinGroup === void 0) {\n                            withinGroup = false;\n                        }\n                        // Create a fragment to store our list items (so we don't have to update the DOM for each item)\n                        var _a = this.config, renderSelectedChoices = _a.renderSelectedChoices, searchResultLimit = _a.searchResultLimit, renderChoiceLimit = _a.renderChoiceLimit;\n                        var filter = this._isSearching ? utils_1.sortByScore : this.config.sorter;\n                        var appendChoice = function(choice) {\n                            var shouldRender = renderSelectedChoices === \"auto\" ? _this._isSelectOneElement || !choice.selected : true;\n                            if (shouldRender) {\n                                var dropdownItem = _this._getTemplate(\"choice\", choice, _this.config.itemSelectText);\n                                fragment.appendChild(dropdownItem);\n                            }\n                        };\n                        var rendererableChoices = choices;\n                        if (renderSelectedChoices === \"auto\" && !this._isSelectOneElement) {\n                            rendererableChoices = choices.filter(function(choice) {\n                                return !choice.selected;\n                            });\n                        }\n                        // Split array into placeholders and \"normal\" choices\n                        var _b = rendererableChoices.reduce(function(acc, choice) {\n                            if (choice.placeholder) {\n                                acc.placeholderChoices.push(choice);\n                            } else {\n                                acc.normalChoices.push(choice);\n                            }\n                            return acc;\n                        }, {\n                            placeholderChoices: [],\n                            normalChoices: []\n                        }), placeholderChoices = _b.placeholderChoices, normalChoices = _b.normalChoices;\n                        // If sorting is enabled or the user is searching, filter choices\n                        if (this.config.shouldSort || this._isSearching) {\n                            normalChoices.sort(filter);\n                        }\n                        var choiceLimit = rendererableChoices.length;\n                        // Prepend placeholeder\n                        var sortedChoices = this._isSelectOneElement ? __spreadArray(__spreadArray([], placeholderChoices, true), normalChoices, true) : normalChoices;\n                        if (this._isSearching) {\n                            choiceLimit = searchResultLimit;\n                        } else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {\n                            choiceLimit = renderChoiceLimit;\n                        }\n                        // Add each choice to dropdown within range\n                        for(var i = 0; i < choiceLimit; i += 1){\n                            if (sortedChoices[i]) {\n                                appendChoice(sortedChoices[i]);\n                            }\n                        }\n                        return fragment;\n                    };\n                    Choices.prototype._createItemsFragment = function(items, fragment) {\n                        var _this = this;\n                        if (fragment === void 0) {\n                            fragment = document.createDocumentFragment();\n                        }\n                        // Create fragment to add elements to\n                        var _a = this.config, shouldSortItems = _a.shouldSortItems, sorter = _a.sorter, removeItemButton = _a.removeItemButton;\n                        // If sorting is enabled, filter items\n                        if (shouldSortItems && !this._isSelectOneElement) {\n                            items.sort(sorter);\n                        }\n                        if (this._isTextElement) {\n                            // Update the value of the hidden input\n                            this.passedElement.value = items.map(function(_a) {\n                                var value = _a.value;\n                                return value;\n                            }).join(this.config.delimiter);\n                        } else {\n                            // Update the options of the hidden input\n                            this.passedElement.options = items;\n                        }\n                        var addItemToFragment = function(item) {\n                            // Create new list element\n                            var listItem = _this._getTemplate(\"item\", item, removeItemButton);\n                            // Append it to list\n                            fragment.appendChild(listItem);\n                        };\n                        // Add each list item to list\n                        items.forEach(addItemToFragment);\n                        return fragment;\n                    };\n                    Choices.prototype._triggerChange = function(value) {\n                        if (value === undefined || value === null) {\n                            return;\n                        }\n                        this.passedElement.triggerEvent(constants_1.EVENTS.change, {\n                            value: value\n                        });\n                    };\n                    Choices.prototype._selectPlaceholderChoice = function(placeholderChoice) {\n                        this._addItem({\n                            value: placeholderChoice.value,\n                            label: placeholderChoice.label,\n                            choiceId: placeholderChoice.id,\n                            groupId: placeholderChoice.groupId,\n                            placeholder: placeholderChoice.placeholder\n                        });\n                        this._triggerChange(placeholderChoice.value);\n                    };\n                    Choices.prototype._handleButtonAction = function(activeItems, element) {\n                        if (!activeItems || !element || !this.config.removeItems || !this.config.removeItemButton) {\n                            return;\n                        }\n                        var itemId = element.parentNode && element.parentNode.dataset.id;\n                        var itemToRemove = itemId && activeItems.find(function(item) {\n                            return item.id === parseInt(itemId, 10);\n                        });\n                        if (!itemToRemove) {\n                            return;\n                        }\n                        // Remove item associated with button\n                        this._removeItem(itemToRemove);\n                        this._triggerChange(itemToRemove.value);\n                        if (this._isSelectOneElement && this._store.placeholderChoice) {\n                            this._selectPlaceholderChoice(this._store.placeholderChoice);\n                        }\n                    };\n                    Choices.prototype._handleItemAction = function(activeItems, element, hasShiftKey) {\n                        var _this = this;\n                        if (hasShiftKey === void 0) {\n                            hasShiftKey = false;\n                        }\n                        if (!activeItems || !element || !this.config.removeItems || this._isSelectOneElement) {\n                            return;\n                        }\n                        var passedId = element.dataset.id;\n                        // We only want to select one item with a click\n                        // so we deselect any items that aren't the target\n                        // unless shift is being pressed\n                        activeItems.forEach(function(item) {\n                            if (item.id === parseInt(\"\".concat(passedId), 10) && !item.highlighted) {\n                                _this.highlightItem(item);\n                            } else if (!hasShiftKey && item.highlighted) {\n                                _this.unhighlightItem(item);\n                            }\n                        });\n                        // Focus input as without focus, a user cannot do anything with a\n                        // highlighted item\n                        this.input.focus();\n                    };\n                    Choices.prototype._handleChoiceAction = function(activeItems, element) {\n                        if (!activeItems || !element) {\n                            return;\n                        }\n                        // If we are clicking on an option\n                        var id = element.dataset.id;\n                        var choice = id && this._store.getChoiceById(id);\n                        if (!choice) {\n                            return;\n                        }\n                        var passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : undefined;\n                        var hasActiveDropdown = this.dropdown.isActive;\n                        // Update choice keyCode\n                        choice.keyCode = passedKeyCode;\n                        this.passedElement.triggerEvent(constants_1.EVENTS.choice, {\n                            choice: choice\n                        });\n                        if (!choice.selected && !choice.disabled) {\n                            var canAddItem = this._canAddItem(activeItems, choice.value);\n                            if (canAddItem.response) {\n                                this._addItem({\n                                    value: choice.value,\n                                    label: choice.label,\n                                    choiceId: choice.id,\n                                    groupId: choice.groupId,\n                                    customProperties: choice.customProperties,\n                                    placeholder: choice.placeholder,\n                                    keyCode: choice.keyCode\n                                });\n                                this._triggerChange(choice.value);\n                            }\n                        }\n                        this.clearInput();\n                        // We want to close the dropdown if we are dealing with a single select box\n                        if (hasActiveDropdown && this._isSelectOneElement) {\n                            this.hideDropdown(true);\n                            this.containerOuter.focus();\n                        }\n                    };\n                    Choices.prototype._handleBackspace = function(activeItems) {\n                        if (!this.config.removeItems || !activeItems) {\n                            return;\n                        }\n                        var lastItem = activeItems[activeItems.length - 1];\n                        var hasHighlightedItems = activeItems.some(function(item) {\n                            return item.highlighted;\n                        });\n                        // If editing the last item is allowed and there are not other selected items,\n                        // we can edit the item value. Otherwise if we can remove items, remove all selected items\n                        if (this.config.editItems && !hasHighlightedItems && lastItem) {\n                            this.input.value = lastItem.value;\n                            this.input.setWidth();\n                            this._removeItem(lastItem);\n                            this._triggerChange(lastItem.value);\n                        } else {\n                            if (!hasHighlightedItems) {\n                                // Highlight last item if none already highlighted\n                                this.highlightItem(lastItem, false);\n                            }\n                            this.removeHighlightedItems(true);\n                        }\n                    };\n                    Choices.prototype._startLoading = function() {\n                        this._store.dispatch((0, misc_1.setIsLoading)(true));\n                    };\n                    Choices.prototype._stopLoading = function() {\n                        this._store.dispatch((0, misc_1.setIsLoading)(false));\n                    };\n                    Choices.prototype._handleLoadingState = function(setLoading) {\n                        if (setLoading === void 0) {\n                            setLoading = true;\n                        }\n                        var placeholderItem = this.itemList.getChild(\".\".concat(this.config.classNames.placeholder));\n                        if (setLoading) {\n                            this.disable();\n                            this.containerOuter.addLoadingState();\n                            if (this._isSelectOneElement) {\n                                if (!placeholderItem) {\n                                    placeholderItem = this._getTemplate(\"placeholder\", this.config.loadingText);\n                                    if (placeholderItem) {\n                                        this.itemList.append(placeholderItem);\n                                    }\n                                } else {\n                                    placeholderItem.innerHTML = this.config.loadingText;\n                                }\n                            } else {\n                                this.input.placeholder = this.config.loadingText;\n                            }\n                        } else {\n                            this.enable();\n                            this.containerOuter.removeLoadingState();\n                            if (this._isSelectOneElement) {\n                                if (placeholderItem) {\n                                    placeholderItem.innerHTML = this._placeholderValue || \"\";\n                                }\n                            } else {\n                                this.input.placeholder = this._placeholderValue || \"\";\n                            }\n                        }\n                    };\n                    Choices.prototype._handleSearch = function(value) {\n                        if (!this.input.isFocussed) {\n                            return;\n                        }\n                        var choices = this._store.choices;\n                        var _a = this.config, searchFloor = _a.searchFloor, searchChoices = _a.searchChoices;\n                        var hasUnactiveChoices = choices.some(function(option) {\n                            return !option.active;\n                        });\n                        // Check that we have a value to search and the input was an alphanumeric character\n                        if (value !== null && typeof value !== \"undefined\" && value.length >= searchFloor) {\n                            var resultCount = searchChoices ? this._searchChoices(value) : 0;\n                            // Trigger search event\n                            this.passedElement.triggerEvent(constants_1.EVENTS.search, {\n                                value: value,\n                                resultCount: resultCount\n                            });\n                        } else if (hasUnactiveChoices) {\n                            // Otherwise reset choices to active\n                            this._isSearching = false;\n                            this._store.dispatch((0, choices_1.activateChoices)(true));\n                        }\n                    };\n                    Choices.prototype._canAddItem = function(activeItems, value) {\n                        var canAddItem = true;\n                        var notice = typeof this.config.addItemText === \"function\" ? this.config.addItemText(value) : this.config.addItemText;\n                        if (!this._isSelectOneElement) {\n                            var isDuplicateValue = (0, utils_1.existsInArray)(activeItems, value);\n                            if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {\n                                // If there is a max entry limit and we have reached that limit\n                                // don't update\n                                canAddItem = false;\n                                notice = typeof this.config.maxItemText === \"function\" ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;\n                            }\n                            if (!this.config.duplicateItemsAllowed && isDuplicateValue && canAddItem) {\n                                canAddItem = false;\n                                notice = typeof this.config.uniqueItemText === \"function\" ? this.config.uniqueItemText(value) : this.config.uniqueItemText;\n                            }\n                            if (this._isTextElement && this.config.addItems && canAddItem && typeof this.config.addItemFilter === \"function\" && !this.config.addItemFilter(value)) {\n                                canAddItem = false;\n                                notice = typeof this.config.customAddItemText === \"function\" ? this.config.customAddItemText(value) : this.config.customAddItemText;\n                            }\n                        }\n                        return {\n                            response: canAddItem,\n                            notice: notice\n                        };\n                    };\n                    Choices.prototype._searchChoices = function(value) {\n                        var newValue = typeof value === \"string\" ? value.trim() : value;\n                        var currentValue = typeof this._currentValue === \"string\" ? this._currentValue.trim() : this._currentValue;\n                        if (newValue.length < 1 && newValue === \"\".concat(currentValue, \" \")) {\n                            return 0;\n                        }\n                        // If new value matches the desired length and is not the same as the current value with a space\n                        var haystack = this._store.searchableChoices;\n                        var needle = newValue;\n                        var options = Object.assign(this.config.fuseOptions, {\n                            keys: __spreadArray([], this.config.searchFields, true),\n                            includeMatches: true\n                        });\n                        var fuse = new fuse_js_1.default(haystack, options);\n                        var results = fuse.search(needle); // see https://github.com/krisk/Fuse/issues/303\n                        this._currentValue = newValue;\n                        this._highlightPosition = 0;\n                        this._isSearching = true;\n                        this._store.dispatch((0, choices_1.filterChoices)(results));\n                        return results.length;\n                    };\n                    Choices.prototype._addEventListeners = function() {\n                        var documentElement = document.documentElement;\n                        // capture events - can cancel event processing or propagation\n                        documentElement.addEventListener(\"touchend\", this._onTouchEnd, true);\n                        this.containerOuter.element.addEventListener(\"keydown\", this._onKeyDown, true);\n                        this.containerOuter.element.addEventListener(\"mousedown\", this._onMouseDown, true);\n                        // passive events - doesn't call `preventDefault` or `stopPropagation`\n                        documentElement.addEventListener(\"click\", this._onClick, {\n                            passive: true\n                        });\n                        documentElement.addEventListener(\"touchmove\", this._onTouchMove, {\n                            passive: true\n                        });\n                        this.dropdown.element.addEventListener(\"mouseover\", this._onMouseOver, {\n                            passive: true\n                        });\n                        if (this._isSelectOneElement) {\n                            this.containerOuter.element.addEventListener(\"focus\", this._onFocus, {\n                                passive: true\n                            });\n                            this.containerOuter.element.addEventListener(\"blur\", this._onBlur, {\n                                passive: true\n                            });\n                        }\n                        this.input.element.addEventListener(\"keyup\", this._onKeyUp, {\n                            passive: true\n                        });\n                        this.input.element.addEventListener(\"focus\", this._onFocus, {\n                            passive: true\n                        });\n                        this.input.element.addEventListener(\"blur\", this._onBlur, {\n                            passive: true\n                        });\n                        if (this.input.element.form) {\n                            this.input.element.form.addEventListener(\"reset\", this._onFormReset, {\n                                passive: true\n                            });\n                        }\n                        this.input.addEventListeners();\n                    };\n                    Choices.prototype._removeEventListeners = function() {\n                        var documentElement = document.documentElement;\n                        documentElement.removeEventListener(\"touchend\", this._onTouchEnd, true);\n                        this.containerOuter.element.removeEventListener(\"keydown\", this._onKeyDown, true);\n                        this.containerOuter.element.removeEventListener(\"mousedown\", this._onMouseDown, true);\n                        documentElement.removeEventListener(\"click\", this._onClick);\n                        documentElement.removeEventListener(\"touchmove\", this._onTouchMove);\n                        this.dropdown.element.removeEventListener(\"mouseover\", this._onMouseOver);\n                        if (this._isSelectOneElement) {\n                            this.containerOuter.element.removeEventListener(\"focus\", this._onFocus);\n                            this.containerOuter.element.removeEventListener(\"blur\", this._onBlur);\n                        }\n                        this.input.element.removeEventListener(\"keyup\", this._onKeyUp);\n                        this.input.element.removeEventListener(\"focus\", this._onFocus);\n                        this.input.element.removeEventListener(\"blur\", this._onBlur);\n                        if (this.input.element.form) {\n                            this.input.element.form.removeEventListener(\"reset\", this._onFormReset);\n                        }\n                        this.input.removeEventListeners();\n                    };\n                    Choices.prototype._onKeyDown = function(event) {\n                        var keyCode = event.keyCode;\n                        var activeItems = this._store.activeItems;\n                        var hasFocusedInput = this.input.isFocussed;\n                        var hasActiveDropdown = this.dropdown.isActive;\n                        var hasItems = this.itemList.hasChildren();\n                        var keyString = String.fromCharCode(keyCode);\n                        // eslint-disable-next-line no-control-regex\n                        var wasPrintableChar = /[^\\x00-\\x1F]/.test(keyString);\n                        var BACK_KEY = constants_1.KEY_CODES.BACK_KEY, DELETE_KEY = constants_1.KEY_CODES.DELETE_KEY, ENTER_KEY = constants_1.KEY_CODES.ENTER_KEY, A_KEY = constants_1.KEY_CODES.A_KEY, ESC_KEY = constants_1.KEY_CODES.ESC_KEY, UP_KEY = constants_1.KEY_CODES.UP_KEY, DOWN_KEY = constants_1.KEY_CODES.DOWN_KEY, PAGE_UP_KEY = constants_1.KEY_CODES.PAGE_UP_KEY, PAGE_DOWN_KEY = constants_1.KEY_CODES.PAGE_DOWN_KEY;\n                        if (!this._isTextElement && !hasActiveDropdown && wasPrintableChar) {\n                            this.showDropdown();\n                            if (!this.input.isFocussed) {\n                                /*\n          We update the input value with the pressed key as\n          the input was not focussed at the time of key press\n          therefore does not have the value of the key.\n        */ this.input.value += event.key.toLowerCase();\n                            }\n                        }\n                        switch(keyCode){\n                            case A_KEY:\n                                return this._onSelectKey(event, hasItems);\n                            case ENTER_KEY:\n                                return this._onEnterKey(event, activeItems, hasActiveDropdown);\n                            case ESC_KEY:\n                                return this._onEscapeKey(hasActiveDropdown);\n                            case UP_KEY:\n                            case PAGE_UP_KEY:\n                            case DOWN_KEY:\n                            case PAGE_DOWN_KEY:\n                                return this._onDirectionKey(event, hasActiveDropdown);\n                            case DELETE_KEY:\n                            case BACK_KEY:\n                                return this._onDeleteKey(event, activeItems, hasFocusedInput);\n                            default:\n                        }\n                    };\n                    Choices.prototype._onKeyUp = function(_a) {\n                        var target = _a.target, keyCode = _a.keyCode;\n                        var value = this.input.value;\n                        var activeItems = this._store.activeItems;\n                        var canAddItem = this._canAddItem(activeItems, value);\n                        var backKey = constants_1.KEY_CODES.BACK_KEY, deleteKey = constants_1.KEY_CODES.DELETE_KEY;\n                        // We are typing into a text input and have a value, we want to show a dropdown\n                        // notice. Otherwise hide the dropdown\n                        if (this._isTextElement) {\n                            var canShowDropdownNotice = canAddItem.notice && value;\n                            if (canShowDropdownNotice) {\n                                var dropdownItem = this._getTemplate(\"notice\", canAddItem.notice);\n                                this.dropdown.element.innerHTML = dropdownItem.outerHTML;\n                                this.showDropdown(true);\n                            } else {\n                                this.hideDropdown(true);\n                            }\n                        } else {\n                            var wasRemovalKeyCode = keyCode === backKey || keyCode === deleteKey;\n                            var userHasRemovedValue = wasRemovalKeyCode && target && !target.value;\n                            var canReactivateChoices = !this._isTextElement && this._isSearching;\n                            var canSearch = this._canSearch && canAddItem.response;\n                            if (userHasRemovedValue && canReactivateChoices) {\n                                this._isSearching = false;\n                                this._store.dispatch((0, choices_1.activateChoices)(true));\n                            } else if (canSearch) {\n                                this._handleSearch(this.input.rawValue);\n                            }\n                        }\n                        this._canSearch = this.config.searchEnabled;\n                    };\n                    Choices.prototype._onSelectKey = function(event, hasItems) {\n                        var ctrlKey = event.ctrlKey, metaKey = event.metaKey;\n                        var hasCtrlDownKeyPressed = ctrlKey || metaKey;\n                        // If CTRL + A or CMD + A have been pressed and there are items to select\n                        if (hasCtrlDownKeyPressed && hasItems) {\n                            this._canSearch = false;\n                            var shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;\n                            if (shouldHightlightAll) {\n                                this.highlightAll();\n                            }\n                        }\n                    };\n                    Choices.prototype._onEnterKey = function(event, activeItems, hasActiveDropdown) {\n                        var target = event.target;\n                        var enterKey = constants_1.KEY_CODES.ENTER_KEY;\n                        var targetWasButton = target && target.hasAttribute(\"data-button\");\n                        if (this._isTextElement && target && target.value) {\n                            var value = this.input.value;\n                            var canAddItem = this._canAddItem(activeItems, value);\n                            if (canAddItem.response) {\n                                this.hideDropdown(true);\n                                this._addItem({\n                                    value: value\n                                });\n                                this._triggerChange(value);\n                                this.clearInput();\n                            }\n                        }\n                        if (targetWasButton) {\n                            this._handleButtonAction(activeItems, target);\n                            event.preventDefault();\n                        }\n                        if (hasActiveDropdown) {\n                            var highlightedChoice = this.dropdown.getChild(\".\".concat(this.config.classNames.highlightedState));\n                            if (highlightedChoice) {\n                                // add enter keyCode value\n                                if (activeItems[0]) {\n                                    activeItems[0].keyCode = enterKey; // eslint-disable-line no-param-reassign\n                                }\n                                this._handleChoiceAction(activeItems, highlightedChoice);\n                            }\n                            event.preventDefault();\n                        } else if (this._isSelectOneElement) {\n                            this.showDropdown();\n                            event.preventDefault();\n                        }\n                    };\n                    Choices.prototype._onEscapeKey = function(hasActiveDropdown) {\n                        if (hasActiveDropdown) {\n                            this.hideDropdown(true);\n                            this.containerOuter.focus();\n                        }\n                    };\n                    Choices.prototype._onDirectionKey = function(event, hasActiveDropdown) {\n                        var keyCode = event.keyCode, metaKey = event.metaKey;\n                        var downKey = constants_1.KEY_CODES.DOWN_KEY, pageUpKey = constants_1.KEY_CODES.PAGE_UP_KEY, pageDownKey = constants_1.KEY_CODES.PAGE_DOWN_KEY;\n                        // If up or down key is pressed, traverse through options\n                        if (hasActiveDropdown || this._isSelectOneElement) {\n                            this.showDropdown();\n                            this._canSearch = false;\n                            var directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;\n                            var skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;\n                            var selectableChoiceIdentifier = \"[data-choice-selectable]\";\n                            var nextEl = void 0;\n                            if (skipKey) {\n                                if (directionInt > 0) {\n                                    nextEl = this.dropdown.element.querySelector(\"\".concat(selectableChoiceIdentifier, \":last-of-type\"));\n                                } else {\n                                    nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);\n                                }\n                            } else {\n                                var currentEl = this.dropdown.element.querySelector(\".\".concat(this.config.classNames.highlightedState));\n                                if (currentEl) {\n                                    nextEl = (0, utils_1.getAdjacentEl)(currentEl, selectableChoiceIdentifier, directionInt);\n                                } else {\n                                    nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);\n                                }\n                            }\n                            if (nextEl) {\n                                // We prevent default to stop the cursor moving\n                                // when pressing the arrow\n                                if (!(0, utils_1.isScrolledIntoView)(nextEl, this.choiceList.element, directionInt)) {\n                                    this.choiceList.scrollToChildElement(nextEl, directionInt);\n                                }\n                                this._highlightChoice(nextEl);\n                            }\n                            // Prevent default to maintain cursor position whilst\n                            // traversing dropdown options\n                            event.preventDefault();\n                        }\n                    };\n                    Choices.prototype._onDeleteKey = function(event, activeItems, hasFocusedInput) {\n                        var target = event.target;\n                        // If backspace or delete key is pressed and the input has no value\n                        if (!this._isSelectOneElement && !target.value && hasFocusedInput) {\n                            this._handleBackspace(activeItems);\n                            event.preventDefault();\n                        }\n                    };\n                    Choices.prototype._onTouchMove = function() {\n                        if (this._wasTap) {\n                            this._wasTap = false;\n                        }\n                    };\n                    Choices.prototype._onTouchEnd = function(event) {\n                        var target = (event || event.touches[0]).target;\n                        var touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);\n                        if (touchWasWithinContainer) {\n                            var containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;\n                            if (containerWasExactTarget) {\n                                if (this._isTextElement) {\n                                    this.input.focus();\n                                } else if (this._isSelectMultipleElement) {\n                                    this.showDropdown();\n                                }\n                            }\n                            // Prevents focus event firing\n                            event.stopPropagation();\n                        }\n                        this._wasTap = true;\n                    };\n                    /**\n   * Handles mousedown event in capture mode for containetOuter.element\n   */ Choices.prototype._onMouseDown = function(event) {\n                        var target = event.target;\n                        if (!(target instanceof HTMLElement)) {\n                            return;\n                        }\n                        // If we have our mouse down on the scrollbar and are on IE11...\n                        if (IS_IE11 && this.choiceList.element.contains(target)) {\n                            // check if click was on a scrollbar area\n                            var firstChoice = this.choiceList.element.firstElementChild;\n                            var isOnScrollbar = this._direction === \"ltr\" ? event.offsetX >= firstChoice.offsetWidth : event.offsetX < firstChoice.offsetLeft;\n                            this._isScrollingOnIe = isOnScrollbar;\n                        }\n                        if (target === this.input.element) {\n                            return;\n                        }\n                        var item = target.closest(\"[data-button],[data-item],[data-choice]\");\n                        if (item instanceof HTMLElement) {\n                            var hasShiftKey = event.shiftKey;\n                            var activeItems = this._store.activeItems;\n                            var dataset = item.dataset;\n                            if (\"button\" in dataset) {\n                                this._handleButtonAction(activeItems, item);\n                            } else if (\"item\" in dataset) {\n                                this._handleItemAction(activeItems, item, hasShiftKey);\n                            } else if (\"choice\" in dataset) {\n                                this._handleChoiceAction(activeItems, item);\n                            }\n                        }\n                        event.preventDefault();\n                    };\n                    /**\n   * Handles mouseover event over this.dropdown\n   * @param {MouseEvent} event\n   */ Choices.prototype._onMouseOver = function(_a) {\n                        var target = _a.target;\n                        if (target instanceof HTMLElement && \"choice\" in target.dataset) {\n                            this._highlightChoice(target);\n                        }\n                    };\n                    Choices.prototype._onClick = function(_a) {\n                        var target = _a.target;\n                        var clickWasWithinContainer = this.containerOuter.element.contains(target);\n                        if (clickWasWithinContainer) {\n                            if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {\n                                if (this._isTextElement) {\n                                    if (document.activeElement !== this.input.element) {\n                                        this.input.focus();\n                                    }\n                                } else {\n                                    this.showDropdown();\n                                    this.containerOuter.focus();\n                                }\n                            } else if (this._isSelectOneElement && target !== this.input.element && !this.dropdown.element.contains(target)) {\n                                this.hideDropdown();\n                            }\n                        } else {\n                            var hasHighlightedItems = this._store.highlightedActiveItems.length > 0;\n                            if (hasHighlightedItems) {\n                                this.unhighlightAll();\n                            }\n                            this.containerOuter.removeFocusState();\n                            this.hideDropdown(true);\n                        }\n                    };\n                    Choices.prototype._onFocus = function(_a) {\n                        var _b;\n                        var _this = this;\n                        var target = _a.target;\n                        var focusWasWithinContainer = target && this.containerOuter.element.contains(target);\n                        if (!focusWasWithinContainer) {\n                            return;\n                        }\n                        var focusActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function() {\n                            if (target === _this.input.element) {\n                                _this.containerOuter.addFocusState();\n                            }\n                        }, _b[constants_1.SELECT_ONE_TYPE] = function() {\n                            _this.containerOuter.addFocusState();\n                            if (target === _this.input.element) {\n                                _this.showDropdown(true);\n                            }\n                        }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function() {\n                            if (target === _this.input.element) {\n                                _this.showDropdown(true);\n                                // If element is a select box, the focused element is the container and the dropdown\n                                // isn't already open, focus and show dropdown\n                                _this.containerOuter.addFocusState();\n                            }\n                        }, _b);\n                        focusActions[this.passedElement.element.type]();\n                    };\n                    Choices.prototype._onBlur = function(_a) {\n                        var _b;\n                        var _this = this;\n                        var target = _a.target;\n                        var blurWasWithinContainer = target && this.containerOuter.element.contains(target);\n                        if (blurWasWithinContainer && !this._isScrollingOnIe) {\n                            var activeItems = this._store.activeItems;\n                            var hasHighlightedItems_1 = activeItems.some(function(item) {\n                                return item.highlighted;\n                            });\n                            var blurActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function() {\n                                if (target === _this.input.element) {\n                                    _this.containerOuter.removeFocusState();\n                                    if (hasHighlightedItems_1) {\n                                        _this.unhighlightAll();\n                                    }\n                                    _this.hideDropdown(true);\n                                }\n                            }, _b[constants_1.SELECT_ONE_TYPE] = function() {\n                                _this.containerOuter.removeFocusState();\n                                if (target === _this.input.element || target === _this.containerOuter.element && !_this._canSearch) {\n                                    _this.hideDropdown(true);\n                                }\n                            }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function() {\n                                if (target === _this.input.element) {\n                                    _this.containerOuter.removeFocusState();\n                                    _this.hideDropdown(true);\n                                    if (hasHighlightedItems_1) {\n                                        _this.unhighlightAll();\n                                    }\n                                }\n                            }, _b);\n                            blurActions[this.passedElement.element.type]();\n                        } else {\n                            // On IE11, clicking the scollbar blurs our input and thus\n                            // closes the dropdown. To stop this, we refocus our input\n                            // if we know we are on IE *and* are scrolling.\n                            this._isScrollingOnIe = false;\n                            this.input.element.focus();\n                        }\n                    };\n                    Choices.prototype._onFormReset = function() {\n                        this._store.dispatch((0, misc_1.resetTo)(this._initialState));\n                    };\n                    Choices.prototype._highlightChoice = function(el) {\n                        var _this = this;\n                        if (el === void 0) {\n                            el = null;\n                        }\n                        var choices = Array.from(this.dropdown.element.querySelectorAll(\"[data-choice-selectable]\"));\n                        if (!choices.length) {\n                            return;\n                        }\n                        var passedEl = el;\n                        var highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(\".\".concat(this.config.classNames.highlightedState)));\n                        // Remove any highlighted choices\n                        highlightedChoices.forEach(function(choice) {\n                            choice.classList.remove(_this.config.classNames.highlightedState);\n                            choice.setAttribute(\"aria-selected\", \"false\");\n                        });\n                        if (passedEl) {\n                            this._highlightPosition = choices.indexOf(passedEl);\n                        } else {\n                            // Highlight choice based on last known highlight location\n                            if (choices.length > this._highlightPosition) {\n                                // If we have an option to highlight\n                                passedEl = choices[this._highlightPosition];\n                            } else {\n                                // Otherwise highlight the option before\n                                passedEl = choices[choices.length - 1];\n                            }\n                            if (!passedEl) {\n                                passedEl = choices[0];\n                            }\n                        }\n                        passedEl.classList.add(this.config.classNames.highlightedState);\n                        passedEl.setAttribute(\"aria-selected\", \"true\");\n                        this.passedElement.triggerEvent(constants_1.EVENTS.highlightChoice, {\n                            el: passedEl\n                        });\n                        if (this.dropdown.isActive) {\n                            // IE11 ignores aria-label and blocks virtual keyboard\n                            // if aria-activedescendant is set without a dropdown\n                            this.input.setActiveDescendant(passedEl.id);\n                            this.containerOuter.setActiveDescendant(passedEl.id);\n                        }\n                    };\n                    Choices.prototype._addItem = function(_a) {\n                        var value = _a.value, _b = _a.label, label = _b === void 0 ? null : _b, _c = _a.choiceId, choiceId = _c === void 0 ? -1 : _c, _d = _a.groupId, groupId = _d === void 0 ? -1 : _d, _e = _a.customProperties, customProperties = _e === void 0 ? {} : _e, _f = _a.placeholder, placeholder = _f === void 0 ? false : _f, _g = _a.keyCode, keyCode = _g === void 0 ? -1 : _g;\n                        var passedValue = typeof value === \"string\" ? value.trim() : value;\n                        var items = this._store.items;\n                        var passedLabel = label || passedValue;\n                        var passedOptionId = choiceId || -1;\n                        var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;\n                        var id = items ? items.length + 1 : 1;\n                        // If a prepended value has been passed, prepend it\n                        if (this.config.prependValue) {\n                            passedValue = this.config.prependValue + passedValue.toString();\n                        }\n                        // If an appended value has been passed, append it\n                        if (this.config.appendValue) {\n                            passedValue += this.config.appendValue.toString();\n                        }\n                        this._store.dispatch((0, items_1.addItem)({\n                            value: passedValue,\n                            label: passedLabel,\n                            id: id,\n                            choiceId: passedOptionId,\n                            groupId: groupId,\n                            customProperties: customProperties,\n                            placeholder: placeholder,\n                            keyCode: keyCode\n                        }));\n                        if (this._isSelectOneElement) {\n                            this.removeActiveItems(id);\n                        }\n                        // Trigger change event\n                        this.passedElement.triggerEvent(constants_1.EVENTS.addItem, {\n                            id: id,\n                            value: passedValue,\n                            label: passedLabel,\n                            customProperties: customProperties,\n                            groupValue: group && group.value ? group.value : null,\n                            keyCode: keyCode\n                        });\n                    };\n                    Choices.prototype._removeItem = function(item) {\n                        var id = item.id, value = item.value, label = item.label, customProperties = item.customProperties, choiceId = item.choiceId, groupId = item.groupId;\n                        var group = groupId && groupId >= 0 ? this._store.getGroupById(groupId) : null;\n                        if (!id || !choiceId) {\n                            return;\n                        }\n                        this._store.dispatch((0, items_1.removeItem)(id, choiceId));\n                        this.passedElement.triggerEvent(constants_1.EVENTS.removeItem, {\n                            id: id,\n                            value: value,\n                            label: label,\n                            customProperties: customProperties,\n                            groupValue: group && group.value ? group.value : null\n                        });\n                    };\n                    Choices.prototype._addChoice = function(_a) {\n                        var value = _a.value, _b = _a.label, label = _b === void 0 ? null : _b, _c = _a.isSelected, isSelected = _c === void 0 ? false : _c, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, _e = _a.groupId, groupId = _e === void 0 ? -1 : _e, _f = _a.customProperties, customProperties = _f === void 0 ? {} : _f, _g = _a.placeholder, placeholder = _g === void 0 ? false : _g, _h = _a.keyCode, keyCode = _h === void 0 ? -1 : _h;\n                        if (typeof value === \"undefined\" || value === null) {\n                            return;\n                        }\n                        // Generate unique id\n                        var choices = this._store.choices;\n                        var choiceLabel = label || value;\n                        var choiceId = choices ? choices.length + 1 : 1;\n                        var choiceElementId = \"\".concat(this._baseId, \"-\").concat(this._idNames.itemChoice, \"-\").concat(choiceId);\n                        this._store.dispatch((0, choices_1.addChoice)({\n                            id: choiceId,\n                            groupId: groupId,\n                            elementId: choiceElementId,\n                            value: value,\n                            label: choiceLabel,\n                            disabled: isDisabled,\n                            customProperties: customProperties,\n                            placeholder: placeholder,\n                            keyCode: keyCode\n                        }));\n                        if (isSelected) {\n                            this._addItem({\n                                value: value,\n                                label: choiceLabel,\n                                choiceId: choiceId,\n                                customProperties: customProperties,\n                                placeholder: placeholder,\n                                keyCode: keyCode\n                            });\n                        }\n                    };\n                    Choices.prototype._addGroup = function(_a) {\n                        var _this = this;\n                        var group = _a.group, id = _a.id, _b = _a.valueKey, valueKey = _b === void 0 ? \"value\" : _b, _c = _a.labelKey, labelKey = _c === void 0 ? \"label\" : _c;\n                        var groupChoices = (0, utils_1.isType)(\"Object\", group) ? group.choices : Array.from(group.getElementsByTagName(\"OPTION\"));\n                        var groupId = id || Math.floor(new Date().valueOf() * Math.random());\n                        var isDisabled = group.disabled ? group.disabled : false;\n                        if (groupChoices) {\n                            this._store.dispatch((0, groups_1.addGroup)({\n                                value: group.label,\n                                id: groupId,\n                                active: true,\n                                disabled: isDisabled\n                            }));\n                            var addGroupChoices = function(choice) {\n                                var isOptDisabled = choice.disabled || choice.parentNode && choice.parentNode.disabled;\n                                _this._addChoice({\n                                    value: choice[valueKey],\n                                    label: (0, utils_1.isType)(\"Object\", choice) ? choice[labelKey] : choice.innerHTML,\n                                    isSelected: choice.selected,\n                                    isDisabled: isOptDisabled,\n                                    groupId: groupId,\n                                    customProperties: choice.customProperties,\n                                    placeholder: choice.placeholder\n                                });\n                            };\n                            groupChoices.forEach(addGroupChoices);\n                        } else {\n                            this._store.dispatch((0, groups_1.addGroup)({\n                                value: group.label,\n                                id: group.id,\n                                active: false,\n                                disabled: group.disabled\n                            }));\n                        }\n                    };\n                    Choices.prototype._getTemplate = function(template) {\n                        var _a;\n                        var args = [];\n                        for(var _i = 1; _i < arguments.length; _i++){\n                            args[_i - 1] = arguments[_i];\n                        }\n                        return (_a = this._templates[template]).call.apply(_a, __spreadArray([\n                            this,\n                            this.config\n                        ], args, false));\n                    };\n                    Choices.prototype._createTemplates = function() {\n                        var callbackOnCreateTemplates = this.config.callbackOnCreateTemplates;\n                        var userTemplates = {};\n                        if (callbackOnCreateTemplates && typeof callbackOnCreateTemplates === \"function\") {\n                            userTemplates = callbackOnCreateTemplates.call(this, utils_1.strToEl);\n                        }\n                        this._templates = (0, deepmerge_1.default)(templates_1.default, userTemplates);\n                    };\n                    Choices.prototype._createElements = function() {\n                        this.containerOuter = new components_1.Container({\n                            element: this._getTemplate(\"containerOuter\", this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type, this.config.labelId),\n                            classNames: this.config.classNames,\n                            type: this.passedElement.element.type,\n                            position: this.config.position\n                        });\n                        this.containerInner = new components_1.Container({\n                            element: this._getTemplate(\"containerInner\"),\n                            classNames: this.config.classNames,\n                            type: this.passedElement.element.type,\n                            position: this.config.position\n                        });\n                        this.input = new components_1.Input({\n                            element: this._getTemplate(\"input\", this._placeholderValue),\n                            classNames: this.config.classNames,\n                            type: this.passedElement.element.type,\n                            preventPaste: !this.config.paste\n                        });\n                        this.choiceList = new components_1.List({\n                            element: this._getTemplate(\"choiceList\", this._isSelectOneElement)\n                        });\n                        this.itemList = new components_1.List({\n                            element: this._getTemplate(\"itemList\", this._isSelectOneElement)\n                        });\n                        this.dropdown = new components_1.Dropdown({\n                            element: this._getTemplate(\"dropdown\"),\n                            classNames: this.config.classNames,\n                            type: this.passedElement.element.type\n                        });\n                    };\n                    Choices.prototype._createStructure = function() {\n                        // Hide original element\n                        this.passedElement.conceal();\n                        // Wrap input in container preserving DOM ordering\n                        this.containerInner.wrap(this.passedElement.element);\n                        // Wrapper inner container with outer container\n                        this.containerOuter.wrap(this.containerInner.element);\n                        if (this._isSelectOneElement) {\n                            this.input.placeholder = this.config.searchPlaceholderValue || \"\";\n                        } else if (this._placeholderValue) {\n                            this.input.placeholder = this._placeholderValue;\n                            this.input.setWidth();\n                        }\n                        this.containerOuter.element.appendChild(this.containerInner.element);\n                        this.containerOuter.element.appendChild(this.dropdown.element);\n                        this.containerInner.element.appendChild(this.itemList.element);\n                        if (!this._isTextElement) {\n                            this.dropdown.element.appendChild(this.choiceList.element);\n                        }\n                        if (!this._isSelectOneElement) {\n                            this.containerInner.element.appendChild(this.input.element);\n                        } else if (this.config.searchEnabled) {\n                            this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);\n                        }\n                        if (this._isSelectElement) {\n                            this._highlightPosition = 0;\n                            this._isSearching = false;\n                            this._startLoading();\n                            if (this._presetGroups.length) {\n                                this._addPredefinedGroups(this._presetGroups);\n                            } else {\n                                this._addPredefinedChoices(this._presetChoices);\n                            }\n                            this._stopLoading();\n                        }\n                        if (this._isTextElement) {\n                            this._addPredefinedItems(this._presetItems);\n                        }\n                    };\n                    Choices.prototype._addPredefinedGroups = function(groups) {\n                        var _this = this;\n                        // If we have a placeholder option\n                        var placeholderChoice = this.passedElement.placeholderOption;\n                        if (placeholderChoice && placeholderChoice.parentNode && placeholderChoice.parentNode.tagName === \"SELECT\") {\n                            this._addChoice({\n                                value: placeholderChoice.value,\n                                label: placeholderChoice.innerHTML,\n                                isSelected: placeholderChoice.selected,\n                                isDisabled: placeholderChoice.disabled,\n                                placeholder: true\n                            });\n                        }\n                        groups.forEach(function(group) {\n                            return _this._addGroup({\n                                group: group,\n                                id: group.id || null\n                            });\n                        });\n                    };\n                    Choices.prototype._addPredefinedChoices = function(choices) {\n                        var _this = this;\n                        // If sorting is enabled or the user is searching, filter choices\n                        if (this.config.shouldSort) {\n                            choices.sort(this.config.sorter);\n                        }\n                        var hasSelectedChoice = choices.some(function(choice) {\n                            return choice.selected;\n                        });\n                        var firstEnabledChoiceIndex = choices.findIndex(function(choice) {\n                            return choice.disabled === undefined || !choice.disabled;\n                        });\n                        choices.forEach(function(choice, index) {\n                            var _a = choice.value, value = _a === void 0 ? \"\" : _a, label = choice.label, customProperties = choice.customProperties, placeholder = choice.placeholder;\n                            if (_this._isSelectElement) {\n                                // If the choice is actually a group\n                                if (choice.choices) {\n                                    _this._addGroup({\n                                        group: choice,\n                                        id: choice.id || null\n                                    });\n                                } else {\n                                    /**\n           * If there is a selected choice already or the choice is not the first in\n           * the array, add each choice normally.\n           *\n           * Otherwise we pre-select the first enabled choice in the array (\"select-one\" only)\n           */ var shouldPreselect = _this._isSelectOneElement && !hasSelectedChoice && index === firstEnabledChoiceIndex;\n                                    var isSelected = shouldPreselect ? true : choice.selected;\n                                    var isDisabled = choice.disabled;\n                                    _this._addChoice({\n                                        value: value,\n                                        label: label,\n                                        isSelected: !!isSelected,\n                                        isDisabled: !!isDisabled,\n                                        placeholder: !!placeholder,\n                                        customProperties: customProperties\n                                    });\n                                }\n                            } else {\n                                _this._addChoice({\n                                    value: value,\n                                    label: label,\n                                    isSelected: !!choice.selected,\n                                    isDisabled: !!choice.disabled,\n                                    placeholder: !!choice.placeholder,\n                                    customProperties: customProperties\n                                });\n                            }\n                        });\n                    };\n                    Choices.prototype._addPredefinedItems = function(items) {\n                        var _this = this;\n                        items.forEach(function(item) {\n                            if (typeof item === \"object\" && item.value) {\n                                _this._addItem({\n                                    value: item.value,\n                                    label: item.label,\n                                    choiceId: item.id,\n                                    customProperties: item.customProperties,\n                                    placeholder: item.placeholder\n                                });\n                            }\n                            if (typeof item === \"string\") {\n                                _this._addItem({\n                                    value: item\n                                });\n                            }\n                        });\n                    };\n                    Choices.prototype._setChoiceOrItem = function(item) {\n                        var _this = this;\n                        var itemType = (0, utils_1.getType)(item).toLowerCase();\n                        var handleType = {\n                            object: function() {\n                                if (!item.value) {\n                                    return;\n                                }\n                                // If we are dealing with a select input, we need to create an option first\n                                // that is then selected. For text inputs we can just add items normally.\n                                if (!_this._isTextElement) {\n                                    _this._addChoice({\n                                        value: item.value,\n                                        label: item.label,\n                                        isSelected: true,\n                                        isDisabled: false,\n                                        customProperties: item.customProperties,\n                                        placeholder: item.placeholder\n                                    });\n                                } else {\n                                    _this._addItem({\n                                        value: item.value,\n                                        label: item.label,\n                                        choiceId: item.id,\n                                        customProperties: item.customProperties,\n                                        placeholder: item.placeholder\n                                    });\n                                }\n                            },\n                            string: function() {\n                                if (!_this._isTextElement) {\n                                    _this._addChoice({\n                                        value: item,\n                                        label: item,\n                                        isSelected: true,\n                                        isDisabled: false\n                                    });\n                                } else {\n                                    _this._addItem({\n                                        value: item\n                                    });\n                                }\n                            }\n                        };\n                        handleType[itemType]();\n                    };\n                    Choices.prototype._findAndSelectChoiceByValue = function(value) {\n                        var _this = this;\n                        var choices = this._store.choices;\n                        // Check 'value' property exists and the choice isn't already selected\n                        var foundChoice = choices.find(function(choice) {\n                            return _this.config.valueComparer(choice.value, value);\n                        });\n                        if (foundChoice && !foundChoice.selected) {\n                            this._addItem({\n                                value: foundChoice.value,\n                                label: foundChoice.label,\n                                choiceId: foundChoice.id,\n                                groupId: foundChoice.groupId,\n                                customProperties: foundChoice.customProperties,\n                                placeholder: foundChoice.placeholder,\n                                keyCode: foundChoice.keyCode\n                            });\n                        }\n                    };\n                    Choices.prototype._generatePlaceholderValue = function() {\n                        if (this._isSelectElement && this.passedElement.placeholderOption) {\n                            var placeholderOption = this.passedElement.placeholderOption;\n                            return placeholderOption ? placeholderOption.text : null;\n                        }\n                        var _a = this.config, placeholder = _a.placeholder, placeholderValue = _a.placeholderValue;\n                        var dataset = this.passedElement.element.dataset;\n                        if (placeholder) {\n                            if (placeholderValue) {\n                                return placeholderValue;\n                            }\n                            if (dataset.placeholder) {\n                                return dataset.placeholder;\n                            }\n                        }\n                        return null;\n                    };\n                    return Choices;\n                }();\n                exports1[\"default\"] = Choices;\n            /***/ },\n            /***/ 613: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_113187__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var utils_1 = __nested_webpack_require_113187__(799);\n                var constants_1 = __nested_webpack_require_113187__(883);\n                var Container = /** @class */ function() {\n                    function Container(_a) {\n                        var element = _a.element, type = _a.type, classNames = _a.classNames, position = _a.position;\n                        this.element = element;\n                        this.classNames = classNames;\n                        this.type = type;\n                        this.position = position;\n                        this.isOpen = false;\n                        this.isFlipped = false;\n                        this.isFocussed = false;\n                        this.isDisabled = false;\n                        this.isLoading = false;\n                        this._onFocus = this._onFocus.bind(this);\n                        this._onBlur = this._onBlur.bind(this);\n                    }\n                    Container.prototype.addEventListeners = function() {\n                        this.element.addEventListener(\"focus\", this._onFocus);\n                        this.element.addEventListener(\"blur\", this._onBlur);\n                    };\n                    Container.prototype.removeEventListeners = function() {\n                        this.element.removeEventListener(\"focus\", this._onFocus);\n                        this.element.removeEventListener(\"blur\", this._onBlur);\n                    };\n                    /**\n   * Determine whether container should be flipped based on passed\n   * dropdown position\n   */ Container.prototype.shouldFlip = function(dropdownPos) {\n                        if (typeof dropdownPos !== \"number\") {\n                            return false;\n                        }\n                        // If flip is enabled and the dropdown bottom position is\n                        // greater than the window height flip the dropdown.\n                        var shouldFlip = false;\n                        if (this.position === \"auto\") {\n                            shouldFlip = !window.matchMedia(\"(min-height: \".concat(dropdownPos + 1, \"px)\")).matches;\n                        } else if (this.position === \"top\") {\n                            shouldFlip = true;\n                        }\n                        return shouldFlip;\n                    };\n                    Container.prototype.setActiveDescendant = function(activeDescendantID) {\n                        this.element.setAttribute(\"aria-activedescendant\", activeDescendantID);\n                    };\n                    Container.prototype.removeActiveDescendant = function() {\n                        this.element.removeAttribute(\"aria-activedescendant\");\n                    };\n                    Container.prototype.open = function(dropdownPos) {\n                        this.element.classList.add(this.classNames.openState);\n                        this.element.setAttribute(\"aria-expanded\", \"true\");\n                        this.isOpen = true;\n                        if (this.shouldFlip(dropdownPos)) {\n                            this.element.classList.add(this.classNames.flippedState);\n                            this.isFlipped = true;\n                        }\n                    };\n                    Container.prototype.close = function() {\n                        this.element.classList.remove(this.classNames.openState);\n                        this.element.setAttribute(\"aria-expanded\", \"false\");\n                        this.removeActiveDescendant();\n                        this.isOpen = false;\n                        // A dropdown flips if it does not have space within the page\n                        if (this.isFlipped) {\n                            this.element.classList.remove(this.classNames.flippedState);\n                            this.isFlipped = false;\n                        }\n                    };\n                    Container.prototype.focus = function() {\n                        if (!this.isFocussed) {\n                            this.element.focus();\n                        }\n                    };\n                    Container.prototype.addFocusState = function() {\n                        this.element.classList.add(this.classNames.focusState);\n                    };\n                    Container.prototype.removeFocusState = function() {\n                        this.element.classList.remove(this.classNames.focusState);\n                    };\n                    Container.prototype.enable = function() {\n                        this.element.classList.remove(this.classNames.disabledState);\n                        this.element.removeAttribute(\"aria-disabled\");\n                        if (this.type === constants_1.SELECT_ONE_TYPE) {\n                            this.element.setAttribute(\"tabindex\", \"0\");\n                        }\n                        this.isDisabled = false;\n                    };\n                    Container.prototype.disable = function() {\n                        this.element.classList.add(this.classNames.disabledState);\n                        this.element.setAttribute(\"aria-disabled\", \"true\");\n                        if (this.type === constants_1.SELECT_ONE_TYPE) {\n                            this.element.setAttribute(\"tabindex\", \"-1\");\n                        }\n                        this.isDisabled = true;\n                    };\n                    Container.prototype.wrap = function(element) {\n                        (0, utils_1.wrap)(element, this.element);\n                    };\n                    Container.prototype.unwrap = function(element) {\n                        if (this.element.parentNode) {\n                            // Move passed element outside this element\n                            this.element.parentNode.insertBefore(element, this.element);\n                            // Remove this element\n                            this.element.parentNode.removeChild(this.element);\n                        }\n                    };\n                    Container.prototype.addLoadingState = function() {\n                        this.element.classList.add(this.classNames.loadingState);\n                        this.element.setAttribute(\"aria-busy\", \"true\");\n                        this.isLoading = true;\n                    };\n                    Container.prototype.removeLoadingState = function() {\n                        this.element.classList.remove(this.classNames.loadingState);\n                        this.element.removeAttribute(\"aria-busy\");\n                        this.isLoading = false;\n                    };\n                    Container.prototype._onFocus = function() {\n                        this.isFocussed = true;\n                    };\n                    Container.prototype._onBlur = function() {\n                        this.isFocussed = false;\n                    };\n                    return Container;\n                }();\n                exports1[\"default\"] = Container;\n            /***/ },\n            /***/ 217: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var Dropdown = /** @class */ function() {\n                    function Dropdown(_a) {\n                        var element = _a.element, type = _a.type, classNames = _a.classNames;\n                        this.element = element;\n                        this.classNames = classNames;\n                        this.type = type;\n                        this.isActive = false;\n                    }\n                    Object.defineProperty(Dropdown.prototype, \"distanceFromTopWindow\", {\n                        /**\n     * Bottom position of dropdown in viewport coordinates\n     */ get: function() {\n                            return this.element.getBoundingClientRect().bottom;\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Dropdown.prototype.getChild = function(selector) {\n                        return this.element.querySelector(selector);\n                    };\n                    /**\n   * Show dropdown to user by adding active state class\n   */ Dropdown.prototype.show = function() {\n                        this.element.classList.add(this.classNames.activeState);\n                        this.element.setAttribute(\"aria-expanded\", \"true\");\n                        this.isActive = true;\n                        return this;\n                    };\n                    /**\n   * Hide dropdown from user\n   */ Dropdown.prototype.hide = function() {\n                        this.element.classList.remove(this.classNames.activeState);\n                        this.element.setAttribute(\"aria-expanded\", \"false\");\n                        this.isActive = false;\n                        return this;\n                    };\n                    return Dropdown;\n                }();\n                exports1[\"default\"] = Dropdown;\n            /***/ },\n            /***/ 520: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_122433__) {\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.WrappedSelect = exports1.WrappedInput = exports1.List = exports1.Input = exports1.Container = exports1.Dropdown = void 0;\n                var dropdown_1 = __importDefault(__nested_webpack_require_122433__(217));\n                exports1.Dropdown = dropdown_1.default;\n                var container_1 = __importDefault(__nested_webpack_require_122433__(613));\n                exports1.Container = container_1.default;\n                var input_1 = __importDefault(__nested_webpack_require_122433__(11));\n                exports1.Input = input_1.default;\n                var list_1 = __importDefault(__nested_webpack_require_122433__(624));\n                exports1.List = list_1.default;\n                var wrapped_input_1 = __importDefault(__nested_webpack_require_122433__(541));\n                exports1.WrappedInput = wrapped_input_1.default;\n                var wrapped_select_1 = __importDefault(__nested_webpack_require_122433__(982));\n                exports1.WrappedSelect = wrapped_select_1.default;\n            /***/ },\n            /***/ 11: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_123842__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var utils_1 = __nested_webpack_require_123842__(799);\n                var constants_1 = __nested_webpack_require_123842__(883);\n                var Input = /** @class */ function() {\n                    function Input(_a) {\n                        var element = _a.element, type = _a.type, classNames = _a.classNames, preventPaste = _a.preventPaste;\n                        this.element = element;\n                        this.type = type;\n                        this.classNames = classNames;\n                        this.preventPaste = preventPaste;\n                        this.isFocussed = this.element.isEqualNode(document.activeElement);\n                        this.isDisabled = element.disabled;\n                        this._onPaste = this._onPaste.bind(this);\n                        this._onInput = this._onInput.bind(this);\n                        this._onFocus = this._onFocus.bind(this);\n                        this._onBlur = this._onBlur.bind(this);\n                    }\n                    Object.defineProperty(Input.prototype, \"placeholder\", {\n                        set: function(placeholder) {\n                            this.element.placeholder = placeholder;\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(Input.prototype, \"value\", {\n                        get: function() {\n                            return (0, utils_1.sanitise)(this.element.value);\n                        },\n                        set: function(value) {\n                            this.element.value = value;\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(Input.prototype, \"rawValue\", {\n                        get: function() {\n                            return this.element.value;\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Input.prototype.addEventListeners = function() {\n                        this.element.addEventListener(\"paste\", this._onPaste);\n                        this.element.addEventListener(\"input\", this._onInput, {\n                            passive: true\n                        });\n                        this.element.addEventListener(\"focus\", this._onFocus, {\n                            passive: true\n                        });\n                        this.element.addEventListener(\"blur\", this._onBlur, {\n                            passive: true\n                        });\n                    };\n                    Input.prototype.removeEventListeners = function() {\n                        this.element.removeEventListener(\"input\", this._onInput);\n                        this.element.removeEventListener(\"paste\", this._onPaste);\n                        this.element.removeEventListener(\"focus\", this._onFocus);\n                        this.element.removeEventListener(\"blur\", this._onBlur);\n                    };\n                    Input.prototype.enable = function() {\n                        this.element.removeAttribute(\"disabled\");\n                        this.isDisabled = false;\n                    };\n                    Input.prototype.disable = function() {\n                        this.element.setAttribute(\"disabled\", \"\");\n                        this.isDisabled = true;\n                    };\n                    Input.prototype.focus = function() {\n                        if (!this.isFocussed) {\n                            this.element.focus();\n                        }\n                    };\n                    Input.prototype.blur = function() {\n                        if (this.isFocussed) {\n                            this.element.blur();\n                        }\n                    };\n                    Input.prototype.clear = function(setWidth) {\n                        if (setWidth === void 0) {\n                            setWidth = true;\n                        }\n                        if (this.element.value) {\n                            this.element.value = \"\";\n                        }\n                        if (setWidth) {\n                            this.setWidth();\n                        }\n                        return this;\n                    };\n                    /**\n   * Set the correct input width based on placeholder\n   * value or input value\n   */ Input.prototype.setWidth = function() {\n                        // Resize input to contents or placeholder\n                        var _a = this.element, style = _a.style, value = _a.value, placeholder = _a.placeholder;\n                        style.minWidth = \"\".concat(placeholder.length + 1, \"ch\");\n                        style.width = \"\".concat(value.length + 1, \"ch\");\n                    };\n                    Input.prototype.setActiveDescendant = function(activeDescendantID) {\n                        this.element.setAttribute(\"aria-activedescendant\", activeDescendantID);\n                    };\n                    Input.prototype.removeActiveDescendant = function() {\n                        this.element.removeAttribute(\"aria-activedescendant\");\n                    };\n                    Input.prototype._onInput = function() {\n                        if (this.type !== constants_1.SELECT_ONE_TYPE) {\n                            this.setWidth();\n                        }\n                    };\n                    Input.prototype._onPaste = function(event) {\n                        if (this.preventPaste) {\n                            event.preventDefault();\n                        }\n                    };\n                    Input.prototype._onFocus = function() {\n                        this.isFocussed = true;\n                    };\n                    Input.prototype._onBlur = function() {\n                        this.isFocussed = false;\n                    };\n                    return Input;\n                }();\n                exports1[\"default\"] = Input;\n            /***/ },\n            /***/ 624: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_130170__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var constants_1 = __nested_webpack_require_130170__(883);\n                var List = /** @class */ function() {\n                    function List(_a) {\n                        var element = _a.element;\n                        this.element = element;\n                        this.scrollPos = this.element.scrollTop;\n                        this.height = this.element.offsetHeight;\n                    }\n                    List.prototype.clear = function() {\n                        this.element.innerHTML = \"\";\n                    };\n                    List.prototype.append = function(node) {\n                        this.element.appendChild(node);\n                    };\n                    List.prototype.getChild = function(selector) {\n                        return this.element.querySelector(selector);\n                    };\n                    List.prototype.hasChildren = function() {\n                        return this.element.hasChildNodes();\n                    };\n                    List.prototype.scrollToTop = function() {\n                        this.element.scrollTop = 0;\n                    };\n                    List.prototype.scrollToChildElement = function(element, direction) {\n                        var _this = this;\n                        if (!element) {\n                            return;\n                        }\n                        var listHeight = this.element.offsetHeight;\n                        // Scroll position of dropdown\n                        var listScrollPosition = this.element.scrollTop + listHeight;\n                        var elementHeight = element.offsetHeight;\n                        // Distance from bottom of element to top of parent\n                        var elementPos = element.offsetTop + elementHeight;\n                        // Difference between the element and scroll position\n                        var destination = direction > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;\n                        requestAnimationFrame(function() {\n                            _this._animateScroll(destination, direction);\n                        });\n                    };\n                    List.prototype._scrollDown = function(scrollPos, strength, destination) {\n                        var easing = (destination - scrollPos) / strength;\n                        var distance = easing > 1 ? easing : 1;\n                        this.element.scrollTop = scrollPos + distance;\n                    };\n                    List.prototype._scrollUp = function(scrollPos, strength, destination) {\n                        var easing = (scrollPos - destination) / strength;\n                        var distance = easing > 1 ? easing : 1;\n                        this.element.scrollTop = scrollPos - distance;\n                    };\n                    List.prototype._animateScroll = function(destination, direction) {\n                        var _this = this;\n                        var strength = constants_1.SCROLLING_SPEED;\n                        var choiceListScrollTop = this.element.scrollTop;\n                        var continueAnimation = false;\n                        if (direction > 0) {\n                            this._scrollDown(choiceListScrollTop, strength, destination);\n                            if (choiceListScrollTop < destination) {\n                                continueAnimation = true;\n                            }\n                        } else {\n                            this._scrollUp(choiceListScrollTop, strength, destination);\n                            if (choiceListScrollTop > destination) {\n                                continueAnimation = true;\n                            }\n                        }\n                        if (continueAnimation) {\n                            requestAnimationFrame(function() {\n                                _this._animateScroll(destination, direction);\n                            });\n                        }\n                    };\n                    return List;\n                }();\n                exports1[\"default\"] = List;\n            /***/ },\n            /***/ 730: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_134522__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var utils_1 = __nested_webpack_require_134522__(799);\n                var WrappedElement = /** @class */ function() {\n                    function WrappedElement(_a) {\n                        var element = _a.element, classNames = _a.classNames;\n                        this.element = element;\n                        this.classNames = classNames;\n                        if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLSelectElement)) {\n                            throw new TypeError(\"Invalid element passed\");\n                        }\n                        this.isDisabled = false;\n                    }\n                    Object.defineProperty(WrappedElement.prototype, \"isActive\", {\n                        get: function() {\n                            return this.element.dataset.choice === \"active\";\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(WrappedElement.prototype, \"dir\", {\n                        get: function() {\n                            return this.element.dir;\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(WrappedElement.prototype, \"value\", {\n                        get: function() {\n                            return this.element.value;\n                        },\n                        set: function(value) {\n                            // you must define setter here otherwise it will be readonly property\n                            this.element.value = value;\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    WrappedElement.prototype.conceal = function() {\n                        // Hide passed input\n                        this.element.classList.add(this.classNames.input);\n                        this.element.hidden = true;\n                        // Remove element from tab index\n                        this.element.tabIndex = -1;\n                        // Backup original styles if any\n                        var origStyle = this.element.getAttribute(\"style\");\n                        if (origStyle) {\n                            this.element.setAttribute(\"data-choice-orig-style\", origStyle);\n                        }\n                        this.element.setAttribute(\"data-choice\", \"active\");\n                    };\n                    WrappedElement.prototype.reveal = function() {\n                        // Reinstate passed element\n                        this.element.classList.remove(this.classNames.input);\n                        this.element.hidden = false;\n                        this.element.removeAttribute(\"tabindex\");\n                        // Recover original styles if any\n                        var origStyle = this.element.getAttribute(\"data-choice-orig-style\");\n                        if (origStyle) {\n                            this.element.removeAttribute(\"data-choice-orig-style\");\n                            this.element.setAttribute(\"style\", origStyle);\n                        } else {\n                            this.element.removeAttribute(\"style\");\n                        }\n                        this.element.removeAttribute(\"data-choice\");\n                        // Re-assign values - this is weird, I know\n                        // @todo Figure out why we need to do this\n                        this.element.value = this.element.value; // eslint-disable-line no-self-assign\n                    };\n                    WrappedElement.prototype.enable = function() {\n                        this.element.removeAttribute(\"disabled\");\n                        this.element.disabled = false;\n                        this.isDisabled = false;\n                    };\n                    WrappedElement.prototype.disable = function() {\n                        this.element.setAttribute(\"disabled\", \"\");\n                        this.element.disabled = true;\n                        this.isDisabled = true;\n                    };\n                    WrappedElement.prototype.triggerEvent = function(eventType, data) {\n                        (0, utils_1.dispatchEvent)(this.element, eventType, data);\n                    };\n                    return WrappedElement;\n                }();\n                exports1[\"default\"] = WrappedElement;\n            /***/ },\n            /***/ 541: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_139273__) {\n                var __extends = this && this.__extends || function() {\n                    var extendStatics = function(d, b) {\n                        extendStatics = Object.setPrototypeOf || ({\n                            __proto__: []\n                        }) instanceof Array && function(d, b) {\n                            d.__proto__ = b;\n                        } || function(d, b) {\n                            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n                        };\n                        return extendStatics(d, b);\n                    };\n                    return function(d, b) {\n                        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n                        extendStatics(d, b);\n                        function __() {\n                            this.constructor = d;\n                        }\n                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                    };\n                }();\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var wrapped_element_1 = __importDefault(__nested_webpack_require_139273__(730));\n                var WrappedInput = /** @class */ function(_super) {\n                    __extends(WrappedInput, _super);\n                    function WrappedInput(_a) {\n                        var element = _a.element, classNames = _a.classNames, delimiter = _a.delimiter;\n                        var _this = _super.call(this, {\n                            element: element,\n                            classNames: classNames\n                        }) || this;\n                        _this.delimiter = delimiter;\n                        return _this;\n                    }\n                    Object.defineProperty(WrappedInput.prototype, \"value\", {\n                        get: function() {\n                            return this.element.value;\n                        },\n                        set: function(value) {\n                            this.element.setAttribute(\"value\", value);\n                            this.element.value = value;\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    return WrappedInput;\n                }(wrapped_element_1.default);\n                exports1[\"default\"] = WrappedInput;\n            /***/ },\n            /***/ 982: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_142157__) {\n                var __extends = this && this.__extends || function() {\n                    var extendStatics = function(d, b) {\n                        extendStatics = Object.setPrototypeOf || ({\n                            __proto__: []\n                        }) instanceof Array && function(d, b) {\n                            d.__proto__ = b;\n                        } || function(d, b) {\n                            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n                        };\n                        return extendStatics(d, b);\n                    };\n                    return function(d, b) {\n                        if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n                        extendStatics(d, b);\n                        function __() {\n                            this.constructor = d;\n                        }\n                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                    };\n                }();\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var wrapped_element_1 = __importDefault(__nested_webpack_require_142157__(730));\n                var WrappedSelect = /** @class */ function(_super) {\n                    __extends(WrappedSelect, _super);\n                    function WrappedSelect(_a) {\n                        var element = _a.element, classNames = _a.classNames, template = _a.template;\n                        var _this = _super.call(this, {\n                            element: element,\n                            classNames: classNames\n                        }) || this;\n                        _this.template = template;\n                        return _this;\n                    }\n                    Object.defineProperty(WrappedSelect.prototype, \"placeholderOption\", {\n                        get: function() {\n                            return this.element.querySelector('option[value=\"\"]') || // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.\n                            this.element.querySelector(\"option[placeholder]\");\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(WrappedSelect.prototype, \"optionGroups\", {\n                        get: function() {\n                            return Array.from(this.element.getElementsByTagName(\"OPTGROUP\"));\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(WrappedSelect.prototype, \"options\", {\n                        get: function() {\n                            return Array.from(this.element.options);\n                        },\n                        set: function(options) {\n                            var _this = this;\n                            var fragment = document.createDocumentFragment();\n                            var addOptionToFragment = function(data) {\n                                // Create a standard select option\n                                var option = _this.template(data);\n                                // Append it to fragment\n                                fragment.appendChild(option);\n                            };\n                            // Add each list item to list\n                            options.forEach(function(optionData) {\n                                return addOptionToFragment(optionData);\n                            });\n                            this.appendDocFragment(fragment);\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    WrappedSelect.prototype.appendDocFragment = function(fragment) {\n                        this.element.innerHTML = \"\";\n                        this.element.appendChild(fragment);\n                    };\n                    return WrappedSelect;\n                }(wrapped_element_1.default);\n                exports1[\"default\"] = WrappedSelect;\n            /***/ },\n            /***/ 883: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.SCROLLING_SPEED = exports1.SELECT_MULTIPLE_TYPE = exports1.SELECT_ONE_TYPE = exports1.TEXT_TYPE = exports1.KEY_CODES = exports1.ACTION_TYPES = exports1.EVENTS = void 0;\n                exports1.EVENTS = {\n                    showDropdown: \"showDropdown\",\n                    hideDropdown: \"hideDropdown\",\n                    change: \"change\",\n                    choice: \"choice\",\n                    search: \"search\",\n                    addItem: \"addItem\",\n                    removeItem: \"removeItem\",\n                    highlightItem: \"highlightItem\",\n                    highlightChoice: \"highlightChoice\",\n                    unhighlightItem: \"unhighlightItem\"\n                };\n                exports1.ACTION_TYPES = {\n                    ADD_CHOICE: \"ADD_CHOICE\",\n                    FILTER_CHOICES: \"FILTER_CHOICES\",\n                    ACTIVATE_CHOICES: \"ACTIVATE_CHOICES\",\n                    CLEAR_CHOICES: \"CLEAR_CHOICES\",\n                    ADD_GROUP: \"ADD_GROUP\",\n                    ADD_ITEM: \"ADD_ITEM\",\n                    REMOVE_ITEM: \"REMOVE_ITEM\",\n                    HIGHLIGHT_ITEM: \"HIGHLIGHT_ITEM\",\n                    CLEAR_ALL: \"CLEAR_ALL\",\n                    RESET_TO: \"RESET_TO\",\n                    SET_IS_LOADING: \"SET_IS_LOADING\"\n                };\n                exports1.KEY_CODES = {\n                    BACK_KEY: 46,\n                    DELETE_KEY: 8,\n                    ENTER_KEY: 13,\n                    A_KEY: 65,\n                    ESC_KEY: 27,\n                    UP_KEY: 38,\n                    DOWN_KEY: 40,\n                    PAGE_UP_KEY: 33,\n                    PAGE_DOWN_KEY: 34\n                };\n                exports1.TEXT_TYPE = \"text\";\n                exports1.SELECT_ONE_TYPE = \"select-one\";\n                exports1.SELECT_MULTIPLE_TYPE = \"select-multiple\";\n                exports1.SCROLLING_SPEED = 4;\n            /***/ },\n            /***/ 789: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_148924__) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.DEFAULT_CONFIG = exports1.DEFAULT_CLASSNAMES = void 0;\n                var utils_1 = __nested_webpack_require_148924__(799);\n                exports1.DEFAULT_CLASSNAMES = {\n                    containerOuter: \"choices\",\n                    containerInner: \"choices__inner\",\n                    input: \"choices__input\",\n                    inputCloned: \"choices__input--cloned\",\n                    list: \"choices__list\",\n                    listItems: \"choices__list--multiple\",\n                    listSingle: \"choices__list--single\",\n                    listDropdown: \"choices__list--dropdown\",\n                    item: \"choices__item\",\n                    itemSelectable: \"choices__item--selectable\",\n                    itemDisabled: \"choices__item--disabled\",\n                    itemChoice: \"choices__item--choice\",\n                    placeholder: \"choices__placeholder\",\n                    group: \"choices__group\",\n                    groupHeading: \"choices__heading\",\n                    button: \"choices__button\",\n                    activeState: \"is-active\",\n                    focusState: \"is-focused\",\n                    openState: \"is-open\",\n                    disabledState: \"is-disabled\",\n                    highlightedState: \"is-highlighted\",\n                    selectedState: \"is-selected\",\n                    flippedState: \"is-flipped\",\n                    loadingState: \"is-loading\",\n                    noResults: \"has-no-results\",\n                    noChoices: \"has-no-choices\"\n                };\n                exports1.DEFAULT_CONFIG = {\n                    items: [],\n                    choices: [],\n                    silent: false,\n                    renderChoiceLimit: -1,\n                    maxItemCount: -1,\n                    addItems: true,\n                    addItemFilter: null,\n                    removeItems: true,\n                    removeItemButton: false,\n                    editItems: false,\n                    allowHTML: true,\n                    duplicateItemsAllowed: true,\n                    delimiter: \",\",\n                    paste: true,\n                    searchEnabled: true,\n                    searchChoices: true,\n                    searchFloor: 1,\n                    searchResultLimit: 4,\n                    searchFields: [\n                        \"label\",\n                        \"value\"\n                    ],\n                    position: \"auto\",\n                    resetScrollPosition: true,\n                    shouldSort: true,\n                    shouldSortItems: false,\n                    sorter: utils_1.sortByAlpha,\n                    placeholder: true,\n                    placeholderValue: null,\n                    searchPlaceholderValue: null,\n                    prependValue: null,\n                    appendValue: null,\n                    renderSelectedChoices: \"auto\",\n                    loadingText: \"Loading...\",\n                    noResultsText: \"No results found\",\n                    noChoicesText: \"No choices to choose from\",\n                    itemSelectText: \"Press to select\",\n                    uniqueItemText: \"Only unique values can be added\",\n                    customAddItemText: \"Only values matching specific conditions can be added\",\n                    addItemText: function(value) {\n                        return 'Press Enter to add <b>\"'.concat((0, utils_1.sanitise)(value), '\"</b>');\n                    },\n                    maxItemText: function(maxItemCount) {\n                        return \"Only \".concat(maxItemCount, \" values can be added\");\n                    },\n                    valueComparer: function(value1, value2) {\n                        return value1 === value2;\n                    },\n                    fuseOptions: {\n                        includeScore: true\n                    },\n                    labelId: \"\",\n                    callbackOnInit: null,\n                    callbackOnCreateTemplates: null,\n                    classNames: exports1.DEFAULT_CLASSNAMES\n                };\n            /***/ },\n            /***/ 18: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 978: /***/ function(__unused_webpack_module, exports1) {\n                /* eslint-disable @typescript-eslint/no-explicit-any */ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 948: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 359: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 285: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 533: /***/ function(__unused_webpack_module, exports1) {\n                /* eslint-disable @typescript-eslint/no-explicit-any */ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 187: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_154595__) {\n                var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {\n                    if (k2 === undefined) k2 = k;\n                    var desc = Object.getOwnPropertyDescriptor(m, k);\n                    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n                        desc = {\n                            enumerable: true,\n                            get: function() {\n                                return m[k];\n                            }\n                        };\n                    }\n                    Object.defineProperty(o, k2, desc);\n                } : function(o, m, k, k2) {\n                    if (k2 === undefined) k2 = k;\n                    o[k2] = m[k];\n                });\n                var __exportStar = this && this.__exportStar || function(m, exports1) {\n                    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                __exportStar(__nested_webpack_require_154595__(18), exports1);\n                __exportStar(__nested_webpack_require_154595__(978), exports1);\n                __exportStar(__nested_webpack_require_154595__(948), exports1);\n                __exportStar(__nested_webpack_require_154595__(359), exports1);\n                __exportStar(__nested_webpack_require_154595__(285), exports1);\n                __exportStar(__nested_webpack_require_154595__(533), exports1);\n                __exportStar(__nested_webpack_require_154595__(287), exports1);\n                __exportStar(__nested_webpack_require_154595__(132), exports1);\n                __exportStar(__nested_webpack_require_154595__(837), exports1);\n                __exportStar(__nested_webpack_require_154595__(598), exports1);\n                __exportStar(__nested_webpack_require_154595__(369), exports1);\n                __exportStar(__nested_webpack_require_154595__(37), exports1);\n                __exportStar(__nested_webpack_require_154595__(47), exports1);\n                __exportStar(__nested_webpack_require_154595__(923), exports1);\n                __exportStar(__nested_webpack_require_154595__(876), exports1);\n            /***/ },\n            /***/ 287: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 132: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 837: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 598: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 37: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 369: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 47: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 923: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 876: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /***/ },\n            /***/ 799: /***/ function(__unused_webpack_module, exports1) {\n                /* eslint-disable @typescript-eslint/no-explicit-any */ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.parseCustomProperties = exports1.diff = exports1.cloneObject = exports1.existsInArray = exports1.dispatchEvent = exports1.sortByScore = exports1.sortByAlpha = exports1.strToEl = exports1.sanitise = exports1.isScrolledIntoView = exports1.getAdjacentEl = exports1.wrap = exports1.isType = exports1.getType = exports1.generateId = exports1.generateChars = exports1.getRandomNumber = void 0;\n                var getRandomNumber = function(min, max) {\n                    return Math.floor(Math.random() * (max - min) + min);\n                };\n                exports1.getRandomNumber = getRandomNumber;\n                var generateChars = function(length) {\n                    return Array.from({\n                        length: length\n                    }, function() {\n                        return (0, exports1.getRandomNumber)(0, 36).toString(36);\n                    }).join(\"\");\n                };\n                exports1.generateChars = generateChars;\n                var generateId = function(element, prefix) {\n                    var id = element.id || element.name && \"\".concat(element.name, \"-\").concat((0, exports1.generateChars)(2)) || (0, exports1.generateChars)(4);\n                    id = id.replace(/(:|\\.|\\[|\\]|,)/g, \"\");\n                    id = \"\".concat(prefix, \"-\").concat(id);\n                    return id;\n                };\n                exports1.generateId = generateId;\n                var getType = function(obj) {\n                    return Object.prototype.toString.call(obj).slice(8, -1);\n                };\n                exports1.getType = getType;\n                var isType = function(type, obj) {\n                    return obj !== undefined && obj !== null && (0, exports1.getType)(obj) === type;\n                };\n                exports1.isType = isType;\n                var wrap = function(element, wrapper) {\n                    if (wrapper === void 0) {\n                        wrapper = document.createElement(\"div\");\n                    }\n                    if (element.parentNode) {\n                        if (element.nextSibling) {\n                            element.parentNode.insertBefore(wrapper, element.nextSibling);\n                        } else {\n                            element.parentNode.appendChild(wrapper);\n                        }\n                    }\n                    return wrapper.appendChild(element);\n                };\n                exports1.wrap = wrap;\n                var getAdjacentEl = function(startEl, selector, direction) {\n                    if (direction === void 0) {\n                        direction = 1;\n                    }\n                    var prop = \"\".concat(direction > 0 ? \"next\" : \"previous\", \"ElementSibling\");\n                    var sibling = startEl[prop];\n                    while(sibling){\n                        if (sibling.matches(selector)) {\n                            return sibling;\n                        }\n                        sibling = sibling[prop];\n                    }\n                    return sibling;\n                };\n                exports1.getAdjacentEl = getAdjacentEl;\n                var isScrolledIntoView = function(element, parent, direction) {\n                    if (direction === void 0) {\n                        direction = 1;\n                    }\n                    if (!element) {\n                        return false;\n                    }\n                    var isVisible;\n                    if (direction > 0) {\n                        // In view from bottom\n                        isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;\n                    } else {\n                        // In view from top\n                        isVisible = element.offsetTop >= parent.scrollTop;\n                    }\n                    return isVisible;\n                };\n                exports1.isScrolledIntoView = isScrolledIntoView;\n                var sanitise = function(value) {\n                    if (typeof value !== \"string\") {\n                        return value;\n                    }\n                    return value.replace(/&/g, \"&amp;\").replace(/>/g, \"&gt;\").replace(/</g, \"&lt;\").replace(/\"/g, \"&quot;\");\n                };\n                exports1.sanitise = sanitise;\n                exports1.strToEl = function() {\n                    var tmpEl = document.createElement(\"div\");\n                    return function(str) {\n                        var cleanedInput = str.trim();\n                        tmpEl.innerHTML = cleanedInput;\n                        var firldChild = tmpEl.children[0];\n                        while(tmpEl.firstChild){\n                            tmpEl.removeChild(tmpEl.firstChild);\n                        }\n                        return firldChild;\n                    };\n                }();\n                var sortByAlpha = function(_a, _b) {\n                    var value = _a.value, _c = _a.label, label = _c === void 0 ? value : _c;\n                    var value2 = _b.value, _d = _b.label, label2 = _d === void 0 ? value2 : _d;\n                    return label.localeCompare(label2, [], {\n                        sensitivity: \"base\",\n                        ignorePunctuation: true,\n                        numeric: true\n                    });\n                };\n                exports1.sortByAlpha = sortByAlpha;\n                var sortByScore = function(a, b) {\n                    var _a = a.score, scoreA = _a === void 0 ? 0 : _a;\n                    var _b = b.score, scoreB = _b === void 0 ? 0 : _b;\n                    return scoreA - scoreB;\n                };\n                exports1.sortByScore = sortByScore;\n                var dispatchEvent = function(element, type, customArgs) {\n                    if (customArgs === void 0) {\n                        customArgs = null;\n                    }\n                    var event = new CustomEvent(type, {\n                        detail: customArgs,\n                        bubbles: true,\n                        cancelable: true\n                    });\n                    return element.dispatchEvent(event);\n                };\n                exports1.dispatchEvent = dispatchEvent;\n                var existsInArray = function(array, value, key) {\n                    if (key === void 0) {\n                        key = \"value\";\n                    }\n                    return array.some(function(item) {\n                        if (typeof value === \"string\") {\n                            return item[key] === value.trim();\n                        }\n                        return item[key] === value;\n                    });\n                };\n                exports1.existsInArray = existsInArray;\n                var cloneObject = function(obj) {\n                    return JSON.parse(JSON.stringify(obj));\n                };\n                exports1.cloneObject = cloneObject;\n                /**\n * Returns an array of keys present on the first but missing on the second object\n */ var diff = function(a, b) {\n                    var aKeys = Object.keys(a).sort();\n                    var bKeys = Object.keys(b).sort();\n                    return aKeys.filter(function(i) {\n                        return bKeys.indexOf(i) < 0;\n                    });\n                };\n                exports1.diff = diff;\n                var parseCustomProperties = function(customProperties) {\n                    if (typeof customProperties !== \"undefined\") {\n                        try {\n                            return JSON.parse(customProperties);\n                        } catch (e) {\n                            return customProperties;\n                        }\n                    }\n                    return {};\n                };\n                exports1.parseCustomProperties = parseCustomProperties;\n            /***/ },\n            /***/ 273: /***/ function(__unused_webpack_module, exports1) {\n                var __spreadArray = this && this.__spreadArray || function(to, from, pack) {\n                    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n                        if (ar || !(i in from)) {\n                            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                            ar[i] = from[i];\n                        }\n                    }\n                    return to.concat(ar || Array.prototype.slice.call(from));\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.defaultState = void 0;\n                exports1.defaultState = [];\n                function choices(state, action) {\n                    if (state === void 0) {\n                        state = exports1.defaultState;\n                    }\n                    if (action === void 0) {\n                        action = {};\n                    }\n                    switch(action.type){\n                        case \"ADD_CHOICE\":\n                            {\n                                var addChoiceAction = action;\n                                var choice = {\n                                    id: addChoiceAction.id,\n                                    elementId: addChoiceAction.elementId,\n                                    groupId: addChoiceAction.groupId,\n                                    value: addChoiceAction.value,\n                                    label: addChoiceAction.label || addChoiceAction.value,\n                                    disabled: addChoiceAction.disabled || false,\n                                    selected: false,\n                                    active: true,\n                                    score: 9999,\n                                    customProperties: addChoiceAction.customProperties,\n                                    placeholder: addChoiceAction.placeholder || false\n                                };\n                                /*\n          A disabled choice appears in the choice dropdown but cannot be selected\n          A selected choice has been added to the passed input's value (added as an item)\n          An active choice appears within the choice dropdown\n        */ return __spreadArray(__spreadArray([], state, true), [\n                                    choice\n                                ], false);\n                            }\n                        case \"ADD_ITEM\":\n                            {\n                                var addItemAction_1 = action;\n                                // When an item is added and it has an associated choice,\n                                // we want to disable it so it can't be chosen again\n                                if (addItemAction_1.choiceId > -1) {\n                                    return state.map(function(obj) {\n                                        var choice = obj;\n                                        if (choice.id === parseInt(\"\".concat(addItemAction_1.choiceId), 10)) {\n                                            choice.selected = true;\n                                        }\n                                        return choice;\n                                    });\n                                }\n                                return state;\n                            }\n                        case \"REMOVE_ITEM\":\n                            {\n                                var removeItemAction_1 = action;\n                                // When an item is removed and it has an associated choice,\n                                // we want to re-enable it so it can be chosen again\n                                if (removeItemAction_1.choiceId && removeItemAction_1.choiceId > -1) {\n                                    return state.map(function(obj) {\n                                        var choice = obj;\n                                        if (choice.id === parseInt(\"\".concat(removeItemAction_1.choiceId), 10)) {\n                                            choice.selected = false;\n                                        }\n                                        return choice;\n                                    });\n                                }\n                                return state;\n                            }\n                        case \"FILTER_CHOICES\":\n                            {\n                                var filterChoicesAction_1 = action;\n                                return state.map(function(obj) {\n                                    var choice = obj;\n                                    // Set active state based on whether choice is\n                                    // within filtered results\n                                    choice.active = filterChoicesAction_1.results.some(function(_a) {\n                                        var item = _a.item, score = _a.score;\n                                        if (item.id === choice.id) {\n                                            choice.score = score;\n                                            return true;\n                                        }\n                                        return false;\n                                    });\n                                    return choice;\n                                });\n                            }\n                        case \"ACTIVATE_CHOICES\":\n                            {\n                                var activateChoicesAction_1 = action;\n                                return state.map(function(obj) {\n                                    var choice = obj;\n                                    choice.active = activateChoicesAction_1.active;\n                                    return choice;\n                                });\n                            }\n                        case \"CLEAR_CHOICES\":\n                            {\n                                return exports1.defaultState;\n                            }\n                        default:\n                            {\n                                return state;\n                            }\n                    }\n                }\n                exports1[\"default\"] = choices;\n            /***/ },\n            /***/ 871: /***/ function(__unused_webpack_module, exports1) {\n                var __spreadArray = this && this.__spreadArray || function(to, from, pack) {\n                    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n                        if (ar || !(i in from)) {\n                            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                            ar[i] = from[i];\n                        }\n                    }\n                    return to.concat(ar || Array.prototype.slice.call(from));\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.defaultState = void 0;\n                exports1.defaultState = [];\n                function groups(state, action) {\n                    if (state === void 0) {\n                        state = exports1.defaultState;\n                    }\n                    if (action === void 0) {\n                        action = {};\n                    }\n                    switch(action.type){\n                        case \"ADD_GROUP\":\n                            {\n                                var addGroupAction = action;\n                                return __spreadArray(__spreadArray([], state, true), [\n                                    {\n                                        id: addGroupAction.id,\n                                        value: addGroupAction.value,\n                                        active: addGroupAction.active,\n                                        disabled: addGroupAction.disabled\n                                    }\n                                ], false);\n                            }\n                        case \"CLEAR_CHOICES\":\n                            {\n                                return [];\n                            }\n                        default:\n                            {\n                                return state;\n                            }\n                    }\n                }\n                exports1[\"default\"] = groups;\n            /***/ },\n            /***/ 655: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_175429__) {\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.defaultState = void 0;\n                var redux_1 = __nested_webpack_require_175429__(791);\n                var items_1 = __importDefault(__nested_webpack_require_175429__(52));\n                var groups_1 = __importDefault(__nested_webpack_require_175429__(871));\n                var choices_1 = __importDefault(__nested_webpack_require_175429__(273));\n                var loading_1 = __importDefault(__nested_webpack_require_175429__(502));\n                var utils_1 = __nested_webpack_require_175429__(799);\n                exports1.defaultState = {\n                    groups: [],\n                    items: [],\n                    choices: [],\n                    loading: false\n                };\n                var appReducer = (0, redux_1.combineReducers)({\n                    items: items_1.default,\n                    groups: groups_1.default,\n                    choices: choices_1.default,\n                    loading: loading_1.default\n                });\n                var rootReducer = function(passedState, action) {\n                    var state = passedState;\n                    // If we are clearing all items, groups and options we reassign\n                    // state and then pass that state to our proper reducer. This isn't\n                    // mutating our actual state\n                    // See: http://stackoverflow.com/a/35641992\n                    if (action.type === \"CLEAR_ALL\") {\n                        state = exports1.defaultState;\n                    } else if (action.type === \"RESET_TO\") {\n                        return (0, utils_1.cloneObject)(action.state);\n                    }\n                    return appReducer(state, action);\n                };\n                exports1[\"default\"] = rootReducer;\n            /***/ },\n            /***/ 52: /***/ function(__unused_webpack_module, exports1) {\n                var __spreadArray = this && this.__spreadArray || function(to, from, pack) {\n                    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n                        if (ar || !(i in from)) {\n                            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                            ar[i] = from[i];\n                        }\n                    }\n                    return to.concat(ar || Array.prototype.slice.call(from));\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.defaultState = void 0;\n                exports1.defaultState = [];\n                function items(state, action) {\n                    if (state === void 0) {\n                        state = exports1.defaultState;\n                    }\n                    if (action === void 0) {\n                        action = {};\n                    }\n                    switch(action.type){\n                        case \"ADD_ITEM\":\n                            {\n                                var addItemAction = action;\n                                // Add object to items array\n                                var newState = __spreadArray(__spreadArray([], state, true), [\n                                    {\n                                        id: addItemAction.id,\n                                        choiceId: addItemAction.choiceId,\n                                        groupId: addItemAction.groupId,\n                                        value: addItemAction.value,\n                                        label: addItemAction.label,\n                                        active: true,\n                                        highlighted: false,\n                                        customProperties: addItemAction.customProperties,\n                                        placeholder: addItemAction.placeholder || false,\n                                        keyCode: null\n                                    }\n                                ], false);\n                                return newState.map(function(obj) {\n                                    var item = obj;\n                                    item.highlighted = false;\n                                    return item;\n                                });\n                            }\n                        case \"REMOVE_ITEM\":\n                            {\n                                // Set item to inactive\n                                return state.map(function(obj) {\n                                    var item = obj;\n                                    if (item.id === action.id) {\n                                        item.active = false;\n                                    }\n                                    return item;\n                                });\n                            }\n                        case \"HIGHLIGHT_ITEM\":\n                            {\n                                var highlightItemAction_1 = action;\n                                return state.map(function(obj) {\n                                    var item = obj;\n                                    if (item.id === highlightItemAction_1.id) {\n                                        item.highlighted = highlightItemAction_1.highlighted;\n                                    }\n                                    return item;\n                                });\n                            }\n                        default:\n                            {\n                                return state;\n                            }\n                    }\n                }\n                exports1[\"default\"] = items;\n            /***/ },\n            /***/ 502: /***/ function(__unused_webpack_module, exports1) {\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.defaultState = void 0;\n                exports1.defaultState = false;\n                var general = function(state, action) {\n                    if (state === void 0) {\n                        state = exports1.defaultState;\n                    }\n                    if (action === void 0) {\n                        action = {};\n                    }\n                    switch(action.type){\n                        case \"SET_IS_LOADING\":\n                            {\n                                return action.isLoading;\n                            }\n                        default:\n                            {\n                                return state;\n                            }\n                    }\n                };\n                exports1[\"default\"] = general;\n            /***/ },\n            /***/ 744: /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_182479__) {\n                var __spreadArray = this && this.__spreadArray || function(to, from, pack) {\n                    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n                        if (ar || !(i in from)) {\n                            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                            ar[i] = from[i];\n                        }\n                    }\n                    return to.concat(ar || Array.prototype.slice.call(from));\n                };\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                /* eslint-disable @typescript-eslint/no-explicit-any */ var redux_1 = __nested_webpack_require_182479__(791);\n                var index_1 = __importDefault(__nested_webpack_require_182479__(655));\n                var Store = /** @class */ function() {\n                    function Store() {\n                        this._store = (0, redux_1.createStore)(index_1.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\n                    }\n                    /**\n   * Subscribe store to function call (wrapped Redux method)\n   */ Store.prototype.subscribe = function(onChange) {\n                        this._store.subscribe(onChange);\n                    };\n                    /**\n   * Dispatch event to store (wrapped Redux method)\n   */ Store.prototype.dispatch = function(action) {\n                        this._store.dispatch(action);\n                    };\n                    Object.defineProperty(Store.prototype, \"state\", {\n                        /**\n     * Get store object (wrapping Redux method)\n     */ get: function() {\n                            return this._store.getState();\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(Store.prototype, \"items\", {\n                        /**\n     * Get items from store\n     */ get: function() {\n                            return this.state.items;\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(Store.prototype, \"activeItems\", {\n                        /**\n     * Get active items from store\n     */ get: function() {\n                            return this.items.filter(function(item) {\n                                return item.active === true;\n                            });\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(Store.prototype, \"highlightedActiveItems\", {\n                        /**\n     * Get highlighted items from store\n     */ get: function() {\n                            return this.items.filter(function(item) {\n                                return item.active && item.highlighted;\n                            });\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(Store.prototype, \"choices\", {\n                        /**\n     * Get choices from store\n     */ get: function() {\n                            return this.state.choices;\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(Store.prototype, \"activeChoices\", {\n                        /**\n     * Get active choices from store\n     */ get: function() {\n                            return this.choices.filter(function(choice) {\n                                return choice.active === true;\n                            });\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(Store.prototype, \"selectableChoices\", {\n                        /**\n     * Get selectable choices from store\n     */ get: function() {\n                            return this.choices.filter(function(choice) {\n                                return choice.disabled !== true;\n                            });\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(Store.prototype, \"searchableChoices\", {\n                        /**\n     * Get choices that can be searched (excluding placeholders)\n     */ get: function() {\n                            return this.selectableChoices.filter(function(choice) {\n                                return choice.placeholder !== true;\n                            });\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(Store.prototype, \"placeholderChoice\", {\n                        /**\n     * Get placeholder choice from store\n     */ get: function() {\n                            return __spreadArray([], this.choices, true).reverse().find(function(choice) {\n                                return choice.placeholder === true;\n                            });\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(Store.prototype, \"groups\", {\n                        /**\n     * Get groups from store\n     */ get: function() {\n                            return this.state.groups;\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    Object.defineProperty(Store.prototype, \"activeGroups\", {\n                        /**\n     * Get active groups from store\n     */ get: function() {\n                            var _a = this, groups = _a.groups, choices = _a.choices;\n                            return groups.filter(function(group) {\n                                var isActive = group.active === true && group.disabled === false;\n                                var hasActiveOptions = choices.some(function(choice) {\n                                    return choice.active === true && choice.disabled === false;\n                                });\n                                return isActive && hasActiveOptions;\n                            }, []);\n                        },\n                        enumerable: false,\n                        configurable: true\n                    });\n                    /**\n   * Get loading state from store\n   */ Store.prototype.isLoading = function() {\n                        return this.state.loading;\n                    };\n                    /**\n   * Get single choice by it's ID\n   */ Store.prototype.getChoiceById = function(id) {\n                        return this.activeChoices.find(function(choice) {\n                            return choice.id === parseInt(id, 10);\n                        });\n                    };\n                    /**\n   * Get group by group id\n   */ Store.prototype.getGroupById = function(id) {\n                        return this.groups.find(function(group) {\n                            return group.id === id;\n                        });\n                    };\n                    return Store;\n                }();\n                exports1[\"default\"] = Store;\n            /***/ },\n            /***/ 686: /***/ function(__unused_webpack_module, exports1) {\n                /**\n * Helpers to create HTML elements used by Choices\n * Can be overridden by providing `callbackOnCreateTemplates` option\n */ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var templates = {\n                    containerOuter: function(_a, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType, labelId) {\n                        var containerOuter = _a.classNames.containerOuter;\n                        var div = Object.assign(document.createElement(\"div\"), {\n                            className: containerOuter\n                        });\n                        div.dataset.type = passedElementType;\n                        if (dir) {\n                            div.dir = dir;\n                        }\n                        if (isSelectOneElement) {\n                            div.tabIndex = 0;\n                        }\n                        if (isSelectElement) {\n                            div.setAttribute(\"role\", searchEnabled ? \"combobox\" : \"listbox\");\n                            if (searchEnabled) {\n                                div.setAttribute(\"aria-autocomplete\", \"list\");\n                            }\n                        }\n                        div.setAttribute(\"aria-haspopup\", \"true\");\n                        div.setAttribute(\"aria-expanded\", \"false\");\n                        if (labelId) {\n                            div.setAttribute(\"aria-labelledby\", labelId);\n                        }\n                        return div;\n                    },\n                    containerInner: function(_a) {\n                        var containerInner = _a.classNames.containerInner;\n                        return Object.assign(document.createElement(\"div\"), {\n                            className: containerInner\n                        });\n                    },\n                    itemList: function(_a, isSelectOneElement) {\n                        var _b = _a.classNames, list = _b.list, listSingle = _b.listSingle, listItems = _b.listItems;\n                        return Object.assign(document.createElement(\"div\"), {\n                            className: \"\".concat(list, \" \").concat(isSelectOneElement ? listSingle : listItems)\n                        });\n                    },\n                    placeholder: function(_a, value) {\n                        var _b;\n                        var allowHTML = _a.allowHTML, placeholder = _a.classNames.placeholder;\n                        return Object.assign(document.createElement(\"div\"), (_b = {\n                            className: placeholder\n                        }, _b[allowHTML ? \"innerHTML\" : \"innerText\"] = value, _b));\n                    },\n                    item: function(_a, _b, removeItemButton) {\n                        var _c, _d;\n                        var allowHTML = _a.allowHTML, _e = _a.classNames, item = _e.item, button = _e.button, highlightedState = _e.highlightedState, itemSelectable = _e.itemSelectable, placeholder = _e.placeholder;\n                        var id = _b.id, value = _b.value, label = _b.label, customProperties = _b.customProperties, active = _b.active, disabled = _b.disabled, highlighted = _b.highlighted, isPlaceholder = _b.placeholder;\n                        var div = Object.assign(document.createElement(\"div\"), (_c = {\n                            className: item\n                        }, _c[allowHTML ? \"innerHTML\" : \"innerText\"] = label, _c));\n                        Object.assign(div.dataset, {\n                            item: \"\",\n                            id: id,\n                            value: value,\n                            customProperties: customProperties\n                        });\n                        if (active) {\n                            div.setAttribute(\"aria-selected\", \"true\");\n                        }\n                        if (disabled) {\n                            div.setAttribute(\"aria-disabled\", \"true\");\n                        }\n                        if (isPlaceholder) {\n                            div.classList.add(placeholder);\n                        }\n                        div.classList.add(highlighted ? highlightedState : itemSelectable);\n                        if (removeItemButton) {\n                            if (disabled) {\n                                div.classList.remove(itemSelectable);\n                            }\n                            div.dataset.deletable = \"\";\n                            /** @todo This MUST be localizable, not hardcoded! */ var REMOVE_ITEM_TEXT = \"Remove item\";\n                            var removeButton = Object.assign(document.createElement(\"button\"), (_d = {\n                                type: \"button\",\n                                className: button\n                            }, _d[allowHTML ? \"innerHTML\" : \"innerText\"] = REMOVE_ITEM_TEXT, _d));\n                            removeButton.setAttribute(\"aria-label\", \"\".concat(REMOVE_ITEM_TEXT, \": '\").concat(value, \"'\"));\n                            removeButton.dataset.button = \"\";\n                            div.appendChild(removeButton);\n                        }\n                        return div;\n                    },\n                    choiceList: function(_a, isSelectOneElement) {\n                        var list = _a.classNames.list;\n                        var div = Object.assign(document.createElement(\"div\"), {\n                            className: list\n                        });\n                        if (!isSelectOneElement) {\n                            div.setAttribute(\"aria-multiselectable\", \"true\");\n                        }\n                        div.setAttribute(\"role\", \"listbox\");\n                        return div;\n                    },\n                    choiceGroup: function(_a, _b) {\n                        var _c;\n                        var allowHTML = _a.allowHTML, _d = _a.classNames, group = _d.group, groupHeading = _d.groupHeading, itemDisabled = _d.itemDisabled;\n                        var id = _b.id, value = _b.value, disabled = _b.disabled;\n                        var div = Object.assign(document.createElement(\"div\"), {\n                            className: \"\".concat(group, \" \").concat(disabled ? itemDisabled : \"\")\n                        });\n                        div.setAttribute(\"role\", \"group\");\n                        Object.assign(div.dataset, {\n                            group: \"\",\n                            id: id,\n                            value: value\n                        });\n                        if (disabled) {\n                            div.setAttribute(\"aria-disabled\", \"true\");\n                        }\n                        div.appendChild(Object.assign(document.createElement(\"div\"), (_c = {\n                            className: groupHeading\n                        }, _c[allowHTML ? \"innerHTML\" : \"innerText\"] = value, _c)));\n                        return div;\n                    },\n                    choice: function(_a, _b, selectText) {\n                        var _c;\n                        var allowHTML = _a.allowHTML, _d = _a.classNames, item = _d.item, itemChoice = _d.itemChoice, itemSelectable = _d.itemSelectable, selectedState = _d.selectedState, itemDisabled = _d.itemDisabled, placeholder = _d.placeholder;\n                        var id = _b.id, value = _b.value, label = _b.label, groupId = _b.groupId, elementId = _b.elementId, isDisabled = _b.disabled, isSelected = _b.selected, isPlaceholder = _b.placeholder;\n                        var div = Object.assign(document.createElement(\"div\"), (_c = {\n                            id: elementId\n                        }, _c[allowHTML ? \"innerHTML\" : \"innerText\"] = label, _c.className = \"\".concat(item, \" \").concat(itemChoice), _c));\n                        if (isSelected) {\n                            div.classList.add(selectedState);\n                        }\n                        if (isPlaceholder) {\n                            div.classList.add(placeholder);\n                        }\n                        div.setAttribute(\"role\", groupId && groupId > 0 ? \"treeitem\" : \"option\");\n                        Object.assign(div.dataset, {\n                            choice: \"\",\n                            id: id,\n                            value: value,\n                            selectText: selectText\n                        });\n                        if (isDisabled) {\n                            div.classList.add(itemDisabled);\n                            div.dataset.choiceDisabled = \"\";\n                            div.setAttribute(\"aria-disabled\", \"true\");\n                        } else {\n                            div.classList.add(itemSelectable);\n                            div.dataset.choiceSelectable = \"\";\n                        }\n                        return div;\n                    },\n                    input: function(_a, placeholderValue) {\n                        var _b = _a.classNames, input = _b.input, inputCloned = _b.inputCloned;\n                        var inp = Object.assign(document.createElement(\"input\"), {\n                            type: \"search\",\n                            name: \"search_terms\",\n                            className: \"\".concat(input, \" \").concat(inputCloned),\n                            autocomplete: \"off\",\n                            autocapitalize: \"off\",\n                            spellcheck: false\n                        });\n                        inp.setAttribute(\"role\", \"textbox\");\n                        inp.setAttribute(\"aria-autocomplete\", \"list\");\n                        inp.setAttribute(\"aria-label\", placeholderValue);\n                        return inp;\n                    },\n                    dropdown: function(_a) {\n                        var _b = _a.classNames, list = _b.list, listDropdown = _b.listDropdown;\n                        var div = document.createElement(\"div\");\n                        div.classList.add(list, listDropdown);\n                        div.setAttribute(\"aria-expanded\", \"false\");\n                        return div;\n                    },\n                    notice: function(_a, innerText, type) {\n                        var _b;\n                        var allowHTML = _a.allowHTML, _c = _a.classNames, item = _c.item, itemChoice = _c.itemChoice, noResults = _c.noResults, noChoices = _c.noChoices;\n                        if (type === void 0) {\n                            type = \"\";\n                        }\n                        var classes = [\n                            item,\n                            itemChoice\n                        ];\n                        if (type === \"no-choices\") {\n                            classes.push(noChoices);\n                        } else if (type === \"no-results\") {\n                            classes.push(noResults);\n                        }\n                        return Object.assign(document.createElement(\"div\"), (_b = {}, _b[allowHTML ? \"innerHTML\" : \"innerText\"] = innerText, _b.className = classes.join(\" \"), _b));\n                    },\n                    option: function(_a) {\n                        var label = _a.label, value = _a.value, customProperties = _a.customProperties, active = _a.active, disabled = _a.disabled;\n                        var opt = new Option(label, value, false, active);\n                        if (customProperties) {\n                            opt.dataset.customProperties = \"\".concat(customProperties);\n                        }\n                        opt.disabled = !!disabled;\n                        return opt;\n                    }\n                };\n                exports1[\"default\"] = templates;\n            /***/ },\n            /***/ 996: /***/ function(module1) {\n                var isMergeableObject = function isMergeableObject(value) {\n                    return isNonNullObject(value) && !isSpecial(value);\n                };\n                function isNonNullObject(value) {\n                    return !!value && typeof value === \"object\";\n                }\n                function isSpecial(value) {\n                    var stringValue = Object.prototype.toString.call(value);\n                    return stringValue === \"[object RegExp]\" || stringValue === \"[object Date]\" || isReactElement(value);\n                }\n                // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n                var canUseSymbol = typeof Symbol === \"function\" && Symbol.for;\n                var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for(\"react.element\") : 0xeac7;\n                function isReactElement(value) {\n                    return value.$$typeof === REACT_ELEMENT_TYPE;\n                }\n                function emptyTarget(val) {\n                    return Array.isArray(val) ? [] : {};\n                }\n                function cloneUnlessOtherwiseSpecified(value, options) {\n                    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n                }\n                function defaultArrayMerge(target, source, options) {\n                    return target.concat(source).map(function(element) {\n                        return cloneUnlessOtherwiseSpecified(element, options);\n                    });\n                }\n                function getMergeFunction(key, options) {\n                    if (!options.customMerge) {\n                        return deepmerge;\n                    }\n                    var customMerge = options.customMerge(key);\n                    return typeof customMerge === \"function\" ? customMerge : deepmerge;\n                }\n                function getEnumerableOwnPropertySymbols(target) {\n                    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n                        return target.propertyIsEnumerable(symbol);\n                    }) : [];\n                }\n                function getKeys(target) {\n                    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n                }\n                function propertyIsOnObject(object, property) {\n                    try {\n                        return property in object;\n                    } catch (_) {\n                        return false;\n                    }\n                }\n                // Protects from prototype poisoning and unexpected merging up the prototype chain.\n                function propertyIsUnsafe(target, key) {\n                    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n                     && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n                     && Object.propertyIsEnumerable.call(target, key) // and also unsafe if they're nonenumerable.\n                    );\n                }\n                function mergeObject(target, source, options) {\n                    var destination = {};\n                    if (options.isMergeableObject(target)) {\n                        getKeys(target).forEach(function(key) {\n                            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n                        });\n                    }\n                    getKeys(source).forEach(function(key) {\n                        if (propertyIsUnsafe(target, key)) {\n                            return;\n                        }\n                        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n                            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n                        } else {\n                            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n                        }\n                    });\n                    return destination;\n                }\n                function deepmerge(target, source, options) {\n                    options = options || {};\n                    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n                    options.isMergeableObject = options.isMergeableObject || isMergeableObject;\n                    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n                    // implementations can use it. The caller may not replace it.\n                    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n                    var sourceIsArray = Array.isArray(source);\n                    var targetIsArray = Array.isArray(target);\n                    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n                    if (!sourceAndTargetTypesMatch) {\n                        return cloneUnlessOtherwiseSpecified(source, options);\n                    } else if (sourceIsArray) {\n                        return options.arrayMerge(target, source, options);\n                    } else {\n                        return mergeObject(target, source, options);\n                    }\n                }\n                deepmerge.all = function deepmergeAll(array, options) {\n                    if (!Array.isArray(array)) {\n                        throw new Error(\"first argument should be an array\");\n                    }\n                    return array.reduce(function(prev, next) {\n                        return deepmerge(prev, next, options);\n                    }, {});\n                };\n                var deepmerge_1 = deepmerge;\n                module1.exports = deepmerge_1;\n            /***/ },\n            /***/ 221: /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_208291__) {\n                __nested_webpack_require_208291__.r(__nested_webpack_exports__);\n                /* harmony export */ __nested_webpack_require_208291__.d(__nested_webpack_exports__, {\n                    /* harmony export */ \"default\": function() {\n                        return /* binding */ Fuse;\n                    }\n                });\n                /**\n * Fuse.js v6.6.2 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2022 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */ function isArray(value) {\n                    return !Array.isArray ? getTag(value) === \"[object Array]\" : Array.isArray(value);\n                }\n                // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\n                const INFINITY = 1 / 0;\n                function baseToString(value) {\n                    // Exit early for strings to avoid a performance hit in some environments.\n                    if (typeof value == \"string\") {\n                        return value;\n                    }\n                    let result = value + \"\";\n                    return result == \"0\" && 1 / value == -INFINITY ? \"-0\" : result;\n                }\n                function toString(value) {\n                    return value == null ? \"\" : baseToString(value);\n                }\n                function isString(value) {\n                    return typeof value === \"string\";\n                }\n                function isNumber(value) {\n                    return typeof value === \"number\";\n                }\n                // Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\n                function isBoolean(value) {\n                    return value === true || value === false || isObjectLike(value) && getTag(value) == \"[object Boolean]\";\n                }\n                function isObject(value) {\n                    return typeof value === \"object\";\n                }\n                // Checks if `value` is object-like.\n                function isObjectLike(value) {\n                    return isObject(value) && value !== null;\n                }\n                function isDefined(value) {\n                    return value !== undefined && value !== null;\n                }\n                function isBlank(value) {\n                    return !value.trim().length;\n                }\n                // Gets the `toStringTag` of `value`.\n                // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\n                function getTag(value) {\n                    return value == null ? value === undefined ? \"[object Undefined]\" : \"[object Null]\" : Object.prototype.toString.call(value);\n                }\n                const EXTENDED_SEARCH_UNAVAILABLE = \"Extended search is not available\";\n                const INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\n                const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key)=>`Invalid value for key ${key}`;\n                const PATTERN_LENGTH_TOO_LARGE = (max)=>`Pattern length exceeds max of ${max}.`;\n                const MISSING_KEY_PROPERTY = (name)=>`Missing ${name} property in key`;\n                const INVALID_KEY_WEIGHT_VALUE = (key)=>`Property 'weight' in key '${key}' must be a positive integer`;\n                const hasOwn = Object.prototype.hasOwnProperty;\n                class KeyStore {\n                    constructor(keys){\n                        this._keys = [];\n                        this._keyMap = {};\n                        let totalWeight = 0;\n                        keys.forEach((key)=>{\n                            let obj = createKey(key);\n                            totalWeight += obj.weight;\n                            this._keys.push(obj);\n                            this._keyMap[obj.id] = obj;\n                            totalWeight += obj.weight;\n                        });\n                        // Normalize weights so that their sum is equal to 1\n                        this._keys.forEach((key)=>{\n                            key.weight /= totalWeight;\n                        });\n                    }\n                    get(keyId) {\n                        return this._keyMap[keyId];\n                    }\n                    keys() {\n                        return this._keys;\n                    }\n                    toJSON() {\n                        return JSON.stringify(this._keys);\n                    }\n                }\n                function createKey(key) {\n                    let path = null;\n                    let id = null;\n                    let src = null;\n                    let weight = 1;\n                    let getFn = null;\n                    if (isString(key) || isArray(key)) {\n                        src = key;\n                        path = createKeyPath(key);\n                        id = createKeyId(key);\n                    } else {\n                        if (!hasOwn.call(key, \"name\")) {\n                            throw new Error(MISSING_KEY_PROPERTY(\"name\"));\n                        }\n                        const name = key.name;\n                        src = name;\n                        if (hasOwn.call(key, \"weight\")) {\n                            weight = key.weight;\n                            if (weight <= 0) {\n                                throw new Error(INVALID_KEY_WEIGHT_VALUE(name));\n                            }\n                        }\n                        path = createKeyPath(name);\n                        id = createKeyId(name);\n                        getFn = key.getFn;\n                    }\n                    return {\n                        path,\n                        id,\n                        weight,\n                        src,\n                        getFn\n                    };\n                }\n                function createKeyPath(key) {\n                    return isArray(key) ? key : key.split(\".\");\n                }\n                function createKeyId(key) {\n                    return isArray(key) ? key.join(\".\") : key;\n                }\n                function get(obj, path) {\n                    let list = [];\n                    let arr = false;\n                    const deepGet = (obj, path, index)=>{\n                        if (!isDefined(obj)) {\n                            return;\n                        }\n                        if (!path[index]) {\n                            // If there's no path left, we've arrived at the object we care about.\n                            list.push(obj);\n                        } else {\n                            let key = path[index];\n                            const value = obj[key];\n                            if (!isDefined(value)) {\n                                return;\n                            }\n                            // If we're at the last value in the path, and if it's a string/number/bool,\n                            // add it to the list\n                            if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {\n                                list.push(toString(value));\n                            } else if (isArray(value)) {\n                                arr = true;\n                                // Search each item in the array.\n                                for(let i = 0, len = value.length; i < len; i += 1){\n                                    deepGet(value[i], path, index + 1);\n                                }\n                            } else if (path.length) {\n                                // An object. Recurse further.\n                                deepGet(value, path, index + 1);\n                            }\n                        }\n                    };\n                    // Backwards compatibility (since path used to be a string)\n                    deepGet(obj, isString(path) ? path.split(\".\") : path, 0);\n                    return arr ? list : list[0];\n                }\n                const MatchOptions = {\n                    // Whether the matches should be included in the result set. When `true`, each record in the result\n                    // set will include the indices of the matched characters.\n                    // These can consequently be used for highlighting purposes.\n                    includeMatches: false,\n                    // When `true`, the matching function will continue to the end of a search pattern even if\n                    // a perfect match has already been located in the string.\n                    findAllMatches: false,\n                    // Minimum number of characters that must be matched before a result is considered a match\n                    minMatchCharLength: 1\n                };\n                const BasicOptions = {\n                    // When `true`, the algorithm continues searching to the end of the input even if a perfect\n                    // match is found before the end of the same input.\n                    isCaseSensitive: false,\n                    // When true, the matching function will continue to the end of a search pattern even if\n                    includeScore: false,\n                    // List of properties that will be searched. This also supports nested properties.\n                    keys: [],\n                    // Whether to sort the result list, by score\n                    shouldSort: true,\n                    // Default sort function: sort by ascending score, ascending index\n                    sortFn: (a, b)=>a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1\n                };\n                const FuzzyOptions = {\n                    // Approximately where in the text is the pattern expected to be found?\n                    location: 0,\n                    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n                    // (of both letters and location), a threshold of '1.0' would match anything.\n                    threshold: 0.6,\n                    // Determines how close the match must be to the fuzzy location (specified above).\n                    // An exact letter match which is 'distance' characters away from the fuzzy location\n                    // would score as a complete mismatch. A distance of '0' requires the match be at\n                    // the exact location specified, a threshold of '1000' would require a perfect match\n                    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n                    distance: 100\n                };\n                const AdvancedOptions = {\n                    // When `true`, it enables the use of unix-like search commands\n                    useExtendedSearch: false,\n                    // The get function to use when fetching an object's properties.\n                    // The default will search nested paths *ie foo.bar.baz*\n                    getFn: get,\n                    // When `true`, search will ignore `location` and `distance`, so it won't matter\n                    // where in the string the pattern appears.\n                    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n                    ignoreLocation: false,\n                    // When `true`, the calculation for the relevance score (used for sorting) will\n                    // ignore the field-length norm.\n                    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n                    ignoreFieldNorm: false,\n                    // The weight to determine how much field length norm effects scoring.\n                    fieldNormWeight: 1\n                };\n                var Config = {\n                    ...BasicOptions,\n                    ...MatchOptions,\n                    ...FuzzyOptions,\n                    ...AdvancedOptions\n                };\n                const SPACE = /[^ ]+/g;\n                // Field-length norm: the shorter the field, the higher the weight.\n                // Set to 3 decimals to reduce index size.\n                function norm(weight = 1, mantissa = 3) {\n                    const cache = new Map();\n                    const m = Math.pow(10, mantissa);\n                    return {\n                        get (value) {\n                            const numTokens = value.match(SPACE).length;\n                            if (cache.has(numTokens)) {\n                                return cache.get(numTokens);\n                            }\n                            // Default function is 1/sqrt(x), weight makes that variable\n                            const norm = 1 / Math.pow(numTokens, 0.5 * weight);\n                            // In place of `toFixed(mantissa)`, for faster computation\n                            const n = parseFloat(Math.round(norm * m) / m);\n                            cache.set(numTokens, n);\n                            return n;\n                        },\n                        clear () {\n                            cache.clear();\n                        }\n                    };\n                }\n                class FuseIndex {\n                    constructor({ getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}){\n                        this.norm = norm(fieldNormWeight, 3);\n                        this.getFn = getFn;\n                        this.isCreated = false;\n                        this.setIndexRecords();\n                    }\n                    setSources(docs = []) {\n                        this.docs = docs;\n                    }\n                    setIndexRecords(records = []) {\n                        this.records = records;\n                    }\n                    setKeys(keys = []) {\n                        this.keys = keys;\n                        this._keysMap = {};\n                        keys.forEach((key, idx)=>{\n                            this._keysMap[key.id] = idx;\n                        });\n                    }\n                    create() {\n                        if (this.isCreated || !this.docs.length) {\n                            return;\n                        }\n                        this.isCreated = true;\n                        // List is Array<String>\n                        if (isString(this.docs[0])) {\n                            this.docs.forEach((doc, docIndex)=>{\n                                this._addString(doc, docIndex);\n                            });\n                        } else {\n                            // List is Array<Object>\n                            this.docs.forEach((doc, docIndex)=>{\n                                this._addObject(doc, docIndex);\n                            });\n                        }\n                        this.norm.clear();\n                    }\n                    // Adds a doc to the end of the index\n                    add(doc) {\n                        const idx = this.size();\n                        if (isString(doc)) {\n                            this._addString(doc, idx);\n                        } else {\n                            this._addObject(doc, idx);\n                        }\n                    }\n                    // Removes the doc at the specified index of the index\n                    removeAt(idx) {\n                        this.records.splice(idx, 1);\n                        // Change ref index of every subsquent doc\n                        for(let i = idx, len = this.size(); i < len; i += 1){\n                            this.records[i].i -= 1;\n                        }\n                    }\n                    getValueForItemAtKeyId(item, keyId) {\n                        return item[this._keysMap[keyId]];\n                    }\n                    size() {\n                        return this.records.length;\n                    }\n                    _addString(doc, docIndex) {\n                        if (!isDefined(doc) || isBlank(doc)) {\n                            return;\n                        }\n                        let record = {\n                            v: doc,\n                            i: docIndex,\n                            n: this.norm.get(doc)\n                        };\n                        this.records.push(record);\n                    }\n                    _addObject(doc, docIndex) {\n                        let record = {\n                            i: docIndex,\n                            $: {}\n                        };\n                        // Iterate over every key (i.e, path), and fetch the value at that key\n                        this.keys.forEach((key, keyIndex)=>{\n                            let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);\n                            if (!isDefined(value)) {\n                                return;\n                            }\n                            if (isArray(value)) {\n                                let subRecords = [];\n                                const stack = [\n                                    {\n                                        nestedArrIndex: -1,\n                                        value\n                                    }\n                                ];\n                                while(stack.length){\n                                    const { nestedArrIndex, value } = stack.pop();\n                                    if (!isDefined(value)) {\n                                        continue;\n                                    }\n                                    if (isString(value) && !isBlank(value)) {\n                                        let subRecord = {\n                                            v: value,\n                                            i: nestedArrIndex,\n                                            n: this.norm.get(value)\n                                        };\n                                        subRecords.push(subRecord);\n                                    } else if (isArray(value)) {\n                                        value.forEach((item, k)=>{\n                                            stack.push({\n                                                nestedArrIndex: k,\n                                                value: item\n                                            });\n                                        });\n                                    } else ;\n                                }\n                                record.$[keyIndex] = subRecords;\n                            } else if (isString(value) && !isBlank(value)) {\n                                let subRecord = {\n                                    v: value,\n                                    n: this.norm.get(value)\n                                };\n                                record.$[keyIndex] = subRecord;\n                            }\n                        });\n                        this.records.push(record);\n                    }\n                    toJSON() {\n                        return {\n                            keys: this.keys,\n                            records: this.records\n                        };\n                    }\n                }\n                function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {\n                    const myIndex = new FuseIndex({\n                        getFn,\n                        fieldNormWeight\n                    });\n                    myIndex.setKeys(keys.map(createKey));\n                    myIndex.setSources(docs);\n                    myIndex.create();\n                    return myIndex;\n                }\n                function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {\n                    const { keys, records } = data;\n                    const myIndex = new FuseIndex({\n                        getFn,\n                        fieldNormWeight\n                    });\n                    myIndex.setKeys(keys);\n                    myIndex.setIndexRecords(records);\n                    return myIndex;\n                }\n                function computeScore$1(pattern, { errors = 0, currentLocation = 0, expectedLocation = 0, distance = Config.distance, ignoreLocation = Config.ignoreLocation } = {}) {\n                    const accuracy = errors / pattern.length;\n                    if (ignoreLocation) {\n                        return accuracy;\n                    }\n                    const proximity = Math.abs(expectedLocation - currentLocation);\n                    if (!distance) {\n                        // Dodge divide by zero error.\n                        return proximity ? 1.0 : accuracy;\n                    }\n                    return accuracy + proximity / distance;\n                }\n                function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {\n                    let indices = [];\n                    let start = -1;\n                    let end = -1;\n                    let i = 0;\n                    for(let len = matchmask.length; i < len; i += 1){\n                        let match = matchmask[i];\n                        if (match && start === -1) {\n                            start = i;\n                        } else if (!match && start !== -1) {\n                            end = i - 1;\n                            if (end - start + 1 >= minMatchCharLength) {\n                                indices.push([\n                                    start,\n                                    end\n                                ]);\n                            }\n                            start = -1;\n                        }\n                    }\n                    // (i-1 - start) + 1 => i - start\n                    if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n                        indices.push([\n                            start,\n                            i - 1\n                        ]);\n                    }\n                    return indices;\n                }\n                // Machine word size\n                const MAX_BITS = 32;\n                function search(text, pattern, patternAlphabet, { location = Config.location, distance = Config.distance, threshold = Config.threshold, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, includeMatches = Config.includeMatches, ignoreLocation = Config.ignoreLocation } = {}) {\n                    if (pattern.length > MAX_BITS) {\n                        throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));\n                    }\n                    const patternLen = pattern.length;\n                    // Set starting location at beginning text and initialize the alphabet.\n                    const textLen = text.length;\n                    // Handle the case when location > text.length\n                    const expectedLocation = Math.max(0, Math.min(location, textLen));\n                    // Highest score beyond which we give up.\n                    let currentThreshold = threshold;\n                    // Is there a nearby exact match? (speedup)\n                    let bestLocation = expectedLocation;\n                    // Performance: only computer matches when the minMatchCharLength > 1\n                    // OR if `includeMatches` is true.\n                    const computeMatches = minMatchCharLength > 1 || includeMatches;\n                    // A mask of the matches, used for building the indices\n                    const matchMask = computeMatches ? Array(textLen) : [];\n                    let index;\n                    // Get all exact matches, here for speed up\n                    while((index = text.indexOf(pattern, bestLocation)) > -1){\n                        let score = computeScore$1(pattern, {\n                            currentLocation: index,\n                            expectedLocation,\n                            distance,\n                            ignoreLocation\n                        });\n                        currentThreshold = Math.min(score, currentThreshold);\n                        bestLocation = index + patternLen;\n                        if (computeMatches) {\n                            let i = 0;\n                            while(i < patternLen){\n                                matchMask[index + i] = 1;\n                                i += 1;\n                            }\n                        }\n                    }\n                    // Reset the best location\n                    bestLocation = -1;\n                    let lastBitArr = [];\n                    let finalScore = 1;\n                    let binMax = patternLen + textLen;\n                    const mask = 1 << patternLen - 1;\n                    for(let i = 0; i < patternLen; i += 1){\n                        // Scan for the best match; each iteration allows for one more error.\n                        // Run a binary search to determine how far from the match location we can stray\n                        // at this error level.\n                        let binMin = 0;\n                        let binMid = binMax;\n                        while(binMin < binMid){\n                            const score = computeScore$1(pattern, {\n                                errors: i,\n                                currentLocation: expectedLocation + binMid,\n                                expectedLocation,\n                                distance,\n                                ignoreLocation\n                            });\n                            if (score <= currentThreshold) {\n                                binMin = binMid;\n                            } else {\n                                binMax = binMid;\n                            }\n                            binMid = Math.floor((binMax - binMin) / 2 + binMin);\n                        }\n                        // Use the result from this iteration as the maximum for the next.\n                        binMax = binMid;\n                        let start = Math.max(1, expectedLocation - binMid + 1);\n                        let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;\n                        // Initialize the bit array\n                        let bitArr = Array(finish + 2);\n                        bitArr[finish + 1] = (1 << i) - 1;\n                        for(let j = finish; j >= start; j -= 1){\n                            let currentLocation = j - 1;\n                            let charMatch = patternAlphabet[text.charAt(currentLocation)];\n                            if (computeMatches) {\n                                // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n                                matchMask[currentLocation] = +!!charMatch;\n                            }\n                            // First pass: exact match\n                            bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;\n                            // Subsequent passes: fuzzy match\n                            if (i) {\n                                bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];\n                            }\n                            if (bitArr[j] & mask) {\n                                finalScore = computeScore$1(pattern, {\n                                    errors: i,\n                                    currentLocation,\n                                    expectedLocation,\n                                    distance,\n                                    ignoreLocation\n                                });\n                                // This match will almost certainly be better than any existing match.\n                                // But check anyway.\n                                if (finalScore <= currentThreshold) {\n                                    // Indeed it is\n                                    currentThreshold = finalScore;\n                                    bestLocation = currentLocation;\n                                    // Already passed `loc`, downhill from here on in.\n                                    if (bestLocation <= expectedLocation) {\n                                        break;\n                                    }\n                                    // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n                                    start = Math.max(1, 2 * expectedLocation - bestLocation);\n                                }\n                            }\n                        }\n                        // No hope for a (better) match at greater error levels.\n                        const score = computeScore$1(pattern, {\n                            errors: i + 1,\n                            currentLocation: expectedLocation,\n                            expectedLocation,\n                            distance,\n                            ignoreLocation\n                        });\n                        if (score > currentThreshold) {\n                            break;\n                        }\n                        lastBitArr = bitArr;\n                    }\n                    const result = {\n                        isMatch: bestLocation >= 0,\n                        // Count exact matches (those with a score of 0) to be \"almost\" exact\n                        score: Math.max(0.001, finalScore)\n                    };\n                    if (computeMatches) {\n                        const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n                        if (!indices.length) {\n                            result.isMatch = false;\n                        } else if (includeMatches) {\n                            result.indices = indices;\n                        }\n                    }\n                    return result;\n                }\n                function createPatternAlphabet(pattern) {\n                    let mask = {};\n                    for(let i = 0, len = pattern.length; i < len; i += 1){\n                        const char = pattern.charAt(i);\n                        mask[char] = (mask[char] || 0) | 1 << len - i - 1;\n                    }\n                    return mask;\n                }\n                class BitapSearch {\n                    constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreLocation = Config.ignoreLocation } = {}){\n                        this.options = {\n                            location,\n                            threshold,\n                            distance,\n                            includeMatches,\n                            findAllMatches,\n                            minMatchCharLength,\n                            isCaseSensitive,\n                            ignoreLocation\n                        };\n                        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n                        this.chunks = [];\n                        if (!this.pattern.length) {\n                            return;\n                        }\n                        const addChunk = (pattern, startIndex)=>{\n                            this.chunks.push({\n                                pattern,\n                                alphabet: createPatternAlphabet(pattern),\n                                startIndex\n                            });\n                        };\n                        const len = this.pattern.length;\n                        if (len > MAX_BITS) {\n                            let i = 0;\n                            const remainder = len % MAX_BITS;\n                            const end = len - remainder;\n                            while(i < end){\n                                addChunk(this.pattern.substr(i, MAX_BITS), i);\n                                i += MAX_BITS;\n                            }\n                            if (remainder) {\n                                const startIndex = len - MAX_BITS;\n                                addChunk(this.pattern.substr(startIndex), startIndex);\n                            }\n                        } else {\n                            addChunk(this.pattern, 0);\n                        }\n                    }\n                    searchIn(text) {\n                        const { isCaseSensitive, includeMatches } = this.options;\n                        if (!isCaseSensitive) {\n                            text = text.toLowerCase();\n                        }\n                        // Exact match\n                        if (this.pattern === text) {\n                            let result = {\n                                isMatch: true,\n                                score: 0\n                            };\n                            if (includeMatches) {\n                                result.indices = [\n                                    [\n                                        0,\n                                        text.length - 1\n                                    ]\n                                ];\n                            }\n                            return result;\n                        }\n                        // Otherwise, use Bitap algorithm\n                        const { location, distance, threshold, findAllMatches, minMatchCharLength, ignoreLocation } = this.options;\n                        let allIndices = [];\n                        let totalScore = 0;\n                        let hasMatches = false;\n                        this.chunks.forEach(({ pattern, alphabet, startIndex })=>{\n                            const { isMatch, score, indices } = search(text, pattern, alphabet, {\n                                location: location + startIndex,\n                                distance,\n                                threshold,\n                                findAllMatches,\n                                minMatchCharLength,\n                                includeMatches,\n                                ignoreLocation\n                            });\n                            if (isMatch) {\n                                hasMatches = true;\n                            }\n                            totalScore += score;\n                            if (isMatch && indices) {\n                                allIndices = [\n                                    ...allIndices,\n                                    ...indices\n                                ];\n                            }\n                        });\n                        let result = {\n                            isMatch: hasMatches,\n                            score: hasMatches ? totalScore / this.chunks.length : 1\n                        };\n                        if (hasMatches && includeMatches) {\n                            result.indices = allIndices;\n                        }\n                        return result;\n                    }\n                }\n                class BaseMatch {\n                    constructor(pattern){\n                        this.pattern = pattern;\n                    }\n                    static isMultiMatch(pattern) {\n                        return getMatch(pattern, this.multiRegex);\n                    }\n                    static isSingleMatch(pattern) {\n                        return getMatch(pattern, this.singleRegex);\n                    }\n                    search() {}\n                }\n                function getMatch(pattern, exp) {\n                    const matches = pattern.match(exp);\n                    return matches ? matches[1] : null;\n                }\n                // Token: 'file\n                class ExactMatch extends BaseMatch {\n                    constructor(pattern){\n                        super(pattern);\n                    }\n                    static get type() {\n                        return \"exact\";\n                    }\n                    static get multiRegex() {\n                        return /^=\"(.*)\"$/;\n                    }\n                    static get singleRegex() {\n                        return /^=(.*)$/;\n                    }\n                    search(text) {\n                        const isMatch = text === this.pattern;\n                        return {\n                            isMatch,\n                            score: isMatch ? 0 : 1,\n                            indices: [\n                                0,\n                                this.pattern.length - 1\n                            ]\n                        };\n                    }\n                }\n                // Token: !fire\n                class InverseExactMatch extends BaseMatch {\n                    constructor(pattern){\n                        super(pattern);\n                    }\n                    static get type() {\n                        return \"inverse-exact\";\n                    }\n                    static get multiRegex() {\n                        return /^!\"(.*)\"$/;\n                    }\n                    static get singleRegex() {\n                        return /^!(.*)$/;\n                    }\n                    search(text) {\n                        const index = text.indexOf(this.pattern);\n                        const isMatch = index === -1;\n                        return {\n                            isMatch,\n                            score: isMatch ? 0 : 1,\n                            indices: [\n                                0,\n                                text.length - 1\n                            ]\n                        };\n                    }\n                }\n                // Token: ^file\n                class PrefixExactMatch extends BaseMatch {\n                    constructor(pattern){\n                        super(pattern);\n                    }\n                    static get type() {\n                        return \"prefix-exact\";\n                    }\n                    static get multiRegex() {\n                        return /^\\^\"(.*)\"$/;\n                    }\n                    static get singleRegex() {\n                        return /^\\^(.*)$/;\n                    }\n                    search(text) {\n                        const isMatch = text.startsWith(this.pattern);\n                        return {\n                            isMatch,\n                            score: isMatch ? 0 : 1,\n                            indices: [\n                                0,\n                                this.pattern.length - 1\n                            ]\n                        };\n                    }\n                }\n                // Token: !^fire\n                class InversePrefixExactMatch extends BaseMatch {\n                    constructor(pattern){\n                        super(pattern);\n                    }\n                    static get type() {\n                        return \"inverse-prefix-exact\";\n                    }\n                    static get multiRegex() {\n                        return /^!\\^\"(.*)\"$/;\n                    }\n                    static get singleRegex() {\n                        return /^!\\^(.*)$/;\n                    }\n                    search(text) {\n                        const isMatch = !text.startsWith(this.pattern);\n                        return {\n                            isMatch,\n                            score: isMatch ? 0 : 1,\n                            indices: [\n                                0,\n                                text.length - 1\n                            ]\n                        };\n                    }\n                }\n                // Token: .file$\n                class SuffixExactMatch extends BaseMatch {\n                    constructor(pattern){\n                        super(pattern);\n                    }\n                    static get type() {\n                        return \"suffix-exact\";\n                    }\n                    static get multiRegex() {\n                        return /^\"(.*)\"\\$$/;\n                    }\n                    static get singleRegex() {\n                        return /^(.*)\\$$/;\n                    }\n                    search(text) {\n                        const isMatch = text.endsWith(this.pattern);\n                        return {\n                            isMatch,\n                            score: isMatch ? 0 : 1,\n                            indices: [\n                                text.length - this.pattern.length,\n                                text.length - 1\n                            ]\n                        };\n                    }\n                }\n                // Token: !.file$\n                class InverseSuffixExactMatch extends BaseMatch {\n                    constructor(pattern){\n                        super(pattern);\n                    }\n                    static get type() {\n                        return \"inverse-suffix-exact\";\n                    }\n                    static get multiRegex() {\n                        return /^!\"(.*)\"\\$$/;\n                    }\n                    static get singleRegex() {\n                        return /^!(.*)\\$$/;\n                    }\n                    search(text) {\n                        const isMatch = !text.endsWith(this.pattern);\n                        return {\n                            isMatch,\n                            score: isMatch ? 0 : 1,\n                            indices: [\n                                0,\n                                text.length - 1\n                            ]\n                        };\n                    }\n                }\n                class FuzzyMatch extends BaseMatch {\n                    constructor(pattern, { location = Config.location, threshold = Config.threshold, distance = Config.distance, includeMatches = Config.includeMatches, findAllMatches = Config.findAllMatches, minMatchCharLength = Config.minMatchCharLength, isCaseSensitive = Config.isCaseSensitive, ignoreLocation = Config.ignoreLocation } = {}){\n                        super(pattern);\n                        this._bitapSearch = new BitapSearch(pattern, {\n                            location,\n                            threshold,\n                            distance,\n                            includeMatches,\n                            findAllMatches,\n                            minMatchCharLength,\n                            isCaseSensitive,\n                            ignoreLocation\n                        });\n                    }\n                    static get type() {\n                        return \"fuzzy\";\n                    }\n                    static get multiRegex() {\n                        return /^\"(.*)\"$/;\n                    }\n                    static get singleRegex() {\n                        return /^(.*)$/;\n                    }\n                    search(text) {\n                        return this._bitapSearch.searchIn(text);\n                    }\n                }\n                // Token: 'file\n                class IncludeMatch extends BaseMatch {\n                    constructor(pattern){\n                        super(pattern);\n                    }\n                    static get type() {\n                        return \"include\";\n                    }\n                    static get multiRegex() {\n                        return /^'\"(.*)\"$/;\n                    }\n                    static get singleRegex() {\n                        return /^'(.*)$/;\n                    }\n                    search(text) {\n                        let location = 0;\n                        let index;\n                        const indices = [];\n                        const patternLen = this.pattern.length;\n                        // Get all exact matches\n                        while((index = text.indexOf(this.pattern, location)) > -1){\n                            location = index + patternLen;\n                            indices.push([\n                                index,\n                                location - 1\n                            ]);\n                        }\n                        const isMatch = !!indices.length;\n                        return {\n                            isMatch,\n                            score: isMatch ? 0 : 1,\n                            indices\n                        };\n                    }\n                }\n                // âOrder is important. DO NOT CHANGE.\n                const searchers = [\n                    ExactMatch,\n                    IncludeMatch,\n                    PrefixExactMatch,\n                    InversePrefixExactMatch,\n                    InverseSuffixExactMatch,\n                    SuffixExactMatch,\n                    InverseExactMatch,\n                    FuzzyMatch\n                ];\n                const searchersLen = searchers.length;\n                // Regex to split by spaces, but keep anything in quotes together\n                const SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\n                const OR_TOKEN = \"|\";\n                // Return a 2D array representation of the query, for simpler parsing.\n                // Example:\n                // \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\n                function parseQuery(pattern, options = {}) {\n                    return pattern.split(OR_TOKEN).map((item)=>{\n                        let query = item.trim().split(SPACE_RE).filter((item)=>item && !!item.trim());\n                        let results = [];\n                        for(let i = 0, len = query.length; i < len; i += 1){\n                            const queryItem = query[i];\n                            // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n                            let found = false;\n                            let idx = -1;\n                            while(!found && ++idx < searchersLen){\n                                const searcher = searchers[idx];\n                                let token = searcher.isMultiMatch(queryItem);\n                                if (token) {\n                                    results.push(new searcher(token, options));\n                                    found = true;\n                                }\n                            }\n                            if (found) {\n                                continue;\n                            }\n                            // 2. Handle single query matches (i.e, once that are *not* quoted)\n                            idx = -1;\n                            while(++idx < searchersLen){\n                                const searcher = searchers[idx];\n                                let token = searcher.isSingleMatch(queryItem);\n                                if (token) {\n                                    results.push(new searcher(token, options));\n                                    break;\n                                }\n                            }\n                        }\n                        return results;\n                    });\n                }\n                // These extended matchers can return an array of matches, as opposed\n                // to a singl match\n                const MultiMatchSet = new Set([\n                    FuzzyMatch.type,\n                    IncludeMatch.type\n                ]);\n                /**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */ class ExtendedSearch {\n                    constructor(pattern, { isCaseSensitive = Config.isCaseSensitive, includeMatches = Config.includeMatches, minMatchCharLength = Config.minMatchCharLength, ignoreLocation = Config.ignoreLocation, findAllMatches = Config.findAllMatches, location = Config.location, threshold = Config.threshold, distance = Config.distance } = {}){\n                        this.query = null;\n                        this.options = {\n                            isCaseSensitive,\n                            includeMatches,\n                            minMatchCharLength,\n                            findAllMatches,\n                            ignoreLocation,\n                            location,\n                            threshold,\n                            distance\n                        };\n                        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n                        this.query = parseQuery(this.pattern, this.options);\n                    }\n                    static condition(_, options) {\n                        return options.useExtendedSearch;\n                    }\n                    searchIn(text) {\n                        const query = this.query;\n                        if (!query) {\n                            return {\n                                isMatch: false,\n                                score: 1\n                            };\n                        }\n                        const { includeMatches, isCaseSensitive } = this.options;\n                        text = isCaseSensitive ? text : text.toLowerCase();\n                        let numMatches = 0;\n                        let allIndices = [];\n                        let totalScore = 0;\n                        // ORs\n                        for(let i = 0, qLen = query.length; i < qLen; i += 1){\n                            const searchers = query[i];\n                            // Reset indices\n                            allIndices.length = 0;\n                            numMatches = 0;\n                            // ANDs\n                            for(let j = 0, pLen = searchers.length; j < pLen; j += 1){\n                                const searcher = searchers[j];\n                                const { isMatch, indices, score } = searcher.search(text);\n                                if (isMatch) {\n                                    numMatches += 1;\n                                    totalScore += score;\n                                    if (includeMatches) {\n                                        const type = searcher.constructor.type;\n                                        if (MultiMatchSet.has(type)) {\n                                            allIndices = [\n                                                ...allIndices,\n                                                ...indices\n                                            ];\n                                        } else {\n                                            allIndices.push(indices);\n                                        }\n                                    }\n                                } else {\n                                    totalScore = 0;\n                                    numMatches = 0;\n                                    allIndices.length = 0;\n                                    break;\n                                }\n                            }\n                            // OR condition, so if TRUE, return\n                            if (numMatches) {\n                                let result = {\n                                    isMatch: true,\n                                    score: totalScore / numMatches\n                                };\n                                if (includeMatches) {\n                                    result.indices = allIndices;\n                                }\n                                return result;\n                            }\n                        }\n                        // Nothing was matched\n                        return {\n                            isMatch: false,\n                            score: 1\n                        };\n                    }\n                }\n                const registeredSearchers = [];\n                function register(...args) {\n                    registeredSearchers.push(...args);\n                }\n                function createSearcher(pattern, options) {\n                    for(let i = 0, len = registeredSearchers.length; i < len; i += 1){\n                        let searcherClass = registeredSearchers[i];\n                        if (searcherClass.condition(pattern, options)) {\n                            return new searcherClass(pattern, options);\n                        }\n                    }\n                    return new BitapSearch(pattern, options);\n                }\n                const LogicalOperator = {\n                    AND: \"$and\",\n                    OR: \"$or\"\n                };\n                const KeyType = {\n                    PATH: \"$path\",\n                    PATTERN: \"$val\"\n                };\n                const isExpression = (query)=>!!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\n                const isPath = (query)=>!!query[KeyType.PATH];\n                const isLeaf = (query)=>!isArray(query) && isObject(query) && !isExpression(query);\n                const convertToExplicit = (query)=>({\n                        [LogicalOperator.AND]: Object.keys(query).map((key)=>({\n                                [key]: query[key]\n                            }))\n                    });\n                // When `auto` is `true`, the parse function will infer and initialize and add\n                // the appropriate `Searcher` instance\n                function parse(query, options, { auto = true } = {}) {\n                    const next = (query)=>{\n                        let keys = Object.keys(query);\n                        const isQueryPath = isPath(query);\n                        if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n                            return next(convertToExplicit(query));\n                        }\n                        if (isLeaf(query)) {\n                            const key = isQueryPath ? query[KeyType.PATH] : keys[0];\n                            const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n                            if (!isString(pattern)) {\n                                throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));\n                            }\n                            const obj = {\n                                keyId: createKeyId(key),\n                                pattern\n                            };\n                            if (auto) {\n                                obj.searcher = createSearcher(pattern, options);\n                            }\n                            return obj;\n                        }\n                        let node = {\n                            children: [],\n                            operator: keys[0]\n                        };\n                        keys.forEach((key)=>{\n                            const value = query[key];\n                            if (isArray(value)) {\n                                value.forEach((item)=>{\n                                    node.children.push(next(item));\n                                });\n                            }\n                        });\n                        return node;\n                    };\n                    if (!isExpression(query)) {\n                        query = convertToExplicit(query);\n                    }\n                    return next(query);\n                }\n                // Practical scoring function\n                function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {\n                    results.forEach((result)=>{\n                        let totalScore = 1;\n                        result.matches.forEach(({ key, norm, score })=>{\n                            const weight = key ? key.weight : null;\n                            totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));\n                        });\n                        result.score = totalScore;\n                    });\n                }\n                function transformMatches(result, data) {\n                    const matches = result.matches;\n                    data.matches = [];\n                    if (!isDefined(matches)) {\n                        return;\n                    }\n                    matches.forEach((match)=>{\n                        if (!isDefined(match.indices) || !match.indices.length) {\n                            return;\n                        }\n                        const { indices, value } = match;\n                        let obj = {\n                            indices,\n                            value\n                        };\n                        if (match.key) {\n                            obj.key = match.key.src;\n                        }\n                        if (match.idx > -1) {\n                            obj.refIndex = match.idx;\n                        }\n                        data.matches.push(obj);\n                    });\n                }\n                function transformScore(result, data) {\n                    data.score = result.score;\n                }\n                function format(results, docs, { includeMatches = Config.includeMatches, includeScore = Config.includeScore } = {}) {\n                    const transformers = [];\n                    if (includeMatches) transformers.push(transformMatches);\n                    if (includeScore) transformers.push(transformScore);\n                    return results.map((result)=>{\n                        const { idx } = result;\n                        const data = {\n                            item: docs[idx],\n                            refIndex: idx\n                        };\n                        if (transformers.length) {\n                            transformers.forEach((transformer)=>{\n                                transformer(result, data);\n                            });\n                        }\n                        return data;\n                    });\n                }\n                class Fuse {\n                    constructor(docs, options = {}, index){\n                        this.options = {\n                            ...Config,\n                            ...options\n                        };\n                        if (this.options.useExtendedSearch && !true) {}\n                        this._keyStore = new KeyStore(this.options.keys);\n                        this.setCollection(docs, index);\n                    }\n                    setCollection(docs, index) {\n                        this._docs = docs;\n                        if (index && !(index instanceof FuseIndex)) {\n                            throw new Error(INCORRECT_INDEX_TYPE);\n                        }\n                        this._myIndex = index || createIndex(this.options.keys, this._docs, {\n                            getFn: this.options.getFn,\n                            fieldNormWeight: this.options.fieldNormWeight\n                        });\n                    }\n                    add(doc) {\n                        if (!isDefined(doc)) {\n                            return;\n                        }\n                        this._docs.push(doc);\n                        this._myIndex.add(doc);\n                    }\n                    remove(predicate = ()=>false) {\n                        const results = [];\n                        for(let i = 0, len = this._docs.length; i < len; i += 1){\n                            const doc = this._docs[i];\n                            if (predicate(doc, i)) {\n                                this.removeAt(i);\n                                i -= 1;\n                                len -= 1;\n                                results.push(doc);\n                            }\n                        }\n                        return results;\n                    }\n                    removeAt(idx) {\n                        this._docs.splice(idx, 1);\n                        this._myIndex.removeAt(idx);\n                    }\n                    getIndex() {\n                        return this._myIndex;\n                    }\n                    search(query, { limit = -1 } = {}) {\n                        const { includeMatches, includeScore, shouldSort, sortFn, ignoreFieldNorm } = this.options;\n                        let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);\n                        computeScore(results, {\n                            ignoreFieldNorm\n                        });\n                        if (shouldSort) {\n                            results.sort(sortFn);\n                        }\n                        if (isNumber(limit) && limit > -1) {\n                            results = results.slice(0, limit);\n                        }\n                        return format(results, this._docs, {\n                            includeMatches,\n                            includeScore\n                        });\n                    }\n                    _searchStringList(query) {\n                        const searcher = createSearcher(query, this.options);\n                        const { records } = this._myIndex;\n                        const results = [];\n                        // Iterate over every string in the index\n                        records.forEach(({ v: text, i: idx, n: norm })=>{\n                            if (!isDefined(text)) {\n                                return;\n                            }\n                            const { isMatch, score, indices } = searcher.searchIn(text);\n                            if (isMatch) {\n                                results.push({\n                                    item: text,\n                                    idx,\n                                    matches: [\n                                        {\n                                            score,\n                                            value: text,\n                                            norm,\n                                            indices\n                                        }\n                                    ]\n                                });\n                            }\n                        });\n                        return results;\n                    }\n                    _searchLogical(query) {\n                        const expression = parse(query, this.options);\n                        const evaluate = (node, item, idx)=>{\n                            if (!node.children) {\n                                const { keyId, searcher } = node;\n                                const matches = this._findMatches({\n                                    key: this._keyStore.get(keyId),\n                                    value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n                                    searcher\n                                });\n                                if (matches && matches.length) {\n                                    return [\n                                        {\n                                            idx,\n                                            item,\n                                            matches\n                                        }\n                                    ];\n                                }\n                                return [];\n                            }\n                            const res = [];\n                            for(let i = 0, len = node.children.length; i < len; i += 1){\n                                const child = node.children[i];\n                                const result = evaluate(child, item, idx);\n                                if (result.length) {\n                                    res.push(...result);\n                                } else if (node.operator === LogicalOperator.AND) {\n                                    return [];\n                                }\n                            }\n                            return res;\n                        };\n                        const records = this._myIndex.records;\n                        const resultMap = {};\n                        const results = [];\n                        records.forEach(({ $: item, i: idx })=>{\n                            if (isDefined(item)) {\n                                let expResults = evaluate(expression, item, idx);\n                                if (expResults.length) {\n                                    // Dedupe when adding\n                                    if (!resultMap[idx]) {\n                                        resultMap[idx] = {\n                                            idx,\n                                            item,\n                                            matches: []\n                                        };\n                                        results.push(resultMap[idx]);\n                                    }\n                                    expResults.forEach(({ matches })=>{\n                                        resultMap[idx].matches.push(...matches);\n                                    });\n                                }\n                            }\n                        });\n                        return results;\n                    }\n                    _searchObjectList(query) {\n                        const searcher = createSearcher(query, this.options);\n                        const { keys, records } = this._myIndex;\n                        const results = [];\n                        // List is Array<Object>\n                        records.forEach(({ $: item, i: idx })=>{\n                            if (!isDefined(item)) {\n                                return;\n                            }\n                            let matches = [];\n                            // Iterate over every key (i.e, path), and fetch the value at that key\n                            keys.forEach((key, keyIndex)=>{\n                                matches.push(...this._findMatches({\n                                    key,\n                                    value: item[keyIndex],\n                                    searcher\n                                }));\n                            });\n                            if (matches.length) {\n                                results.push({\n                                    idx,\n                                    item,\n                                    matches\n                                });\n                            }\n                        });\n                        return results;\n                    }\n                    _findMatches({ key, value, searcher }) {\n                        if (!isDefined(value)) {\n                            return [];\n                        }\n                        let matches = [];\n                        if (isArray(value)) {\n                            value.forEach(({ v: text, i: idx, n: norm })=>{\n                                if (!isDefined(text)) {\n                                    return;\n                                }\n                                const { isMatch, score, indices } = searcher.searchIn(text);\n                                if (isMatch) {\n                                    matches.push({\n                                        score,\n                                        key,\n                                        value: text,\n                                        idx,\n                                        norm,\n                                        indices\n                                    });\n                                }\n                            });\n                        } else {\n                            const { v: text, n: norm } = value;\n                            const { isMatch, score, indices } = searcher.searchIn(text);\n                            if (isMatch) {\n                                matches.push({\n                                    score,\n                                    key,\n                                    value: text,\n                                    norm,\n                                    indices\n                                });\n                            }\n                        }\n                        return matches;\n                    }\n                }\n                Fuse.version = \"6.6.2\";\n                Fuse.createIndex = createIndex;\n                Fuse.parseIndex = parseIndex;\n                Fuse.config = Config;\n                {\n                    Fuse.parseQuery = parse;\n                }\n                {\n                    register(ExtendedSearch);\n                }\n            /***/ },\n            /***/ 791: /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_278357__) {\n                // ESM COMPAT FLAG\n                __nested_webpack_require_278357__.r(__nested_webpack_exports__);\n                // EXPORTS\n                __nested_webpack_require_278357__.d(__nested_webpack_exports__, {\n                    \"__DO_NOT_USE__ActionTypes\": function() {\n                        return /* binding */ ActionTypes;\n                    },\n                    \"applyMiddleware\": function() {\n                        return /* binding */ applyMiddleware;\n                    },\n                    \"bindActionCreators\": function() {\n                        return /* binding */ bindActionCreators;\n                    },\n                    \"combineReducers\": function() {\n                        return /* binding */ combineReducers;\n                    },\n                    \"compose\": function() {\n                        return /* binding */ compose;\n                    },\n                    \"createStore\": function() {\n                        return /* binding */ createStore;\n                    },\n                    \"legacy_createStore\": function() {\n                        return /* binding */ legacy_createStore;\n                    }\n                });\n                ; // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js\n                function _typeof(obj) {\n                    \"@babel/helpers - typeof\";\n                    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n                        return typeof obj;\n                    } : function(obj) {\n                        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    }, _typeof(obj);\n                }\n                ; // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\n                function _toPrimitive(input, hint) {\n                    if (_typeof(input) !== \"object\" || input === null) return input;\n                    var prim = input[Symbol.toPrimitive];\n                    if (prim !== undefined) {\n                        var res = prim.call(input, hint || \"default\");\n                        if (_typeof(res) !== \"object\") return res;\n                        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                    }\n                    return (hint === \"string\" ? String : Number)(input);\n                }\n                ; // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\n                function _toPropertyKey(arg) {\n                    var key = _toPrimitive(arg, \"string\");\n                    return _typeof(key) === \"symbol\" ? key : String(key);\n                }\n                ; // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js\n                function _defineProperty(obj, key, value) {\n                    key = _toPropertyKey(key);\n                    if (key in obj) {\n                        Object.defineProperty(obj, key, {\n                            value: value,\n                            enumerable: true,\n                            configurable: true,\n                            writable: true\n                        });\n                    } else {\n                        obj[key] = value;\n                    }\n                    return obj;\n                }\n                ; // CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\n                function ownKeys(object, enumerableOnly) {\n                    var keys = Object.keys(object);\n                    if (Object.getOwnPropertySymbols) {\n                        var symbols = Object.getOwnPropertySymbols(object);\n                        enumerableOnly && (symbols = symbols.filter(function(sym) {\n                            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n                        })), keys.push.apply(keys, symbols);\n                    }\n                    return keys;\n                }\n                function _objectSpread2(target) {\n                    for(var i = 1; i < arguments.length; i++){\n                        var source = null != arguments[i] ? arguments[i] : {};\n                        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n                            _defineProperty(target, key, source[key]);\n                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n                            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n                        });\n                    }\n                    return target;\n                }\n                ; // CONCATENATED MODULE: ./node_modules/redux/es/redux.js\n                /**\n * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js\n *\n * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes\n * during build.\n * @param {number} code\n */ function formatProdErrorMessage(code) {\n                    return \"Minified Redux error #\" + code + \"; visit https://redux.js.org/Errors?code=\" + code + \" for the full message or \" + \"use the non-minified dev environment for full errors. \";\n                }\n                // Inlined version of the `symbol-observable` polyfill\n                var $$observable = function() {\n                    return typeof Symbol === \"function\" && Symbol.observable || \"@@observable\";\n                }();\n                /**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */ var randomString = function randomString() {\n                    return Math.random().toString(36).substring(7).split(\"\").join(\".\");\n                };\n                var ActionTypes = {\n                    INIT: \"@@redux/INIT\" + randomString(),\n                    REPLACE: \"@@redux/REPLACE\" + randomString(),\n                    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n                        return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n                    }\n                };\n                /**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */ function isPlainObject(obj) {\n                    if (typeof obj !== \"object\" || obj === null) return false;\n                    var proto = obj;\n                    while(Object.getPrototypeOf(proto) !== null){\n                        proto = Object.getPrototypeOf(proto);\n                    }\n                    return Object.getPrototypeOf(obj) === proto;\n                }\n                // Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of\n                function miniKindOf(val) {\n                    if (val === void 0) return \"undefined\";\n                    if (val === null) return \"null\";\n                    var type = typeof val;\n                    switch(type){\n                        case \"boolean\":\n                        case \"string\":\n                        case \"number\":\n                        case \"symbol\":\n                        case \"function\":\n                            {\n                                return type;\n                            }\n                    }\n                    if (Array.isArray(val)) return \"array\";\n                    if (isDate(val)) return \"date\";\n                    if (isError(val)) return \"error\";\n                    var constructorName = ctorName(val);\n                    switch(constructorName){\n                        case \"Symbol\":\n                        case \"Promise\":\n                        case \"WeakMap\":\n                        case \"WeakSet\":\n                        case \"Map\":\n                        case \"Set\":\n                            return constructorName;\n                    } // other\n                    return type.slice(8, -1).toLowerCase().replace(/\\s/g, \"\");\n                }\n                function ctorName(val) {\n                    return typeof val.constructor === \"function\" ? val.constructor.name : null;\n                }\n                function isError(val) {\n                    return val instanceof Error || typeof val.message === \"string\" && val.constructor && typeof val.constructor.stackTraceLimit === \"number\";\n                }\n                function isDate(val) {\n                    if (val instanceof Date) return true;\n                    return typeof val.toDateString === \"function\" && typeof val.getDate === \"function\" && typeof val.setDate === \"function\";\n                }\n                function kindOf(val) {\n                    var typeOfVal = typeof val;\n                    if (false) {}\n                    return typeOfVal;\n                }\n                /**\n * @deprecated\n *\n * **We recommend using the `configureStore` method\n * of the `@reduxjs/toolkit` package**, which replaces `createStore`.\n *\n * Redux Toolkit is our recommended approach for writing Redux logic today,\n * including store setup, reducers, data fetching, and more.\n *\n * **For more details, please read this Redux docs page:**\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * `configureStore` from Redux Toolkit is an improved version of `createStore` that\n * simplifies setup and helps avoid common bugs.\n *\n * You should not be using the `redux` core package by itself today, except for learning purposes.\n * The `createStore` method from the core `redux` package will not be removed, but we encourage\n * all users to migrate to using Redux Toolkit for all Redux code.\n *\n * If you want to use `createStore` without this visual deprecation warning, use\n * the `legacy_createStore` import instead:\n *\n * `import { legacy_createStore as createStore} from 'redux'`\n *\n */ function createStore(reducer, preloadedState, enhancer) {\n                    var _ref2;\n                    if (typeof preloadedState === \"function\" && typeof enhancer === \"function\" || typeof enhancer === \"function\" && typeof arguments[3] === \"function\") {\n                        throw new Error( true ? formatProdErrorMessage(0) : 0);\n                    }\n                    if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n                        enhancer = preloadedState;\n                        preloadedState = undefined;\n                    }\n                    if (typeof enhancer !== \"undefined\") {\n                        if (typeof enhancer !== \"function\") {\n                            throw new Error( true ? formatProdErrorMessage(1) : 0);\n                        }\n                        return enhancer(createStore)(reducer, preloadedState);\n                    }\n                    if (typeof reducer !== \"function\") {\n                        throw new Error( true ? formatProdErrorMessage(2) : 0);\n                    }\n                    var currentReducer = reducer;\n                    var currentState = preloadedState;\n                    var currentListeners = [];\n                    var nextListeners = currentListeners;\n                    var isDispatching = false;\n                    /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */ function ensureCanMutateNextListeners() {\n                        if (nextListeners === currentListeners) {\n                            nextListeners = currentListeners.slice();\n                        }\n                    }\n                    /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */ function getState() {\n                        if (isDispatching) {\n                            throw new Error( true ? formatProdErrorMessage(3) : 0);\n                        }\n                        return currentState;\n                    }\n                    /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */ function subscribe(listener) {\n                        if (typeof listener !== \"function\") {\n                            throw new Error( true ? formatProdErrorMessage(4) : 0);\n                        }\n                        if (isDispatching) {\n                            throw new Error( true ? formatProdErrorMessage(5) : 0);\n                        }\n                        var isSubscribed = true;\n                        ensureCanMutateNextListeners();\n                        nextListeners.push(listener);\n                        return function unsubscribe() {\n                            if (!isSubscribed) {\n                                return;\n                            }\n                            if (isDispatching) {\n                                throw new Error( true ? formatProdErrorMessage(6) : 0);\n                            }\n                            isSubscribed = false;\n                            ensureCanMutateNextListeners();\n                            var index = nextListeners.indexOf(listener);\n                            nextListeners.splice(index, 1);\n                            currentListeners = null;\n                        };\n                    }\n                    /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing âwhat changedâ. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */ function dispatch(action) {\n                        if (!isPlainObject(action)) {\n                            throw new Error( true ? formatProdErrorMessage(7) : 0);\n                        }\n                        if (typeof action.type === \"undefined\") {\n                            throw new Error( true ? formatProdErrorMessage(8) : 0);\n                        }\n                        if (isDispatching) {\n                            throw new Error( true ? formatProdErrorMessage(9) : 0);\n                        }\n                        try {\n                            isDispatching = true;\n                            currentState = currentReducer(currentState, action);\n                        } finally{\n                            isDispatching = false;\n                        }\n                        var listeners = currentListeners = nextListeners;\n                        for(var i = 0; i < listeners.length; i++){\n                            var listener = listeners[i];\n                            listener();\n                        }\n                        return action;\n                    }\n                    /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */ function replaceReducer(nextReducer) {\n                        if (typeof nextReducer !== \"function\") {\n                            throw new Error( true ? formatProdErrorMessage(10) : 0);\n                        }\n                        currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n                        // Any reducers that existed in both the new and old rootReducer\n                        // will receive the previous state. This effectively populates\n                        // the new state tree with any relevant data from the old one.\n                        dispatch({\n                            type: ActionTypes.REPLACE\n                        });\n                    }\n                    /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */ function observable() {\n                        var _ref;\n                        var outerSubscribe = subscribe;\n                        return _ref = {\n                            /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */ subscribe: function subscribe(observer) {\n                                if (typeof observer !== \"object\" || observer === null) {\n                                    throw new Error( true ? formatProdErrorMessage(11) : 0);\n                                }\n                                function observeState() {\n                                    if (observer.next) {\n                                        observer.next(getState());\n                                    }\n                                }\n                                observeState();\n                                var unsubscribe = outerSubscribe(observeState);\n                                return {\n                                    unsubscribe: unsubscribe\n                                };\n                            }\n                        }, _ref[$$observable] = function() {\n                            return this;\n                        }, _ref;\n                    } // When a store is created, an \"INIT\" action is dispatched so that every\n                    // reducer returns their initial state. This effectively populates\n                    // the initial state tree.\n                    dispatch({\n                        type: ActionTypes.INIT\n                    });\n                    return _ref2 = {\n                        dispatch: dispatch,\n                        subscribe: subscribe,\n                        getState: getState,\n                        replaceReducer: replaceReducer\n                    }, _ref2[$$observable] = observable, _ref2;\n                }\n                /**\n * Creates a Redux store that holds the state tree.\n *\n * **We recommend using `configureStore` from the\n * `@reduxjs/toolkit` package**, which replaces `createStore`:\n * **https://redux.js.org/introduction/why-rtk-is-redux-today**\n *\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */ var legacy_createStore = createStore;\n                /**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */ function warning(message) {\n                    /* eslint-disable no-console */ if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\n                        console.error(message);\n                    }\n                    /* eslint-enable no-console */ try {\n                        // This error was thrown as a convenience so that if you enable\n                        // \"break on all exceptions\" in your console,\n                        // it would pause the execution at this line.\n                        throw new Error(message);\n                    } catch (e) {} // eslint-disable-line no-empty\n                }\n                function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n                    var reducerKeys = Object.keys(reducers);\n                    var argumentName = action && action.type === ActionTypes.INIT ? \"preloadedState argument passed to createStore\" : \"previous state received by the reducer\";\n                    if (reducerKeys.length === 0) {\n                        return \"Store does not have a valid reducer. Make sure the argument passed \" + \"to combineReducers is an object whose values are reducers.\";\n                    }\n                    if (!isPlainObject(inputState)) {\n                        return \"The \" + argumentName + ' has unexpected type of \"' + kindOf(inputState) + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n                    }\n                    var unexpectedKeys = Object.keys(inputState).filter(function(key) {\n                        return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n                    });\n                    unexpectedKeys.forEach(function(key) {\n                        unexpectedKeyCache[key] = true;\n                    });\n                    if (action && action.type === ActionTypes.REPLACE) return;\n                    if (unexpectedKeys.length > 0) {\n                        return \"Unexpected \" + (unexpectedKeys.length > 1 ? \"keys\" : \"key\") + \" \" + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + \". \") + \"Expected to find one of the known reducer keys instead: \" + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n                    }\n                }\n                function assertReducerShape(reducers) {\n                    Object.keys(reducers).forEach(function(key) {\n                        var reducer = reducers[key];\n                        var initialState = reducer(undefined, {\n                            type: ActionTypes.INIT\n                        });\n                        if (typeof initialState === \"undefined\") {\n                            throw new Error( true ? formatProdErrorMessage(12) : 0);\n                        }\n                        if (typeof reducer(undefined, {\n                            type: ActionTypes.PROBE_UNKNOWN_ACTION()\n                        }) === \"undefined\") {\n                            throw new Error( true ? formatProdErrorMessage(13) : 0);\n                        }\n                    });\n                }\n                /**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */ function combineReducers(reducers) {\n                    var reducerKeys = Object.keys(reducers);\n                    var finalReducers = {};\n                    for(var i = 0; i < reducerKeys.length; i++){\n                        var key = reducerKeys[i];\n                        if (false) {}\n                        if (typeof reducers[key] === \"function\") {\n                            finalReducers[key] = reducers[key];\n                        }\n                    }\n                    var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same\n                    // keys multiple times.\n                    var unexpectedKeyCache;\n                    if (false) {}\n                    var shapeAssertionError;\n                    try {\n                        assertReducerShape(finalReducers);\n                    } catch (e) {\n                        shapeAssertionError = e;\n                    }\n                    return function combination(state, action) {\n                        if (state === void 0) {\n                            state = {};\n                        }\n                        if (shapeAssertionError) {\n                            throw shapeAssertionError;\n                        }\n                        if (false) { var warningMessage; }\n                        var hasChanged = false;\n                        var nextState = {};\n                        for(var _i = 0; _i < finalReducerKeys.length; _i++){\n                            var _key = finalReducerKeys[_i];\n                            var reducer = finalReducers[_key];\n                            var previousStateForKey = state[_key];\n                            var nextStateForKey = reducer(previousStateForKey, action);\n                            if (typeof nextStateForKey === \"undefined\") {\n                                var actionType = action && action.type;\n                                throw new Error( true ? formatProdErrorMessage(14) : 0);\n                            }\n                            nextState[_key] = nextStateForKey;\n                            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n                        }\n                        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n                        return hasChanged ? nextState : state;\n                    };\n                }\n                function bindActionCreator(actionCreator, dispatch) {\n                    return function() {\n                        return dispatch(actionCreator.apply(this, arguments));\n                    };\n                }\n                /**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */ function bindActionCreators(actionCreators, dispatch) {\n                    if (typeof actionCreators === \"function\") {\n                        return bindActionCreator(actionCreators, dispatch);\n                    }\n                    if (typeof actionCreators !== \"object\" || actionCreators === null) {\n                        throw new Error( true ? formatProdErrorMessage(16) : 0);\n                    }\n                    var boundActionCreators = {};\n                    for(var key in actionCreators){\n                        var actionCreator = actionCreators[key];\n                        if (typeof actionCreator === \"function\") {\n                            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n                        }\n                    }\n                    return boundActionCreators;\n                }\n                /**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */ function compose() {\n                    for(var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++){\n                        funcs[_key] = arguments[_key];\n                    }\n                    if (funcs.length === 0) {\n                        return function(arg) {\n                            return arg;\n                        };\n                    }\n                    if (funcs.length === 1) {\n                        return funcs[0];\n                    }\n                    return funcs.reduce(function(a, b) {\n                        return function() {\n                            return a(b.apply(void 0, arguments));\n                        };\n                    });\n                }\n                /**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */ function applyMiddleware() {\n                    for(var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++){\n                        middlewares[_key] = arguments[_key];\n                    }\n                    return function(createStore) {\n                        return function() {\n                            var store = createStore.apply(void 0, arguments);\n                            var _dispatch = function dispatch() {\n                                throw new Error( true ? formatProdErrorMessage(15) : 0);\n                            };\n                            var middlewareAPI = {\n                                getState: store.getState,\n                                dispatch: function dispatch() {\n                                    return _dispatch.apply(void 0, arguments);\n                                }\n                            };\n                            var chain = middlewares.map(function(middleware) {\n                                return middleware(middlewareAPI);\n                            });\n                            _dispatch = compose.apply(void 0, chain)(store.dispatch);\n                            return _objectSpread2(_objectSpread2({}, store), {}, {\n                                dispatch: _dispatch\n                            });\n                        };\n                    };\n                }\n                /*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */ function isCrushed() {}\n                if (false) {}\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_313209__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_313209__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ !function() {\n            /******/ // getDefaultExport function for compatibility with non-harmony modules\n            /******/ __nested_webpack_require_313209__.n = function(module1) {\n                /******/ var getter = module1 && module1.__esModule ? /******/ function() {\n                    return module1[\"default\"];\n                } : /******/ function() {\n                    return module1;\n                };\n                /******/ __nested_webpack_require_313209__.d(getter, {\n                    a: getter\n                });\n                /******/ return getter;\n            /******/ };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/define property getters */ /******/ !function() {\n            /******/ // define getter functions for harmony exports\n            /******/ __nested_webpack_require_313209__.d = function(exports1, definition) {\n                /******/ for(var key in definition){\n                    /******/ if (__nested_webpack_require_313209__.o(definition, key) && !__nested_webpack_require_313209__.o(exports1, key)) {\n                        /******/ Object.defineProperty(exports1, key, {\n                            enumerable: true,\n                            get: definition[key]\n                        });\n                    /******/ }\n                /******/ }\n            /******/ };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ !function() {\n            /******/ __nested_webpack_require_313209__.o = function(obj, prop) {\n                return Object.prototype.hasOwnProperty.call(obj, prop);\n            };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ !function() {\n            /******/ // define __esModule on exports\n            /******/ __nested_webpack_require_313209__.r = function(exports1) {\n                /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                        value: \"Module\"\n                    });\n                /******/ }\n                /******/ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /******/ };\n        /******/ }();\n        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};\n        // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n        !function() {\n            /* harmony import */ var _scripts_choices__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_313209__(373);\n            /* harmony import */ var _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_313209__.n(_scripts_choices__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var _scripts_interfaces__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_313209__(187);\n            /* harmony import */ var _scripts_interfaces__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_313209__.n(_scripts_interfaces__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var _scripts_constants__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_313209__(883);\n            /* harmony import */ var _scripts_defaults__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_313209__(789);\n            /* harmony import */ var _scripts_templates__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_313209__(686);\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default();\n        }();\n        __nested_webpack_exports__ = __nested_webpack_exports__[\"default\"];\n        /******/ return __nested_webpack_exports__;\n    /******/ }();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hvaWNlcy5qcy9wdWJsaWMvYXNzZXRzL3NjcmlwdHMvY2hvaWNlcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsNEZBQTRGLEdBQzNGLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0Q7U0FDYixFQUt3QkE7QUFDOUIsR0FBR0ssUUFBUTtJQUNYLE9BQWdCLE1BQUgsR0FBSTtRQUNqQixNQUFNLEdBQUk7UUFDVixNQUFNLEdBQUksSUFBSUMsc0JBQXVCO1lBRXJDLEdBQUcsR0FBRyxLQUNOLEdBQUcsR0FBSSxTQUFTQyx1QkFBdUIsRUFBRU4sUUFBTyxFQUFFTyw4QkFBbUI7Z0JBSXJFQyxPQUFPQyxjQUFjLENBQUNULFVBQVMsY0FBZTtvQkFDNUNVLE9BQU87Z0JBQ1Q7Z0JBQ0FWLFNBQVFXLFlBQVksR0FBR1gsU0FBUVksZUFBZSxHQUFHWixTQUFRYSxhQUFhLEdBQUdiLFNBQVFjLFNBQVMsR0FBRyxLQUFLO2dCQUNsRyxJQUFJQyxjQUFjUiw4QkFBbUJBLENBQUM7Z0JBQ3RDLElBQUlPLFlBQVksU0FBVUUsRUFBRTtvQkFDMUIsSUFBSU4sUUFBUU0sR0FBR04sS0FBSyxFQUNsQk8sUUFBUUQsR0FBR0MsS0FBSyxFQUNoQkMsS0FBS0YsR0FBR0UsRUFBRSxFQUNWQyxVQUFVSCxHQUFHRyxPQUFPLEVBQ3BCQyxXQUFXSixHQUFHSSxRQUFRLEVBQ3RCQyxZQUFZTCxHQUFHSyxTQUFTLEVBQ3hCQyxtQkFBbUJOLEdBQUdNLGdCQUFnQixFQUN0Q0MsY0FBY1AsR0FBR08sV0FBVyxFQUM1QkMsVUFBVVIsR0FBR1EsT0FBTztvQkFDdEIsT0FBTzt3QkFDTEMsTUFBTVYsWUFBWVcsWUFBWSxDQUFDQyxVQUFVO3dCQUN6Q2pCLE9BQU9BO3dCQUNQTyxPQUFPQTt3QkFDUEMsSUFBSUE7d0JBQ0pDLFNBQVNBO3dCQUNUQyxVQUFVQTt3QkFDVkMsV0FBV0E7d0JB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RCxNQUFNLEdBQUksT0FBT0EsMEJBQW1CQTtJQUNwQyxNQUFNLEdBQUc7QUFFVCIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2R1Y3QtYXBwLy4vbm9kZV9tb2R1bGVzL2Nob2ljZXMuanMvcHVibGljL2Fzc2V0cy9zY3JpcHRzL2Nob2ljZXMuanM/NTJkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgY2hvaWNlcy5qcyB2MTAuMi4wIHwgwqkgMjAyMiBKb3NoIEpvaG5zb24gfCBodHRwczovL2dpdGh1Yi5jb20vanNoam9obnNvbi9DaG9pY2VzI3JlYWRtZSAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQ2hvaWNlc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJDaG9pY2VzXCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gMjgyOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmNsZWFyQ2hvaWNlcyA9IGV4cG9ydHMuYWN0aXZhdGVDaG9pY2VzID0gZXhwb3J0cy5maWx0ZXJDaG9pY2VzID0gZXhwb3J0cy5hZGRDaG9pY2UgPSB2b2lkIDA7XG52YXIgY29uc3RhbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4Myk7XG52YXIgYWRkQ2hvaWNlID0gZnVuY3Rpb24gKF9hKSB7XG4gIHZhciB2YWx1ZSA9IF9hLnZhbHVlLFxuICAgIGxhYmVsID0gX2EubGFiZWwsXG4gICAgaWQgPSBfYS5pZCxcbiAgICBncm91cElkID0gX2EuZ3JvdXBJZCxcbiAgICBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLFxuICAgIGVsZW1lbnRJZCA9IF9hLmVsZW1lbnRJZCxcbiAgICBjdXN0b21Qcm9wZXJ0aWVzID0gX2EuY3VzdG9tUHJvcGVydGllcyxcbiAgICBwbGFjZWhvbGRlciA9IF9hLnBsYWNlaG9sZGVyLFxuICAgIGtleUNvZGUgPSBfYS5rZXlDb2RlO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGNvbnN0YW50c18xLkFDVElPTl9UWVBFUy5BRERfQ0hPSUNFLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBsYWJlbDogbGFiZWwsXG4gICAgaWQ6IGlkLFxuICAgIGdyb3VwSWQ6IGdyb3VwSWQsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIGVsZW1lbnRJZDogZWxlbWVudElkLFxuICAgIGN1c3RvbVByb3BlcnRpZXM6IGN1c3RvbVByb3BlcnRpZXMsXG4gICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgIGtleUNvZGU6IGtleUNvZGVcbiAgfTtcbn07XG5leHBvcnRzLmFkZENob2ljZSA9IGFkZENob2ljZTtcbnZhciBmaWx0ZXJDaG9pY2VzID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBjb25zdGFudHNfMS5BQ1RJT05fVFlQRVMuRklMVEVSX0NIT0lDRVMsXG4gICAgcmVzdWx0czogcmVzdWx0c1xuICB9O1xufTtcbmV4cG9ydHMuZmlsdGVyQ2hvaWNlcyA9IGZpbHRlckNob2ljZXM7XG52YXIgYWN0aXZhdGVDaG9pY2VzID0gZnVuY3Rpb24gKGFjdGl2ZSkge1xuICBpZiAoYWN0aXZlID09PSB2b2lkIDApIHtcbiAgICBhY3RpdmUgPSB0cnVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogY29uc3RhbnRzXzEuQUNUSU9OX1RZUEVTLkFDVElWQVRFX0NIT0lDRVMsXG4gICAgYWN0aXZlOiBhY3RpdmVcbiAgfTtcbn07XG5leHBvcnRzLmFjdGl2YXRlQ2hvaWNlcyA9IGFjdGl2YXRlQ2hvaWNlcztcbnZhciBjbGVhckNob2ljZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogY29uc3RhbnRzXzEuQUNUSU9OX1RZUEVTLkNMRUFSX0NIT0lDRVNcbiAgfTtcbn07XG5leHBvcnRzLmNsZWFyQ2hvaWNlcyA9IGNsZWFyQ2hvaWNlcztcblxuLyoqKi8gfSksXG5cbi8qKiovIDc4Mzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5hZGRHcm91cCA9IHZvaWQgMDtcbnZhciBjb25zdGFudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODgzKTtcbnZhciBhZGRHcm91cCA9IGZ1bmN0aW9uIChfYSkge1xuICB2YXIgdmFsdWUgPSBfYS52YWx1ZSxcbiAgICBpZCA9IF9hLmlkLFxuICAgIGFjdGl2ZSA9IF9hLmFjdGl2ZSxcbiAgICBkaXNhYmxlZCA9IF9hLmRpc2FibGVkO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGNvbnN0YW50c18xLkFDVElPTl9UWVBFUy5BRERfR1JPVVAsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGlkOiBpZCxcbiAgICBhY3RpdmU6IGFjdGl2ZSxcbiAgICBkaXNhYmxlZDogZGlzYWJsZWRcbiAgfTtcbn07XG5leHBvcnRzLmFkZEdyb3VwID0gYWRkR3JvdXA7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NjQ6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuaGlnaGxpZ2h0SXRlbSA9IGV4cG9ydHMucmVtb3ZlSXRlbSA9IGV4cG9ydHMuYWRkSXRlbSA9IHZvaWQgMDtcbnZhciBjb25zdGFudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODgzKTtcbnZhciBhZGRJdGVtID0gZnVuY3Rpb24gKF9hKSB7XG4gIHZhciB2YWx1ZSA9IF9hLnZhbHVlLFxuICAgIGxhYmVsID0gX2EubGFiZWwsXG4gICAgaWQgPSBfYS5pZCxcbiAgICBjaG9pY2VJZCA9IF9hLmNob2ljZUlkLFxuICAgIGdyb3VwSWQgPSBfYS5ncm91cElkLFxuICAgIGN1c3RvbVByb3BlcnRpZXMgPSBfYS5jdXN0b21Qcm9wZXJ0aWVzLFxuICAgIHBsYWNlaG9sZGVyID0gX2EucGxhY2Vob2xkZXIsXG4gICAga2V5Q29kZSA9IF9hLmtleUNvZGU7XG4gIHJldHVybiB7XG4gICAgdHlwZTogY29uc3RhbnRzXzEuQUNUSU9OX1RZUEVTLkFERF9JVEVNLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBsYWJlbDogbGFiZWwsXG4gICAgaWQ6IGlkLFxuICAgIGNob2ljZUlkOiBjaG9pY2VJZCxcbiAgICBncm91cElkOiBncm91cElkLFxuICAgIGN1c3RvbVByb3BlcnRpZXM6IGN1c3RvbVByb3BlcnRpZXMsXG4gICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgIGtleUNvZGU6IGtleUNvZGVcbiAgfTtcbn07XG5leHBvcnRzLmFkZEl0ZW0gPSBhZGRJdGVtO1xudmFyIHJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoaWQsIGNob2ljZUlkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogY29uc3RhbnRzXzEuQUNUSU9OX1RZUEVTLlJFTU9WRV9JVEVNLFxuICAgIGlkOiBpZCxcbiAgICBjaG9pY2VJZDogY2hvaWNlSWRcbiAgfTtcbn07XG5leHBvcnRzLnJlbW92ZUl0ZW0gPSByZW1vdmVJdGVtO1xudmFyIGhpZ2hsaWdodEl0ZW0gPSBmdW5jdGlvbiAoaWQsIGhpZ2hsaWdodGVkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogY29uc3RhbnRzXzEuQUNUSU9OX1RZUEVTLkhJR0hMSUdIVF9JVEVNLFxuICAgIGlkOiBpZCxcbiAgICBoaWdobGlnaHRlZDogaGlnaGxpZ2h0ZWRcbiAgfTtcbn07XG5leHBvcnRzLmhpZ2hsaWdodEl0ZW0gPSBoaWdobGlnaHRJdGVtO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTM3OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLnNldElzTG9hZGluZyA9IGV4cG9ydHMucmVzZXRUbyA9IGV4cG9ydHMuY2xlYXJBbGwgPSB2b2lkIDA7XG52YXIgY29uc3RhbnRzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4Myk7XG52YXIgY2xlYXJBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogY29uc3RhbnRzXzEuQUNUSU9OX1RZUEVTLkNMRUFSX0FMTFxuICB9O1xufTtcbmV4cG9ydHMuY2xlYXJBbGwgPSBjbGVhckFsbDtcbnZhciByZXNldFRvID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogY29uc3RhbnRzXzEuQUNUSU9OX1RZUEVTLlJFU0VUX1RPLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9O1xufTtcbmV4cG9ydHMucmVzZXRUbyA9IHJlc2V0VG87XG52YXIgc2V0SXNMb2FkaW5nID0gZnVuY3Rpb24gKGlzTG9hZGluZykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGNvbnN0YW50c18xLkFDVElPTl9UWVBFUy5TRVRfSVNfTE9BRElORyxcbiAgICBpc0xvYWRpbmc6IGlzTG9hZGluZ1xuICB9O1xufTtcbmV4cG9ydHMuc2V0SXNMb2FkaW5nID0gc2V0SXNMb2FkaW5nO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMzczOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuXG52YXIgX19zcHJlYWRBcnJheSA9IHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICBhcltpXSA9IGZyb21baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xudmFyIGRlZXBtZXJnZV8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOTk2KSk7XG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG52YXIgZnVzZV9qc18xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjIxKSk7XG52YXIgY2hvaWNlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyODIpO1xudmFyIGdyb3Vwc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODMpO1xudmFyIGl0ZW1zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2NCk7XG52YXIgbWlzY18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzcpO1xudmFyIGNvbXBvbmVudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIwKTtcbnZhciBjb25zdGFudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODgzKTtcbnZhciBkZWZhdWx0c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODkpO1xudmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5OSk7XG52YXIgcmVkdWNlcnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjU1KTtcbnZhciBzdG9yZV8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNzQ0KSk7XG52YXIgdGVtcGxhdGVzXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2ODYpKTtcbi8qKiBAc2VlIHtAbGluayBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1hY2VhMDc1ZDBhYzY5NTRmMjc1YTcwMDIzOTA2MDUwY30gKi9cbnZhciBJU19JRTExID0gJy1tcy1zY3JvbGwtbGltaXQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiAnLW1zLWltZS1hbGlnbicgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xudmFyIFVTRVJfREVGQVVMVFMgPSB7fTtcbi8qKlxuICogQ2hvaWNlc1xuICogQGF1dGhvciBKb3NoIEpvaG5zb248am9zaEBqb3NodWFqb2huc29uLmNvLnVrPlxuICovXG52YXIgQ2hvaWNlcyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENob2ljZXMoZWxlbWVudCwgdXNlckNvbmZpZykge1xuICAgIGlmIChlbGVtZW50ID09PSB2b2lkIDApIHtcbiAgICAgIGVsZW1lbnQgPSAnW2RhdGEtY2hvaWNlXSc7XG4gICAgfVxuICAgIGlmICh1c2VyQ29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgIHVzZXJDb25maWcgPSB7fTtcbiAgICB9XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodXNlckNvbmZpZy5hbGxvd0hUTUwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiBhbGxvd0hUTUwgd2lsbCBkZWZhdWx0IHRvIGZhbHNlIGluIGEgZnV0dXJlIHJlbGVhc2UuIFRvIHJlbmRlciBIVE1MIGluIENob2ljZXMsIHlvdSB3aWxsIG5lZWQgdG8gc2V0IGl0IHRvIHRydWUuIFNldHRpbmcgYWxsb3dIVE1MIHdpbGwgc3VwcHJlc3MgdGhpcyBtZXNzYWdlLicpO1xuICAgIH1cbiAgICB0aGlzLmNvbmZpZyA9IGRlZXBtZXJnZV8xLmRlZmF1bHQuYWxsKFtkZWZhdWx0c18xLkRFRkFVTFRfQ09ORklHLCBDaG9pY2VzLmRlZmF1bHRzLm9wdGlvbnMsIHVzZXJDb25maWddLFxuICAgIC8vIFdoZW4gbWVyZ2luZyBhcnJheSBjb25maWdzLCByZXBsYWNlIHdpdGggYSBjb3B5IG9mIHRoZSB1c2VyQ29uZmlnIGFycmF5LFxuICAgIC8vIGluc3RlYWQgb2YgY29uY2F0ZW5hdGluZyB3aXRoIHRoZSBkZWZhdWx0IGFycmF5XG4gICAge1xuICAgICAgYXJyYXlNZXJnZTogZnVuY3Rpb24gKF8sIHNvdXJjZUFycmF5KSB7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KFtdLCBzb3VyY2VBcnJheSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGludmFsaWRDb25maWdPcHRpb25zID0gKDAsIHV0aWxzXzEuZGlmZikodGhpcy5jb25maWcsIGRlZmF1bHRzXzEuREVGQVVMVF9DT05GSUcpO1xuICAgIGlmIChpbnZhbGlkQ29uZmlnT3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5rbm93biBjb25maWcgb3B0aW9uKHMpIHBhc3NlZCcsIGludmFsaWRDb25maWdPcHRpb25zLmpvaW4oJywgJykpO1xuICAgIH1cbiAgICB2YXIgcGFzc2VkRWxlbWVudCA9IHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCkgOiBlbGVtZW50O1xuICAgIGlmICghKHBhc3NlZEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8IHBhc3NlZEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignRXhwZWN0ZWQgb25lIG9mIHRoZSBmb2xsb3dpbmcgdHlwZXMgdGV4dHxzZWxlY3Qtb25lfHNlbGVjdC1tdWx0aXBsZScpO1xuICAgIH1cbiAgICB0aGlzLl9pc1RleHRFbGVtZW50ID0gcGFzc2VkRWxlbWVudC50eXBlID09PSBjb25zdGFudHNfMS5URVhUX1RZUEU7XG4gICAgdGhpcy5faXNTZWxlY3RPbmVFbGVtZW50ID0gcGFzc2VkRWxlbWVudC50eXBlID09PSBjb25zdGFudHNfMS5TRUxFQ1RfT05FX1RZUEU7XG4gICAgdGhpcy5faXNTZWxlY3RNdWx0aXBsZUVsZW1lbnQgPSBwYXNzZWRFbGVtZW50LnR5cGUgPT09IGNvbnN0YW50c18xLlNFTEVDVF9NVUxUSVBMRV9UWVBFO1xuICAgIHRoaXMuX2lzU2VsZWN0RWxlbWVudCA9IHRoaXMuX2lzU2VsZWN0T25lRWxlbWVudCB8fCB0aGlzLl9pc1NlbGVjdE11bHRpcGxlRWxlbWVudDtcbiAgICB0aGlzLmNvbmZpZy5zZWFyY2hFbmFibGVkID0gdGhpcy5faXNTZWxlY3RNdWx0aXBsZUVsZW1lbnQgfHwgdGhpcy5jb25maWcuc2VhcmNoRW5hYmxlZDtcbiAgICBpZiAoIVsnYXV0bycsICdhbHdheXMnXS5pbmNsdWRlcyhcIlwiLmNvbmNhdCh0aGlzLmNvbmZpZy5yZW5kZXJTZWxlY3RlZENob2ljZXMpKSkge1xuICAgICAgdGhpcy5jb25maWcucmVuZGVyU2VsZWN0ZWRDaG9pY2VzID0gJ2F1dG8nO1xuICAgIH1cbiAgICBpZiAodXNlckNvbmZpZy5hZGRJdGVtRmlsdGVyICYmIHR5cGVvZiB1c2VyQ29uZmlnLmFkZEl0ZW1GaWx0ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciByZSA9IHVzZXJDb25maWcuYWRkSXRlbUZpbHRlciBpbnN0YW5jZW9mIFJlZ0V4cCA/IHVzZXJDb25maWcuYWRkSXRlbUZpbHRlciA6IG5ldyBSZWdFeHAodXNlckNvbmZpZy5hZGRJdGVtRmlsdGVyKTtcbiAgICAgIHRoaXMuY29uZmlnLmFkZEl0ZW1GaWx0ZXIgPSByZS50ZXN0LmJpbmQocmUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNUZXh0RWxlbWVudCkge1xuICAgICAgdGhpcy5wYXNzZWRFbGVtZW50ID0gbmV3IGNvbXBvbmVudHNfMS5XcmFwcGVkSW5wdXQoe1xuICAgICAgICBlbGVtZW50OiBwYXNzZWRFbGVtZW50LFxuICAgICAgICBjbGFzc05hbWVzOiB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLFxuICAgICAgICBkZWxpbWl0ZXI6IHRoaXMuY29uZmlnLmRlbGltaXRlclxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFzc2VkRWxlbWVudCA9IG5ldyBjb21wb25lbnRzXzEuV3JhcHBlZFNlbGVjdCh7XG4gICAgICAgIGVsZW1lbnQ6IHBhc3NlZEVsZW1lbnQsXG4gICAgICAgIGNsYXNzTmFtZXM6IHRoaXMuY29uZmlnLmNsYXNzTmFtZXMsXG4gICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5fdGVtcGxhdGVzLm9wdGlvbihkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbGlzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZSA9IG5ldyBzdG9yZV8xLmRlZmF1bHQoKTtcbiAgICB0aGlzLl9pbml0aWFsU3RhdGUgPSByZWR1Y2Vyc18xLmRlZmF1bHRTdGF0ZTtcbiAgICB0aGlzLl9jdXJyZW50U3RhdGUgPSByZWR1Y2Vyc18xLmRlZmF1bHRTdGF0ZTtcbiAgICB0aGlzLl9wcmV2U3RhdGUgPSByZWR1Y2Vyc18xLmRlZmF1bHRTdGF0ZTtcbiAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSAnJztcbiAgICB0aGlzLl9jYW5TZWFyY2ggPSAhIXRoaXMuY29uZmlnLnNlYXJjaEVuYWJsZWQ7XG4gICAgdGhpcy5faXNTY3JvbGxpbmdPbkllID0gZmFsc2U7XG4gICAgdGhpcy5faGlnaGxpZ2h0UG9zaXRpb24gPSAwO1xuICAgIHRoaXMuX3dhc1RhcCA9IHRydWU7XG4gICAgdGhpcy5fcGxhY2Vob2xkZXJWYWx1ZSA9IHRoaXMuX2dlbmVyYXRlUGxhY2Vob2xkZXJWYWx1ZSgpO1xuICAgIHRoaXMuX2Jhc2VJZCA9ICgwLCB1dGlsc18xLmdlbmVyYXRlSWQpKHRoaXMucGFzc2VkRWxlbWVudC5lbGVtZW50LCAnY2hvaWNlcy0nKTtcbiAgICAvKipcbiAgICAgKiBzZXR0aW5nIGRpcmVjdGlvbiBpbiBjYXNlcyB3aGVyZSBpdCdzIGV4cGxpY2l0bHkgc2V0IG9uIHBhc3NlZEVsZW1lbnRcbiAgICAgKiBvciB3aGVuIGNhbGN1bGF0ZWQgZGlyZWN0aW9uIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBkb2N1bWVudFxuICAgICAqL1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IHRoaXMucGFzc2VkRWxlbWVudC5kaXI7XG4gICAgaWYgKCF0aGlzLl9kaXJlY3Rpb24pIHtcbiAgICAgIHZhciBlbGVtZW50RGlyZWN0aW9uID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5wYXNzZWRFbGVtZW50LmVsZW1lbnQpLmRpcmVjdGlvbjtcbiAgICAgIHZhciBkb2N1bWVudERpcmVjdGlvbiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuZGlyZWN0aW9uO1xuICAgICAgaWYgKGVsZW1lbnREaXJlY3Rpb24gIT09IGRvY3VtZW50RGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGVsZW1lbnREaXJlY3Rpb247XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2lkTmFtZXMgPSB7XG4gICAgICBpdGVtQ2hvaWNlOiAnaXRlbS1jaG9pY2UnXG4gICAgfTtcbiAgICBpZiAodGhpcy5faXNTZWxlY3RFbGVtZW50KSB7XG4gICAgICAvLyBBc3NpZ24gcHJlc2V0IGdyb3VwcyBmcm9tIHBhc3NlZCBlbGVtZW50XG4gICAgICB0aGlzLl9wcmVzZXRHcm91cHMgPSB0aGlzLnBhc3NlZEVsZW1lbnQub3B0aW9uR3JvdXBzO1xuICAgICAgLy8gQXNzaWduIHByZXNldCBvcHRpb25zIGZyb20gcGFzc2VkIGVsZW1lbnRcbiAgICAgIHRoaXMuX3ByZXNldE9wdGlvbnMgPSB0aGlzLnBhc3NlZEVsZW1lbnQub3B0aW9ucztcbiAgICB9XG4gICAgLy8gQXNzaWduIHByZXNldCBjaG9pY2VzIGZyb20gcGFzc2VkIG9iamVjdFxuICAgIHRoaXMuX3ByZXNldENob2ljZXMgPSB0aGlzLmNvbmZpZy5jaG9pY2VzO1xuICAgIC8vIEFzc2lnbiBwcmVzZXQgaXRlbXMgZnJvbSBwYXNzZWQgb2JqZWN0IGZpcnN0XG4gICAgdGhpcy5fcHJlc2V0SXRlbXMgPSB0aGlzLmNvbmZpZy5pdGVtcztcbiAgICAvLyBBZGQgYW55IHZhbHVlcyBwYXNzZWQgZnJvbSBhdHRyaWJ1dGVcbiAgICBpZiAodGhpcy5wYXNzZWRFbGVtZW50LnZhbHVlICYmIHRoaXMuX2lzVGV4dEVsZW1lbnQpIHtcbiAgICAgIHZhciBzcGxpdFZhbHVlcyA9IHRoaXMucGFzc2VkRWxlbWVudC52YWx1ZS5zcGxpdCh0aGlzLmNvbmZpZy5kZWxpbWl0ZXIpO1xuICAgICAgdGhpcy5fcHJlc2V0SXRlbXMgPSB0aGlzLl9wcmVzZXRJdGVtcy5jb25jYXQoc3BsaXRWYWx1ZXMpO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYXJyYXkgb2YgY2hvaWNlcyBmcm9tIG9wdGlvbiBlbGVtZW50c1xuICAgIGlmICh0aGlzLnBhc3NlZEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgdGhpcy5wYXNzZWRFbGVtZW50Lm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgICAgIF90aGlzLl9wcmVzZXRDaG9pY2VzLnB1c2goe1xuICAgICAgICAgIHZhbHVlOiBvcHRpb24udmFsdWUsXG4gICAgICAgICAgbGFiZWw6IG9wdGlvbi5pbm5lckhUTUwsXG4gICAgICAgICAgc2VsZWN0ZWQ6ICEhb3B0aW9uLnNlbGVjdGVkLFxuICAgICAgICAgIGRpc2FibGVkOiBvcHRpb24uZGlzYWJsZWQgfHwgb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IG9wdGlvbi52YWx1ZSA9PT0gJycgfHwgb3B0aW9uLmhhc0F0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSxcbiAgICAgICAgICBjdXN0b21Qcm9wZXJ0aWVzOiAoMCwgdXRpbHNfMS5wYXJzZUN1c3RvbVByb3BlcnRpZXMpKG9wdGlvbi5kYXRhc2V0LmN1c3RvbVByb3BlcnRpZXMpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlciA9IHRoaXMuX3JlbmRlci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRm9jdXMgPSB0aGlzLl9vbkZvY3VzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25CbHVyID0gdGhpcy5fb25CbHVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25LZXlVcCA9IHRoaXMuX29uS2V5VXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbktleURvd24gPSB0aGlzLl9vbktleURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uVG91Y2hNb3ZlID0gdGhpcy5fb25Ub3VjaE1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblRvdWNoRW5kID0gdGhpcy5fb25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uTW91c2VEb3duID0gdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vdXNlT3ZlciA9IHRoaXMuX29uTW91c2VPdmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Gb3JtUmVzZXQgPSB0aGlzLl9vbkZvcm1SZXNldC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU2VsZWN0S2V5ID0gdGhpcy5fb25TZWxlY3RLZXkuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkVudGVyS2V5ID0gdGhpcy5fb25FbnRlcktleS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRXNjYXBlS2V5ID0gdGhpcy5fb25Fc2NhcGVLZXkuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkRpcmVjdGlvbktleSA9IHRoaXMuX29uRGlyZWN0aW9uS2V5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25EZWxldGVLZXkgPSB0aGlzLl9vbkRlbGV0ZUtleS5iaW5kKHRoaXMpO1xuICAgIC8vIElmIGVsZW1lbnQgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXNlZCB3aXRoIENob2ljZXMsIGZhaWwgc2lsZW50bHlcbiAgICBpZiAodGhpcy5wYXNzZWRFbGVtZW50LmlzQWN0aXZlKSB7XG4gICAgICBpZiAoIXRoaXMuY29uZmlnLnNpbGVudCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RyeWluZyB0byBpbml0aWFsaXNlIENob2ljZXMgb24gZWxlbWVudCBhbHJlYWR5IGluaXRpYWxpc2VkJywge1xuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmluaXRpYWxpc2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gTGV0J3MgZ29cbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hvaWNlcywgXCJkZWZhdWx0c1wiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHtcbiAgICAgICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgICAgcmV0dXJuIFVTRVJfREVGQVVMVFM7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCB0ZW1wbGF0ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIHRlbXBsYXRlc18xLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBDaG9pY2VzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmluaXRpYWxpc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NyZWF0ZVRlbXBsYXRlcygpO1xuICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG4gICAgdGhpcy5fY3JlYXRlU3RydWN0dXJlKCk7XG4gICAgdGhpcy5fc3RvcmUuc3Vic2NyaWJlKHRoaXMuX3JlbmRlcik7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB2YXIgc2hvdWxkRGlzYWJsZSA9ICF0aGlzLmNvbmZpZy5hZGRJdGVtcyB8fCB0aGlzLnBhc3NlZEVsZW1lbnQuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgaWYgKHNob3VsZERpc2FibGUpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxpc2VkID0gdHJ1ZTtcbiAgICB2YXIgY2FsbGJhY2tPbkluaXQgPSB0aGlzLmNvbmZpZy5jYWxsYmFja09uSW5pdDtcbiAgICAvLyBSdW4gY2FsbGJhY2sgaWYgaXQgaXMgYSBmdW5jdGlvblxuICAgIGlmIChjYWxsYmFja09uSW5pdCAmJiB0eXBlb2YgY2FsbGJhY2tPbkluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrT25Jbml0LmNhbGwodGhpcyk7XG4gICAgfVxuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMucGFzc2VkRWxlbWVudC5yZXZlYWwoKTtcbiAgICB0aGlzLmNvbnRhaW5lck91dGVyLnVud3JhcCh0aGlzLnBhc3NlZEVsZW1lbnQuZWxlbWVudCk7XG4gICAgdGhpcy5jbGVhclN0b3JlKCk7XG4gICAgaWYgKHRoaXMuX2lzU2VsZWN0RWxlbWVudCkge1xuICAgICAgdGhpcy5wYXNzZWRFbGVtZW50Lm9wdGlvbnMgPSB0aGlzLl9wcmVzZXRPcHRpb25zO1xuICAgIH1cbiAgICB0aGlzLl90ZW1wbGF0ZXMgPSB0ZW1wbGF0ZXNfMS5kZWZhdWx0O1xuICAgIHRoaXMuaW5pdGlhbGlzZWQgPSBmYWxzZTtcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBhc3NlZEVsZW1lbnQuaXNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5wYXNzZWRFbGVtZW50LmVuYWJsZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250YWluZXJPdXRlci5pc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgdGhpcy5pbnB1dC5lbmFibGUoKTtcbiAgICAgIHRoaXMuY29udGFpbmVyT3V0ZXIuZW5hYmxlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5wYXNzZWRFbGVtZW50LmlzRGlzYWJsZWQpIHtcbiAgICAgIHRoaXMucGFzc2VkRWxlbWVudC5kaXNhYmxlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250YWluZXJPdXRlci5pc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgICAgdGhpcy5pbnB1dC5kaXNhYmxlKCk7XG4gICAgICB0aGlzLmNvbnRhaW5lck91dGVyLmRpc2FibGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLmhpZ2hsaWdodEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSwgcnVuRXZlbnQpIHtcbiAgICBpZiAocnVuRXZlbnQgPT09IHZvaWQgMCkge1xuICAgICAgcnVuRXZlbnQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgaWQgPSBpdGVtLmlkLFxuICAgICAgX2EgPSBpdGVtLmdyb3VwSWQsXG4gICAgICBncm91cElkID0gX2EgPT09IHZvaWQgMCA/IC0xIDogX2EsXG4gICAgICBfYiA9IGl0ZW0udmFsdWUsXG4gICAgICB2YWx1ZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iLFxuICAgICAgX2MgPSBpdGVtLmxhYmVsLFxuICAgICAgbGFiZWwgPSBfYyA9PT0gdm9pZCAwID8gJycgOiBfYztcbiAgICB2YXIgZ3JvdXAgPSBncm91cElkID49IDAgPyB0aGlzLl9zdG9yZS5nZXRHcm91cEJ5SWQoZ3JvdXBJZCkgOiBudWxsO1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKCgwLCBpdGVtc18xLmhpZ2hsaWdodEl0ZW0pKGlkLCB0cnVlKSk7XG4gICAgaWYgKHJ1bkV2ZW50KSB7XG4gICAgICB0aGlzLnBhc3NlZEVsZW1lbnQudHJpZ2dlckV2ZW50KGNvbnN0YW50c18xLkVWRU5UUy5oaWdobGlnaHRJdGVtLCB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgIGdyb3VwVmFsdWU6IGdyb3VwICYmIGdyb3VwLnZhbHVlID8gZ3JvdXAudmFsdWUgOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLnVuaGlnaGxpZ2h0SXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGlkID0gaXRlbS5pZCxcbiAgICAgIF9hID0gaXRlbS5ncm91cElkLFxuICAgICAgZ3JvdXBJZCA9IF9hID09PSB2b2lkIDAgPyAtMSA6IF9hLFxuICAgICAgX2IgPSBpdGVtLnZhbHVlLFxuICAgICAgdmFsdWUgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYixcbiAgICAgIF9jID0gaXRlbS5sYWJlbCxcbiAgICAgIGxhYmVsID0gX2MgPT09IHZvaWQgMCA/ICcnIDogX2M7XG4gICAgdmFyIGdyb3VwID0gZ3JvdXBJZCA+PSAwID8gdGhpcy5fc3RvcmUuZ2V0R3JvdXBCeUlkKGdyb3VwSWQpIDogbnVsbDtcbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaCgoMCwgaXRlbXNfMS5oaWdobGlnaHRJdGVtKShpZCwgZmFsc2UpKTtcbiAgICB0aGlzLnBhc3NlZEVsZW1lbnQudHJpZ2dlckV2ZW50KGNvbnN0YW50c18xLkVWRU5UUy5oaWdobGlnaHRJdGVtLCB7XG4gICAgICBpZDogaWQsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBsYWJlbDogbGFiZWwsXG4gICAgICBncm91cFZhbHVlOiBncm91cCAmJiBncm91cC52YWx1ZSA/IGdyb3VwLnZhbHVlIDogbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5oaWdobGlnaHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9zdG9yZS5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gX3RoaXMuaGlnaGxpZ2h0SXRlbShpdGVtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUudW5oaWdobGlnaHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB0aGlzLl9zdG9yZS5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gX3RoaXMudW5oaWdobGlnaHRJdGVtKGl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5yZW1vdmVBY3RpdmVJdGVtc0J5VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuX3N0b3JlLmFjdGl2ZUl0ZW1zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0udmFsdWUgPT09IHZhbHVlO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBfdGhpcy5fcmVtb3ZlSXRlbShpdGVtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUucmVtb3ZlQWN0aXZlSXRlbXMgPSBmdW5jdGlvbiAoZXhjbHVkZWRJZCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fc3RvcmUuYWN0aXZlSXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgICAgdmFyIGlkID0gX2EuaWQ7XG4gICAgICByZXR1cm4gaWQgIT09IGV4Y2x1ZGVkSWQ7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIF90aGlzLl9yZW1vdmVJdGVtKGl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5yZW1vdmVIaWdobGlnaHRlZEl0ZW1zID0gZnVuY3Rpb24gKHJ1bkV2ZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAocnVuRXZlbnQgPT09IHZvaWQgMCkge1xuICAgICAgcnVuRXZlbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fc3RvcmUuaGlnaGxpZ2h0ZWRBY3RpdmVJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBfdGhpcy5fcmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgIC8vIElmIHRoaXMgYWN0aW9uIHdhcyBwZXJmb3JtZWQgYnkgdGhlIHVzZXJcbiAgICAgIC8vIHRyaWdnZXIgdGhlIGV2ZW50XG4gICAgICBpZiAocnVuRXZlbnQpIHtcbiAgICAgICAgX3RoaXMuX3RyaWdnZXJDaGFuZ2UoaXRlbS52YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLnNob3dEcm9wZG93biA9IGZ1bmN0aW9uIChwcmV2ZW50SW5wdXRGb2N1cykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuZHJvcGRvd24uaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuZHJvcGRvd24uc2hvdygpO1xuICAgICAgX3RoaXMuY29udGFpbmVyT3V0ZXIub3BlbihfdGhpcy5kcm9wZG93bi5kaXN0YW5jZUZyb21Ub3BXaW5kb3cpO1xuICAgICAgaWYgKCFwcmV2ZW50SW5wdXRGb2N1cyAmJiBfdGhpcy5fY2FuU2VhcmNoKSB7XG4gICAgICAgIF90aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICB9XG4gICAgICBfdGhpcy5wYXNzZWRFbGVtZW50LnRyaWdnZXJFdmVudChjb25zdGFudHNfMS5FVkVOVFMuc2hvd0Ryb3Bkb3duLCB7fSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLmhpZGVEcm9wZG93biA9IGZ1bmN0aW9uIChwcmV2ZW50SW5wdXRCbHVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoIXRoaXMuZHJvcGRvd24uaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgICAgX3RoaXMuY29udGFpbmVyT3V0ZXIuY2xvc2UoKTtcbiAgICAgIGlmICghcHJldmVudElucHV0Qmx1ciAmJiBfdGhpcy5fY2FuU2VhcmNoKSB7XG4gICAgICAgIF90aGlzLmlucHV0LnJlbW92ZUFjdGl2ZURlc2NlbmRhbnQoKTtcbiAgICAgICAgX3RoaXMuaW5wdXQuYmx1cigpO1xuICAgICAgfVxuICAgICAgX3RoaXMucGFzc2VkRWxlbWVudC50cmlnZ2VyRXZlbnQoY29uc3RhbnRzXzEuRVZFTlRTLmhpZGVEcm9wZG93biwge30pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZU9ubHkpIHtcbiAgICBpZiAodmFsdWVPbmx5ID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlT25seSA9IGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdmFsdWVzID0gdGhpcy5fc3RvcmUuYWN0aXZlSXRlbXMucmVkdWNlKGZ1bmN0aW9uIChzZWxlY3RlZEl0ZW1zLCBpdGVtKSB7XG4gICAgICB2YXIgaXRlbVZhbHVlID0gdmFsdWVPbmx5ID8gaXRlbS52YWx1ZSA6IGl0ZW07XG4gICAgICBzZWxlY3RlZEl0ZW1zLnB1c2goaXRlbVZhbHVlKTtcbiAgICAgIHJldHVybiBzZWxlY3RlZEl0ZW1zO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdGhpcy5faXNTZWxlY3RPbmVFbGVtZW50ID8gdmFsdWVzWzBdIDogdmFsdWVzO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpc2VkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fc2V0Q2hvaWNlT3JJdGVtKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuc2V0Q2hvaWNlQnlWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpc2VkIHx8IHRoaXMuX2lzVGV4dEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBJZiBvbmx5IG9uZSB2YWx1ZSBoYXMgYmVlbiBwYXNzZWQsIGNvbnZlcnQgdG8gYXJyYXlcbiAgICB2YXIgY2hvaWNlVmFsdWUgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICAvLyBMb29wIHRocm91Z2ggZWFjaCB2YWx1ZSBhbmRcbiAgICBjaG9pY2VWYWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fZmluZEFuZFNlbGVjdENob2ljZUJ5VmFsdWUodmFsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIFNldCBjaG9pY2VzIG9mIHNlbGVjdCBpbnB1dCB2aWEgYW4gYXJyYXkgb2Ygb2JqZWN0cyAob3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFycmF5IG9mIG9iamVjdCBvciBwcm9taXNlIG9mIGl0KSxcbiAgICogYSB2YWx1ZSBmaWVsZCBuYW1lIGFuZCBhIGxhYmVsIGZpZWxkIG5hbWUuXG4gICAqIFRoaXMgYmVoYXZlcyB0aGUgc2FtZSBhcyBwYXNzaW5nIGl0ZW1zIHZpYSB0aGUgY2hvaWNlcyBvcHRpb24gYnV0IGNhbiBiZSBjYWxsZWQgYWZ0ZXIgaW5pdGlhbGlzaW5nIENob2ljZXMuXG4gICAqIFRoaXMgY2FuIGFsc28gYmUgdXNlZCB0byBhZGQgZ3JvdXBzIG9mIGNob2ljZXMgKHNlZSBleGFtcGxlIDIpOyBPcHRpb25hbGx5IHBhc3MgYSB0cnVlIGByZXBsYWNlQ2hvaWNlc2AgdmFsdWUgdG8gcmVtb3ZlIGFueSBleGlzdGluZyBjaG9pY2VzLlxuICAgKiBPcHRpb25hbGx5IHBhc3MgYSBgY3VzdG9tUHJvcGVydGllc2Agb2JqZWN0IHRvIGFkZCBhZGRpdGlvbmFsIGRhdGEgdG8geW91ciBjaG9pY2VzICh1c2VmdWwgd2hlbiBzZWFyY2hpbmcvZmlsdGVyaW5nIGV0YykuXG4gICAqXG4gICAqICoqSW5wdXQgdHlwZXMgYWZmZWN0ZWQ6Kiogc2VsZWN0LW9uZSwgc2VsZWN0LW11bHRpcGxlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGV4YW1wbGUgPSBuZXcgQ2hvaWNlcyhlbGVtZW50KTtcbiAgICpcbiAgICogZXhhbXBsZS5zZXRDaG9pY2VzKFtcbiAgICogICB7dmFsdWU6ICdPbmUnLCBsYWJlbDogJ0xhYmVsIE9uZScsIGRpc2FibGVkOiB0cnVlfSxcbiAgICogICB7dmFsdWU6ICdUd28nLCBsYWJlbDogJ0xhYmVsIFR3bycsIHNlbGVjdGVkOiB0cnVlfSxcbiAgICogICB7dmFsdWU6ICdUaHJlZScsIGxhYmVsOiAnTGFiZWwgVGhyZWUnfSxcbiAgICogXSwgJ3ZhbHVlJywgJ2xhYmVsJywgZmFsc2UpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogY29uc3QgZXhhbXBsZSA9IG5ldyBDaG9pY2VzKGVsZW1lbnQpO1xuICAgKlxuICAgKiBleGFtcGxlLnNldENob2ljZXMoYXN5bmMgKCkgPT4ge1xuICAgKiAgIHRyeSB7XG4gICAqICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCBmZXRjaCgnL2l0ZW1zJyk7XG4gICAqICAgICAgcmV0dXJuIGl0ZW1zLmpzb24oKVxuICAgKiAgIH0gY2F0Y2goZXJyKSB7XG4gICAqICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IGV4YW1wbGUgPSBuZXcgQ2hvaWNlcyhlbGVtZW50KTtcbiAgICpcbiAgICogZXhhbXBsZS5zZXRDaG9pY2VzKFt7XG4gICAqICAgbGFiZWw6ICdHcm91cCBvbmUnLFxuICAgKiAgIGlkOiAxLFxuICAgKiAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICogICBjaG9pY2VzOiBbXG4gICAqICAgICB7dmFsdWU6ICdDaGlsZCBPbmUnLCBsYWJlbDogJ0NoaWxkIE9uZScsIHNlbGVjdGVkOiB0cnVlfSxcbiAgICogICAgIHt2YWx1ZTogJ0NoaWxkIFR3bycsIGxhYmVsOiAnQ2hpbGQgVHdvJywgIGRpc2FibGVkOiB0cnVlfSxcbiAgICogICAgIHt2YWx1ZTogJ0NoaWxkIFRocmVlJywgbGFiZWw6ICdDaGlsZCBUaHJlZSd9LFxuICAgKiAgIF1cbiAgICogfSxcbiAgICoge1xuICAgKiAgIGxhYmVsOiAnR3JvdXAgdHdvJyxcbiAgICogICBpZDogMixcbiAgICogICBkaXNhYmxlZDogZmFsc2UsXG4gICAqICAgY2hvaWNlczogW1xuICAgKiAgICAge3ZhbHVlOiAnQ2hpbGQgRm91cicsIGxhYmVsOiAnQ2hpbGQgRm91cicsIGRpc2FibGVkOiB0cnVlfSxcbiAgICogICAgIHt2YWx1ZTogJ0NoaWxkIEZpdmUnLCBsYWJlbDogJ0NoaWxkIEZpdmUnfSxcbiAgICogICAgIHt2YWx1ZTogJ0NoaWxkIFNpeCcsIGxhYmVsOiAnQ2hpbGQgU2l4JywgY3VzdG9tUHJvcGVydGllczoge1xuICAgKiAgICAgICBkZXNjcmlwdGlvbjogJ0N1c3RvbSBkZXNjcmlwdGlvbiBhYm91dCBjaGlsZCBzaXgnLFxuICAgKiAgICAgICByYW5kb206ICdBbm90aGVyIHJhbmRvbSBjdXN0b20gcHJvcGVydHknXG4gICAqICAgICB9fSxcbiAgICogICBdXG4gICAqIH1dLCAndmFsdWUnLCAnbGFiZWwnLCBmYWxzZSk7XG4gICAqIGBgYFxuICAgKi9cbiAgQ2hvaWNlcy5wcm90b3R5cGUuc2V0Q2hvaWNlcyA9IGZ1bmN0aW9uIChjaG9pY2VzQXJyYXlPckZldGNoZXIsIHZhbHVlLCBsYWJlbCwgcmVwbGFjZUNob2ljZXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChjaG9pY2VzQXJyYXlPckZldGNoZXIgPT09IHZvaWQgMCkge1xuICAgICAgY2hvaWNlc0FycmF5T3JGZXRjaGVyID0gW107XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9ICd2YWx1ZSc7XG4gICAgfVxuICAgIGlmIChsYWJlbCA9PT0gdm9pZCAwKSB7XG4gICAgICBsYWJlbCA9ICdsYWJlbCc7XG4gICAgfVxuICAgIGlmIChyZXBsYWNlQ2hvaWNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXBsYWNlQ2hvaWNlcyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaW5pdGlhbGlzZWQpIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInNldENob2ljZXMgd2FzIGNhbGxlZCBvbiBhIG5vbi1pbml0aWFsaXplZCBpbnN0YW5jZSBvZiBDaG9pY2VzXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2lzU2VsZWN0RWxlbWVudCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNldENob2ljZXMgY2FuJ3QgYmUgdXNlZCB3aXRoIElOUFVUIGJhc2VkIENob2ljZXNcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICF2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbHVlIHBhcmFtZXRlciBtdXN0IGJlIGEgbmFtZSBvZiAndmFsdWUnIGZpZWxkIGluIHBhc3NlZCBvYmplY3RzXCIpO1xuICAgIH1cbiAgICAvLyBDbGVhciBjaG9pY2VzIGlmIG5lZWRlZFxuICAgIGlmIChyZXBsYWNlQ2hvaWNlcykge1xuICAgICAgdGhpcy5jbGVhckNob2ljZXMoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaG9pY2VzQXJyYXlPckZldGNoZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGl0J3MgYSBjaG9pY2VzIGZldGNoZXIgZnVuY3Rpb25cbiAgICAgIHZhciBmZXRjaGVyXzEgPSBjaG9pY2VzQXJyYXlPckZldGNoZXIodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgJiYgZmV0Y2hlcl8xIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAvLyB0aGF0J3MgYSBwcm9taXNlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9taXNlLWV4ZWN1dG9yLXJldHVyblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2hhbmRsZUxvYWRpbmdTdGF0ZSh0cnVlKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGZldGNoZXJfMTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5zZXRDaG9pY2VzKGRhdGEsIHZhbHVlLCBsYWJlbCwgcmVwbGFjZUNob2ljZXMpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKCFfdGhpcy5jb25maWcuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2hhbmRsZUxvYWRpbmdTdGF0ZShmYWxzZSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBmdW5jdGlvbiByZXR1cm5lZCBzb21ldGhpbmcgZWxzZSB0aGFuIHByb21pc2UsIGxldCdzIGNoZWNrIGlmIGl0J3MgYW4gYXJyYXkgb2YgY2hvaWNlc1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZldGNoZXJfMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIi5zZXRDaG9pY2VzIGZpcnN0IGFyZ3VtZW50IGZ1bmN0aW9uIG11c3QgcmV0dXJuIGVpdGhlciBhcnJheSBvZiBjaG9pY2VzIG9yIFByb21pc2UsIGdvdDogXCIuY29uY2F0KHR5cGVvZiBmZXRjaGVyXzEpKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2lvbiB3aXRoIHJlc3VsdHMsIGl0J3Mgc3luYyBhbmQgY2hvaWNlcyB3ZXJlIGNsZWFyZWQgYWxyZWFkeVxuICAgICAgcmV0dXJuIHRoaXMuc2V0Q2hvaWNlcyhmZXRjaGVyXzEsIHZhbHVlLCBsYWJlbCwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2hvaWNlc0FycmF5T3JGZXRjaGVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIi5zZXRDaG9pY2VzIG11c3QgYmUgY2FsbGVkIGVpdGhlciB3aXRoIGFycmF5IG9mIGNob2ljZXMgd2l0aCBhIGZ1bmN0aW9uIHJlc3VsdGluZyBpbnRvIFByb21pc2Ugb2YgYXJyYXkgb2YgY2hvaWNlc1wiKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXJPdXRlci5yZW1vdmVMb2FkaW5nU3RhdGUoKTtcbiAgICB0aGlzLl9zdGFydExvYWRpbmcoKTtcbiAgICBjaG9pY2VzQXJyYXlPckZldGNoZXIuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXBPckNob2ljZSkge1xuICAgICAgaWYgKGdyb3VwT3JDaG9pY2UuY2hvaWNlcykge1xuICAgICAgICBfdGhpcy5fYWRkR3JvdXAoe1xuICAgICAgICAgIGlkOiBncm91cE9yQ2hvaWNlLmlkID8gcGFyc2VJbnQoXCJcIi5jb25jYXQoZ3JvdXBPckNob2ljZS5pZCksIDEwKSA6IG51bGwsXG4gICAgICAgICAgZ3JvdXA6IGdyb3VwT3JDaG9pY2UsXG4gICAgICAgICAgdmFsdWVLZXk6IHZhbHVlLFxuICAgICAgICAgIGxhYmVsS2V5OiBsYWJlbFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaG9pY2UgPSBncm91cE9yQ2hvaWNlO1xuICAgICAgICBfdGhpcy5fYWRkQ2hvaWNlKHtcbiAgICAgICAgICB2YWx1ZTogY2hvaWNlW3ZhbHVlXSxcbiAgICAgICAgICBsYWJlbDogY2hvaWNlW2xhYmVsXSxcbiAgICAgICAgICBpc1NlbGVjdGVkOiAhIWNob2ljZS5zZWxlY3RlZCxcbiAgICAgICAgICBpc0Rpc2FibGVkOiAhIWNob2ljZS5kaXNhYmxlZCxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogISFjaG9pY2UucGxhY2Vob2xkZXIsXG4gICAgICAgICAgY3VzdG9tUHJvcGVydGllczogY2hvaWNlLmN1c3RvbVByb3BlcnRpZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fc3RvcExvYWRpbmcoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuY2xlYXJDaG9pY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKCgwLCBjaG9pY2VzXzEuY2xlYXJDaG9pY2VzKSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuY2xlYXJTdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaCgoMCwgbWlzY18xLmNsZWFyQWxsKSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuY2xlYXJJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2hvdWxkU2V0SW5wdXRXaWR0aCA9ICF0aGlzLl9pc1NlbGVjdE9uZUVsZW1lbnQ7XG4gICAgdGhpcy5pbnB1dC5jbGVhcihzaG91bGRTZXRJbnB1dFdpZHRoKTtcbiAgICBpZiAoIXRoaXMuX2lzVGV4dEVsZW1lbnQgJiYgdGhpcy5fY2FuU2VhcmNoKSB7XG4gICAgICB0aGlzLl9pc1NlYXJjaGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fc3RvcmUuZGlzcGF0Y2goKDAsIGNob2ljZXNfMS5hY3RpdmF0ZUNob2ljZXMpKHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlLmlzTG9hZGluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHRoaXMuX3N0b3JlLnN0YXRlO1xuICAgIHZhciBzdGF0ZUNoYW5nZWQgPSB0aGlzLl9jdXJyZW50U3RhdGUuY2hvaWNlcyAhPT0gdGhpcy5fcHJldlN0YXRlLmNob2ljZXMgfHwgdGhpcy5fY3VycmVudFN0YXRlLmdyb3VwcyAhPT0gdGhpcy5fcHJldlN0YXRlLmdyb3VwcyB8fCB0aGlzLl9jdXJyZW50U3RhdGUuaXRlbXMgIT09IHRoaXMuX3ByZXZTdGF0ZS5pdGVtcztcbiAgICB2YXIgc2hvdWxkUmVuZGVyQ2hvaWNlcyA9IHRoaXMuX2lzU2VsZWN0RWxlbWVudDtcbiAgICB2YXIgc2hvdWxkUmVuZGVySXRlbXMgPSB0aGlzLl9jdXJyZW50U3RhdGUuaXRlbXMgIT09IHRoaXMuX3ByZXZTdGF0ZS5pdGVtcztcbiAgICBpZiAoIXN0YXRlQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkUmVuZGVyQ2hvaWNlcykge1xuICAgICAgdGhpcy5fcmVuZGVyQ2hvaWNlcygpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkUmVuZGVySXRlbXMpIHtcbiAgICAgIHRoaXMuX3JlbmRlckl0ZW1zKCk7XG4gICAgfVxuICAgIHRoaXMuX3ByZXZTdGF0ZSA9IHRoaXMuX2N1cnJlbnRTdGF0ZTtcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX3JlbmRlckNob2ljZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX2EgPSB0aGlzLl9zdG9yZSxcbiAgICAgIGFjdGl2ZUdyb3VwcyA9IF9hLmFjdGl2ZUdyb3VwcyxcbiAgICAgIGFjdGl2ZUNob2ljZXMgPSBfYS5hY3RpdmVDaG9pY2VzO1xuICAgIHZhciBjaG9pY2VMaXN0RnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdGhpcy5jaG9pY2VMaXN0LmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuY29uZmlnLnJlc2V0U2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5jaG9pY2VMaXN0LnNjcm9sbFRvVG9wKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gSWYgd2UgaGF2ZSBncm91cGVkIG9wdGlvbnNcbiAgICBpZiAoYWN0aXZlR3JvdXBzLmxlbmd0aCA+PSAxICYmICF0aGlzLl9pc1NlYXJjaGluZykge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBsYWNlaG9sZGVyIGNob2ljZSBhbG9uZyB3aXRoIGdyb3Vwc1xuICAgICAgdmFyIGFjdGl2ZVBsYWNlaG9sZGVycyA9IGFjdGl2ZUNob2ljZXMuZmlsdGVyKGZ1bmN0aW9uIChhY3RpdmVDaG9pY2UpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZUNob2ljZS5wbGFjZWhvbGRlciA9PT0gdHJ1ZSAmJiBhY3RpdmVDaG9pY2UuZ3JvdXBJZCA9PT0gLTE7XG4gICAgICB9KTtcbiAgICAgIGlmIChhY3RpdmVQbGFjZWhvbGRlcnMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgY2hvaWNlTGlzdEZyYWdtZW50ID0gdGhpcy5fY3JlYXRlQ2hvaWNlc0ZyYWdtZW50KGFjdGl2ZVBsYWNlaG9sZGVycywgY2hvaWNlTGlzdEZyYWdtZW50KTtcbiAgICAgIH1cbiAgICAgIGNob2ljZUxpc3RGcmFnbWVudCA9IHRoaXMuX2NyZWF0ZUdyb3Vwc0ZyYWdtZW50KGFjdGl2ZUdyb3VwcywgYWN0aXZlQ2hvaWNlcywgY2hvaWNlTGlzdEZyYWdtZW50KTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2ZUNob2ljZXMubGVuZ3RoID49IDEpIHtcbiAgICAgIGNob2ljZUxpc3RGcmFnbWVudCA9IHRoaXMuX2NyZWF0ZUNob2ljZXNGcmFnbWVudChhY3RpdmVDaG9pY2VzLCBjaG9pY2VMaXN0RnJhZ21lbnQpO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBoYXZlIGNob2ljZXMgdG8gc2hvd1xuICAgIGlmIChjaG9pY2VMaXN0RnJhZ21lbnQuY2hpbGROb2RlcyAmJiBjaG9pY2VMaXN0RnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgYWN0aXZlSXRlbXMgPSB0aGlzLl9zdG9yZS5hY3RpdmVJdGVtcztcbiAgICAgIHZhciBjYW5BZGRJdGVtID0gdGhpcy5fY2FuQWRkSXRlbShhY3RpdmVJdGVtcywgdGhpcy5pbnB1dC52YWx1ZSk7XG4gICAgICAvLyAuLi5hbmQgd2UgY2FuIHNlbGVjdCB0aGVtXG4gICAgICBpZiAoY2FuQWRkSXRlbS5yZXNwb25zZSkge1xuICAgICAgICAvLyAuLi5hcHBlbmQgdGhlbSBhbmQgaGlnaGxpZ2h0IHRoZSBmaXJzdCBjaG9pY2VcbiAgICAgICAgdGhpcy5jaG9pY2VMaXN0LmFwcGVuZChjaG9pY2VMaXN0RnJhZ21lbnQpO1xuICAgICAgICB0aGlzLl9oaWdobGlnaHRDaG9pY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBub3RpY2UgPSB0aGlzLl9nZXRUZW1wbGF0ZSgnbm90aWNlJywgY2FuQWRkSXRlbS5ub3RpY2UpO1xuICAgICAgICB0aGlzLmNob2ljZUxpc3QuYXBwZW5kKG5vdGljZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBzaG93IGEgbm90aWNlXG4gICAgICB2YXIgZHJvcGRvd25JdGVtID0gdm9pZCAwO1xuICAgICAgdmFyIG5vdGljZSA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLl9pc1NlYXJjaGluZykge1xuICAgICAgICBub3RpY2UgPSB0eXBlb2YgdGhpcy5jb25maWcubm9SZXN1bHRzVGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuY29uZmlnLm5vUmVzdWx0c1RleHQoKSA6IHRoaXMuY29uZmlnLm5vUmVzdWx0c1RleHQ7XG4gICAgICAgIGRyb3Bkb3duSXRlbSA9IHRoaXMuX2dldFRlbXBsYXRlKCdub3RpY2UnLCBub3RpY2UsICduby1yZXN1bHRzJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3RpY2UgPSB0eXBlb2YgdGhpcy5jb25maWcubm9DaG9pY2VzVGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuY29uZmlnLm5vQ2hvaWNlc1RleHQoKSA6IHRoaXMuY29uZmlnLm5vQ2hvaWNlc1RleHQ7XG4gICAgICAgIGRyb3Bkb3duSXRlbSA9IHRoaXMuX2dldFRlbXBsYXRlKCdub3RpY2UnLCBub3RpY2UsICduby1jaG9pY2VzJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNob2ljZUxpc3QuYXBwZW5kKGRyb3Bkb3duSXRlbSk7XG4gICAgfVxuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5fcmVuZGVySXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjdGl2ZUl0ZW1zID0gdGhpcy5fc3RvcmUuYWN0aXZlSXRlbXMgfHwgW107XG4gICAgdGhpcy5pdGVtTGlzdC5jbGVhcigpO1xuICAgIC8vIENyZWF0ZSBhIGZyYWdtZW50IHRvIHN0b3JlIG91ciBsaXN0IGl0ZW1zXG4gICAgLy8gKHNvIHdlIGRvbid0IGhhdmUgdG8gdXBkYXRlIHRoZSBET00gZm9yIGVhY2ggaXRlbSlcbiAgICB2YXIgaXRlbUxpc3RGcmFnbWVudCA9IHRoaXMuX2NyZWF0ZUl0ZW1zRnJhZ21lbnQoYWN0aXZlSXRlbXMpO1xuICAgIC8vIElmIHdlIGhhdmUgaXRlbXMgdG8gYWRkLCBhcHBlbmQgdGhlbVxuICAgIGlmIChpdGVtTGlzdEZyYWdtZW50LmNoaWxkTm9kZXMpIHtcbiAgICAgIHRoaXMuaXRlbUxpc3QuYXBwZW5kKGl0ZW1MaXN0RnJhZ21lbnQpO1xuICAgIH1cbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX2NyZWF0ZUdyb3Vwc0ZyYWdtZW50ID0gZnVuY3Rpb24gKGdyb3VwcywgY2hvaWNlcywgZnJhZ21lbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChmcmFnbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgICBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB9XG4gICAgdmFyIGdldEdyb3VwQ2hvaWNlcyA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgcmV0dXJuIGNob2ljZXMuZmlsdGVyKGZ1bmN0aW9uIChjaG9pY2UpIHtcbiAgICAgICAgaWYgKF90aGlzLl9pc1NlbGVjdE9uZUVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gY2hvaWNlLmdyb3VwSWQgPT09IGdyb3VwLmlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaG9pY2UuZ3JvdXBJZCA9PT0gZ3JvdXAuaWQgJiYgKF90aGlzLmNvbmZpZy5yZW5kZXJTZWxlY3RlZENob2ljZXMgPT09ICdhbHdheXMnIHx8ICFjaG9pY2Uuc2VsZWN0ZWQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBJZiBzb3J0aW5nIGlzIGVuYWJsZWQsIGZpbHRlciBncm91cHNcbiAgICBpZiAodGhpcy5jb25maWcuc2hvdWxkU29ydCkge1xuICAgICAgZ3JvdXBzLnNvcnQodGhpcy5jb25maWcuc29ydGVyKTtcbiAgICB9XG4gICAgZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICB2YXIgZ3JvdXBDaG9pY2VzID0gZ2V0R3JvdXBDaG9pY2VzKGdyb3VwKTtcbiAgICAgIGlmIChncm91cENob2ljZXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgdmFyIGRyb3Bkb3duR3JvdXAgPSBfdGhpcy5fZ2V0VGVtcGxhdGUoJ2Nob2ljZUdyb3VwJywgZ3JvdXApO1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkcm9wZG93bkdyb3VwKTtcbiAgICAgICAgX3RoaXMuX2NyZWF0ZUNob2ljZXNGcmFnbWVudChncm91cENob2ljZXMsIGZyYWdtZW50LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9jcmVhdGVDaG9pY2VzRnJhZ21lbnQgPSBmdW5jdGlvbiAoY2hvaWNlcywgZnJhZ21lbnQsIHdpdGhpbkdyb3VwKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoZnJhZ21lbnQgPT09IHZvaWQgMCkge1xuICAgICAgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgfVxuICAgIGlmICh3aXRoaW5Hcm91cCA9PT0gdm9pZCAwKSB7XG4gICAgICB3aXRoaW5Hcm91cCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBmcmFnbWVudCB0byBzdG9yZSBvdXIgbGlzdCBpdGVtcyAoc28gd2UgZG9uJ3QgaGF2ZSB0byB1cGRhdGUgdGhlIERPTSBmb3IgZWFjaCBpdGVtKVxuICAgIHZhciBfYSA9IHRoaXMuY29uZmlnLFxuICAgICAgcmVuZGVyU2VsZWN0ZWRDaG9pY2VzID0gX2EucmVuZGVyU2VsZWN0ZWRDaG9pY2VzLFxuICAgICAgc2VhcmNoUmVzdWx0TGltaXQgPSBfYS5zZWFyY2hSZXN1bHRMaW1pdCxcbiAgICAgIHJlbmRlckNob2ljZUxpbWl0ID0gX2EucmVuZGVyQ2hvaWNlTGltaXQ7XG4gICAgdmFyIGZpbHRlciA9IHRoaXMuX2lzU2VhcmNoaW5nID8gdXRpbHNfMS5zb3J0QnlTY29yZSA6IHRoaXMuY29uZmlnLnNvcnRlcjtcbiAgICB2YXIgYXBwZW5kQ2hvaWNlID0gZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgdmFyIHNob3VsZFJlbmRlciA9IHJlbmRlclNlbGVjdGVkQ2hvaWNlcyA9PT0gJ2F1dG8nID8gX3RoaXMuX2lzU2VsZWN0T25lRWxlbWVudCB8fCAhY2hvaWNlLnNlbGVjdGVkIDogdHJ1ZTtcbiAgICAgIGlmIChzaG91bGRSZW5kZXIpIHtcbiAgICAgICAgdmFyIGRyb3Bkb3duSXRlbSA9IF90aGlzLl9nZXRUZW1wbGF0ZSgnY2hvaWNlJywgY2hvaWNlLCBfdGhpcy5jb25maWcuaXRlbVNlbGVjdFRleHQpO1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkcm9wZG93bkl0ZW0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlbmRlcmVyYWJsZUNob2ljZXMgPSBjaG9pY2VzO1xuICAgIGlmIChyZW5kZXJTZWxlY3RlZENob2ljZXMgPT09ICdhdXRvJyAmJiAhdGhpcy5faXNTZWxlY3RPbmVFbGVtZW50KSB7XG4gICAgICByZW5kZXJlcmFibGVDaG9pY2VzID0gY2hvaWNlcy5maWx0ZXIoZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgICByZXR1cm4gIWNob2ljZS5zZWxlY3RlZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTcGxpdCBhcnJheSBpbnRvIHBsYWNlaG9sZGVycyBhbmQgXCJub3JtYWxcIiBjaG9pY2VzXG4gICAgdmFyIF9iID0gcmVuZGVyZXJhYmxlQ2hvaWNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY2hvaWNlKSB7XG4gICAgICAgIGlmIChjaG9pY2UucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICBhY2MucGxhY2Vob2xkZXJDaG9pY2VzLnB1c2goY2hvaWNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2Mubm9ybWFsQ2hvaWNlcy5wdXNoKGNob2ljZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHtcbiAgICAgICAgcGxhY2Vob2xkZXJDaG9pY2VzOiBbXSxcbiAgICAgICAgbm9ybWFsQ2hvaWNlczogW11cbiAgICAgIH0pLFxuICAgICAgcGxhY2Vob2xkZXJDaG9pY2VzID0gX2IucGxhY2Vob2xkZXJDaG9pY2VzLFxuICAgICAgbm9ybWFsQ2hvaWNlcyA9IF9iLm5vcm1hbENob2ljZXM7XG4gICAgLy8gSWYgc29ydGluZyBpcyBlbmFibGVkIG9yIHRoZSB1c2VyIGlzIHNlYXJjaGluZywgZmlsdGVyIGNob2ljZXNcbiAgICBpZiAodGhpcy5jb25maWcuc2hvdWxkU29ydCB8fCB0aGlzLl9pc1NlYXJjaGluZykge1xuICAgICAgbm9ybWFsQ2hvaWNlcy5zb3J0KGZpbHRlcik7XG4gICAgfVxuICAgIHZhciBjaG9pY2VMaW1pdCA9IHJlbmRlcmVyYWJsZUNob2ljZXMubGVuZ3RoO1xuICAgIC8vIFByZXBlbmQgcGxhY2Vob2xlZGVyXG4gICAgdmFyIHNvcnRlZENob2ljZXMgPSB0aGlzLl9pc1NlbGVjdE9uZUVsZW1lbnQgPyBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHBsYWNlaG9sZGVyQ2hvaWNlcywgdHJ1ZSksIG5vcm1hbENob2ljZXMsIHRydWUpIDogbm9ybWFsQ2hvaWNlcztcbiAgICBpZiAodGhpcy5faXNTZWFyY2hpbmcpIHtcbiAgICAgIGNob2ljZUxpbWl0ID0gc2VhcmNoUmVzdWx0TGltaXQ7XG4gICAgfSBlbHNlIGlmIChyZW5kZXJDaG9pY2VMaW1pdCAmJiByZW5kZXJDaG9pY2VMaW1pdCA+IDAgJiYgIXdpdGhpbkdyb3VwKSB7XG4gICAgICBjaG9pY2VMaW1pdCA9IHJlbmRlckNob2ljZUxpbWl0O1xuICAgIH1cbiAgICAvLyBBZGQgZWFjaCBjaG9pY2UgdG8gZHJvcGRvd24gd2l0aGluIHJhbmdlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaG9pY2VMaW1pdDsgaSArPSAxKSB7XG4gICAgICBpZiAoc29ydGVkQ2hvaWNlc1tpXSkge1xuICAgICAgICBhcHBlbmRDaG9pY2Uoc29ydGVkQ2hvaWNlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX2NyZWF0ZUl0ZW1zRnJhZ21lbnQgPSBmdW5jdGlvbiAoaXRlbXMsIGZyYWdtZW50KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoZnJhZ21lbnQgPT09IHZvaWQgMCkge1xuICAgICAgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBmcmFnbWVudCB0byBhZGQgZWxlbWVudHMgdG9cbiAgICB2YXIgX2EgPSB0aGlzLmNvbmZpZyxcbiAgICAgIHNob3VsZFNvcnRJdGVtcyA9IF9hLnNob3VsZFNvcnRJdGVtcyxcbiAgICAgIHNvcnRlciA9IF9hLnNvcnRlcixcbiAgICAgIHJlbW92ZUl0ZW1CdXR0b24gPSBfYS5yZW1vdmVJdGVtQnV0dG9uO1xuICAgIC8vIElmIHNvcnRpbmcgaXMgZW5hYmxlZCwgZmlsdGVyIGl0ZW1zXG4gICAgaWYgKHNob3VsZFNvcnRJdGVtcyAmJiAhdGhpcy5faXNTZWxlY3RPbmVFbGVtZW50KSB7XG4gICAgICBpdGVtcy5zb3J0KHNvcnRlcik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc1RleHRFbGVtZW50KSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBoaWRkZW4gaW5wdXRcbiAgICAgIHRoaXMucGFzc2VkRWxlbWVudC52YWx1ZSA9IGl0ZW1zLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pLmpvaW4odGhpcy5jb25maWcuZGVsaW1pdGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlIHRoZSBvcHRpb25zIG9mIHRoZSBoaWRkZW4gaW5wdXRcbiAgICAgIHRoaXMucGFzc2VkRWxlbWVudC5vcHRpb25zID0gaXRlbXM7XG4gICAgfVxuICAgIHZhciBhZGRJdGVtVG9GcmFnbWVudCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAvLyBDcmVhdGUgbmV3IGxpc3QgZWxlbWVudFxuICAgICAgdmFyIGxpc3RJdGVtID0gX3RoaXMuX2dldFRlbXBsYXRlKCdpdGVtJywgaXRlbSwgcmVtb3ZlSXRlbUJ1dHRvbik7XG4gICAgICAvLyBBcHBlbmQgaXQgdG8gbGlzdFxuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobGlzdEl0ZW0pO1xuICAgIH07XG4gICAgLy8gQWRkIGVhY2ggbGlzdCBpdGVtIHRvIGxpc3RcbiAgICBpdGVtcy5mb3JFYWNoKGFkZEl0ZW1Ub0ZyYWdtZW50KTtcbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl90cmlnZ2VyQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXNzZWRFbGVtZW50LnRyaWdnZXJFdmVudChjb25zdGFudHNfMS5FVkVOVFMuY2hhbmdlLCB7XG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX3NlbGVjdFBsYWNlaG9sZGVyQ2hvaWNlID0gZnVuY3Rpb24gKHBsYWNlaG9sZGVyQ2hvaWNlKSB7XG4gICAgdGhpcy5fYWRkSXRlbSh7XG4gICAgICB2YWx1ZTogcGxhY2Vob2xkZXJDaG9pY2UudmFsdWUsXG4gICAgICBsYWJlbDogcGxhY2Vob2xkZXJDaG9pY2UubGFiZWwsXG4gICAgICBjaG9pY2VJZDogcGxhY2Vob2xkZXJDaG9pY2UuaWQsXG4gICAgICBncm91cElkOiBwbGFjZWhvbGRlckNob2ljZS5ncm91cElkLFxuICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyQ2hvaWNlLnBsYWNlaG9sZGVyXG4gICAgfSk7XG4gICAgdGhpcy5fdHJpZ2dlckNoYW5nZShwbGFjZWhvbGRlckNob2ljZS52YWx1ZSk7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9oYW5kbGVCdXR0b25BY3Rpb24gPSBmdW5jdGlvbiAoYWN0aXZlSXRlbXMsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWFjdGl2ZUl0ZW1zIHx8ICFlbGVtZW50IHx8ICF0aGlzLmNvbmZpZy5yZW1vdmVJdGVtcyB8fCAhdGhpcy5jb25maWcucmVtb3ZlSXRlbUJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXRlbUlkID0gZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5kYXRhc2V0LmlkO1xuICAgIHZhciBpdGVtVG9SZW1vdmUgPSBpdGVtSWQgJiYgYWN0aXZlSXRlbXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uaWQgPT09IHBhcnNlSW50KGl0ZW1JZCwgMTApO1xuICAgIH0pO1xuICAgIGlmICghaXRlbVRvUmVtb3ZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbW92ZSBpdGVtIGFzc29jaWF0ZWQgd2l0aCBidXR0b25cbiAgICB0aGlzLl9yZW1vdmVJdGVtKGl0ZW1Ub1JlbW92ZSk7XG4gICAgdGhpcy5fdHJpZ2dlckNoYW5nZShpdGVtVG9SZW1vdmUudmFsdWUpO1xuICAgIGlmICh0aGlzLl9pc1NlbGVjdE9uZUVsZW1lbnQgJiYgdGhpcy5fc3RvcmUucGxhY2Vob2xkZXJDaG9pY2UpIHtcbiAgICAgIHRoaXMuX3NlbGVjdFBsYWNlaG9sZGVyQ2hvaWNlKHRoaXMuX3N0b3JlLnBsYWNlaG9sZGVyQ2hvaWNlKTtcbiAgICB9XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9oYW5kbGVJdGVtQWN0aW9uID0gZnVuY3Rpb24gKGFjdGl2ZUl0ZW1zLCBlbGVtZW50LCBoYXNTaGlmdEtleSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKGhhc1NoaWZ0S2V5ID09PSB2b2lkIDApIHtcbiAgICAgIGhhc1NoaWZ0S2V5ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICghYWN0aXZlSXRlbXMgfHwgIWVsZW1lbnQgfHwgIXRoaXMuY29uZmlnLnJlbW92ZUl0ZW1zIHx8IHRoaXMuX2lzU2VsZWN0T25lRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGFzc2VkSWQgPSBlbGVtZW50LmRhdGFzZXQuaWQ7XG4gICAgLy8gV2Ugb25seSB3YW50IHRvIHNlbGVjdCBvbmUgaXRlbSB3aXRoIGEgY2xpY2tcbiAgICAvLyBzbyB3ZSBkZXNlbGVjdCBhbnkgaXRlbXMgdGhhdCBhcmVuJ3QgdGhlIHRhcmdldFxuICAgIC8vIHVubGVzcyBzaGlmdCBpcyBiZWluZyBwcmVzc2VkXG4gICAgYWN0aXZlSXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgaWYgKGl0ZW0uaWQgPT09IHBhcnNlSW50KFwiXCIuY29uY2F0KHBhc3NlZElkKSwgMTApICYmICFpdGVtLmhpZ2hsaWdodGVkKSB7XG4gICAgICAgIF90aGlzLmhpZ2hsaWdodEl0ZW0oaXRlbSk7XG4gICAgICB9IGVsc2UgaWYgKCFoYXNTaGlmdEtleSAmJiBpdGVtLmhpZ2hsaWdodGVkKSB7XG4gICAgICAgIF90aGlzLnVuaGlnaGxpZ2h0SXRlbShpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBGb2N1cyBpbnB1dCBhcyB3aXRob3V0IGZvY3VzLCBhIHVzZXIgY2Fubm90IGRvIGFueXRoaW5nIHdpdGggYVxuICAgIC8vIGhpZ2hsaWdodGVkIGl0ZW1cbiAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9oYW5kbGVDaG9pY2VBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aXZlSXRlbXMsIGVsZW1lbnQpIHtcbiAgICBpZiAoIWFjdGl2ZUl0ZW1zIHx8ICFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIGFyZSBjbGlja2luZyBvbiBhbiBvcHRpb25cbiAgICB2YXIgaWQgPSBlbGVtZW50LmRhdGFzZXQuaWQ7XG4gICAgdmFyIGNob2ljZSA9IGlkICYmIHRoaXMuX3N0b3JlLmdldENob2ljZUJ5SWQoaWQpO1xuICAgIGlmICghY2hvaWNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXNzZWRLZXlDb2RlID0gYWN0aXZlSXRlbXNbMF0gJiYgYWN0aXZlSXRlbXNbMF0ua2V5Q29kZSA/IGFjdGl2ZUl0ZW1zWzBdLmtleUNvZGUgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGhhc0FjdGl2ZURyb3Bkb3duID0gdGhpcy5kcm9wZG93bi5pc0FjdGl2ZTtcbiAgICAvLyBVcGRhdGUgY2hvaWNlIGtleUNvZGVcbiAgICBjaG9pY2Uua2V5Q29kZSA9IHBhc3NlZEtleUNvZGU7XG4gICAgdGhpcy5wYXNzZWRFbGVtZW50LnRyaWdnZXJFdmVudChjb25zdGFudHNfMS5FVkVOVFMuY2hvaWNlLCB7XG4gICAgICBjaG9pY2U6IGNob2ljZVxuICAgIH0pO1xuICAgIGlmICghY2hvaWNlLnNlbGVjdGVkICYmICFjaG9pY2UuZGlzYWJsZWQpIHtcbiAgICAgIHZhciBjYW5BZGRJdGVtID0gdGhpcy5fY2FuQWRkSXRlbShhY3RpdmVJdGVtcywgY2hvaWNlLnZhbHVlKTtcbiAgICAgIGlmIChjYW5BZGRJdGVtLnJlc3BvbnNlKSB7XG4gICAgICAgIHRoaXMuX2FkZEl0ZW0oe1xuICAgICAgICAgIHZhbHVlOiBjaG9pY2UudmFsdWUsXG4gICAgICAgICAgbGFiZWw6IGNob2ljZS5sYWJlbCxcbiAgICAgICAgICBjaG9pY2VJZDogY2hvaWNlLmlkLFxuICAgICAgICAgIGdyb3VwSWQ6IGNob2ljZS5ncm91cElkLFxuICAgICAgICAgIGN1c3RvbVByb3BlcnRpZXM6IGNob2ljZS5jdXN0b21Qcm9wZXJ0aWVzLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBjaG9pY2UucGxhY2Vob2xkZXIsXG4gICAgICAgICAga2V5Q29kZTogY2hvaWNlLmtleUNvZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuZ2UoY2hvaWNlLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jbGVhcklucHV0KCk7XG4gICAgLy8gV2Ugd2FudCB0byBjbG9zZSB0aGUgZHJvcGRvd24gaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBhIHNpbmdsZSBzZWxlY3QgYm94XG4gICAgaWYgKGhhc0FjdGl2ZURyb3Bkb3duICYmIHRoaXMuX2lzU2VsZWN0T25lRWxlbWVudCkge1xuICAgICAgdGhpcy5oaWRlRHJvcGRvd24odHJ1ZSk7XG4gICAgICB0aGlzLmNvbnRhaW5lck91dGVyLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5faGFuZGxlQmFja3NwYWNlID0gZnVuY3Rpb24gKGFjdGl2ZUl0ZW1zKSB7XG4gICAgaWYgKCF0aGlzLmNvbmZpZy5yZW1vdmVJdGVtcyB8fCAhYWN0aXZlSXRlbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxhc3RJdGVtID0gYWN0aXZlSXRlbXNbYWN0aXZlSXRlbXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGhhc0hpZ2hsaWdodGVkSXRlbXMgPSBhY3RpdmVJdGVtcy5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5oaWdobGlnaHRlZDtcbiAgICB9KTtcbiAgICAvLyBJZiBlZGl0aW5nIHRoZSBsYXN0IGl0ZW0gaXMgYWxsb3dlZCBhbmQgdGhlcmUgYXJlIG5vdCBvdGhlciBzZWxlY3RlZCBpdGVtcyxcbiAgICAvLyB3ZSBjYW4gZWRpdCB0aGUgaXRlbSB2YWx1ZS4gT3RoZXJ3aXNlIGlmIHdlIGNhbiByZW1vdmUgaXRlbXMsIHJlbW92ZSBhbGwgc2VsZWN0ZWQgaXRlbXNcbiAgICBpZiAodGhpcy5jb25maWcuZWRpdEl0ZW1zICYmICFoYXNIaWdobGlnaHRlZEl0ZW1zICYmIGxhc3RJdGVtKSB7XG4gICAgICB0aGlzLmlucHV0LnZhbHVlID0gbGFzdEl0ZW0udmFsdWU7XG4gICAgICB0aGlzLmlucHV0LnNldFdpZHRoKCk7XG4gICAgICB0aGlzLl9yZW1vdmVJdGVtKGxhc3RJdGVtKTtcbiAgICAgIHRoaXMuX3RyaWdnZXJDaGFuZ2UobGFzdEl0ZW0udmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWhhc0hpZ2hsaWdodGVkSXRlbXMpIHtcbiAgICAgICAgLy8gSGlnaGxpZ2h0IGxhc3QgaXRlbSBpZiBub25lIGFscmVhZHkgaGlnaGxpZ2h0ZWRcbiAgICAgICAgdGhpcy5oaWdobGlnaHRJdGVtKGxhc3RJdGVtLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZUhpZ2hsaWdodGVkSXRlbXModHJ1ZSk7XG4gICAgfVxuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5fc3RhcnRMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKCgwLCBtaXNjXzEuc2V0SXNMb2FkaW5nKSh0cnVlKSk7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9zdG9wTG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaCgoMCwgbWlzY18xLnNldElzTG9hZGluZykoZmFsc2UpKTtcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX2hhbmRsZUxvYWRpbmdTdGF0ZSA9IGZ1bmN0aW9uIChzZXRMb2FkaW5nKSB7XG4gICAgaWYgKHNldExvYWRpbmcgPT09IHZvaWQgMCkge1xuICAgICAgc2V0TG9hZGluZyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBwbGFjZWhvbGRlckl0ZW0gPSB0aGlzLml0ZW1MaXN0LmdldENoaWxkKFwiLlwiLmNvbmNhdCh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLnBsYWNlaG9sZGVyKSk7XG4gICAgaWYgKHNldExvYWRpbmcpIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgdGhpcy5jb250YWluZXJPdXRlci5hZGRMb2FkaW5nU3RhdGUoKTtcbiAgICAgIGlmICh0aGlzLl9pc1NlbGVjdE9uZUVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFwbGFjZWhvbGRlckl0ZW0pIHtcbiAgICAgICAgICBwbGFjZWhvbGRlckl0ZW0gPSB0aGlzLl9nZXRUZW1wbGF0ZSgncGxhY2Vob2xkZXInLCB0aGlzLmNvbmZpZy5sb2FkaW5nVGV4dCk7XG4gICAgICAgICAgaWYgKHBsYWNlaG9sZGVySXRlbSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtTGlzdC5hcHBlbmQocGxhY2Vob2xkZXJJdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGxhY2Vob2xkZXJJdGVtLmlubmVySFRNTCA9IHRoaXMuY29uZmlnLmxvYWRpbmdUZXh0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5jb25maWcubG9hZGluZ1RleHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICB0aGlzLmNvbnRhaW5lck91dGVyLnJlbW92ZUxvYWRpbmdTdGF0ZSgpO1xuICAgICAgaWYgKHRoaXMuX2lzU2VsZWN0T25lRWxlbWVudCkge1xuICAgICAgICBpZiAocGxhY2Vob2xkZXJJdGVtKSB7XG4gICAgICAgICAgcGxhY2Vob2xkZXJJdGVtLmlubmVySFRNTCA9IHRoaXMuX3BsYWNlaG9sZGVyVmFsdWUgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5wdXQucGxhY2Vob2xkZXIgPSB0aGlzLl9wbGFjZWhvbGRlclZhbHVlIHx8ICcnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX2hhbmRsZVNlYXJjaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghdGhpcy5pbnB1dC5pc0ZvY3Vzc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjaG9pY2VzID0gdGhpcy5fc3RvcmUuY2hvaWNlcztcbiAgICB2YXIgX2EgPSB0aGlzLmNvbmZpZyxcbiAgICAgIHNlYXJjaEZsb29yID0gX2Euc2VhcmNoRmxvb3IsXG4gICAgICBzZWFyY2hDaG9pY2VzID0gX2Euc2VhcmNoQ2hvaWNlcztcbiAgICB2YXIgaGFzVW5hY3RpdmVDaG9pY2VzID0gY2hvaWNlcy5zb21lKGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgIHJldHVybiAhb3B0aW9uLmFjdGl2ZTtcbiAgICB9KTtcbiAgICAvLyBDaGVjayB0aGF0IHdlIGhhdmUgYSB2YWx1ZSB0byBzZWFyY2ggYW5kIHRoZSBpbnB1dCB3YXMgYW4gYWxwaGFudW1lcmljIGNoYXJhY3RlclxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlLmxlbmd0aCA+PSBzZWFyY2hGbG9vcikge1xuICAgICAgdmFyIHJlc3VsdENvdW50ID0gc2VhcmNoQ2hvaWNlcyA/IHRoaXMuX3NlYXJjaENob2ljZXModmFsdWUpIDogMDtcbiAgICAgIC8vIFRyaWdnZXIgc2VhcmNoIGV2ZW50XG4gICAgICB0aGlzLnBhc3NlZEVsZW1lbnQudHJpZ2dlckV2ZW50KGNvbnN0YW50c18xLkVWRU5UUy5zZWFyY2gsIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICByZXN1bHRDb3VudDogcmVzdWx0Q291bnRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaGFzVW5hY3RpdmVDaG9pY2VzKSB7XG4gICAgICAvLyBPdGhlcndpc2UgcmVzZXQgY2hvaWNlcyB0byBhY3RpdmVcbiAgICAgIHRoaXMuX2lzU2VhcmNoaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaCgoMCwgY2hvaWNlc18xLmFjdGl2YXRlQ2hvaWNlcykodHJ1ZSkpO1xuICAgIH1cbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX2NhbkFkZEl0ZW0gPSBmdW5jdGlvbiAoYWN0aXZlSXRlbXMsIHZhbHVlKSB7XG4gICAgdmFyIGNhbkFkZEl0ZW0gPSB0cnVlO1xuICAgIHZhciBub3RpY2UgPSB0eXBlb2YgdGhpcy5jb25maWcuYWRkSXRlbVRleHQgPT09ICdmdW5jdGlvbicgPyB0aGlzLmNvbmZpZy5hZGRJdGVtVGV4dCh2YWx1ZSkgOiB0aGlzLmNvbmZpZy5hZGRJdGVtVGV4dDtcbiAgICBpZiAoIXRoaXMuX2lzU2VsZWN0T25lRWxlbWVudCkge1xuICAgICAgdmFyIGlzRHVwbGljYXRlVmFsdWUgPSAoMCwgdXRpbHNfMS5leGlzdHNJbkFycmF5KShhY3RpdmVJdGVtcywgdmFsdWUpO1xuICAgICAgaWYgKHRoaXMuY29uZmlnLm1heEl0ZW1Db3VudCA+IDAgJiYgdGhpcy5jb25maWcubWF4SXRlbUNvdW50IDw9IGFjdGl2ZUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIG1heCBlbnRyeSBsaW1pdCBhbmQgd2UgaGF2ZSByZWFjaGVkIHRoYXQgbGltaXRcbiAgICAgICAgLy8gZG9uJ3QgdXBkYXRlXG4gICAgICAgIGNhbkFkZEl0ZW0gPSBmYWxzZTtcbiAgICAgICAgbm90aWNlID0gdHlwZW9mIHRoaXMuY29uZmlnLm1heEl0ZW1UZXh0ID09PSAnZnVuY3Rpb24nID8gdGhpcy5jb25maWcubWF4SXRlbVRleHQodGhpcy5jb25maWcubWF4SXRlbUNvdW50KSA6IHRoaXMuY29uZmlnLm1heEl0ZW1UZXh0O1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5kdXBsaWNhdGVJdGVtc0FsbG93ZWQgJiYgaXNEdXBsaWNhdGVWYWx1ZSAmJiBjYW5BZGRJdGVtKSB7XG4gICAgICAgIGNhbkFkZEl0ZW0gPSBmYWxzZTtcbiAgICAgICAgbm90aWNlID0gdHlwZW9mIHRoaXMuY29uZmlnLnVuaXF1ZUl0ZW1UZXh0ID09PSAnZnVuY3Rpb24nID8gdGhpcy5jb25maWcudW5pcXVlSXRlbVRleHQodmFsdWUpIDogdGhpcy5jb25maWcudW5pcXVlSXRlbVRleHQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNUZXh0RWxlbWVudCAmJiB0aGlzLmNvbmZpZy5hZGRJdGVtcyAmJiBjYW5BZGRJdGVtICYmIHR5cGVvZiB0aGlzLmNvbmZpZy5hZGRJdGVtRmlsdGVyID09PSAnZnVuY3Rpb24nICYmICF0aGlzLmNvbmZpZy5hZGRJdGVtRmlsdGVyKHZhbHVlKSkge1xuICAgICAgICBjYW5BZGRJdGVtID0gZmFsc2U7XG4gICAgICAgIG5vdGljZSA9IHR5cGVvZiB0aGlzLmNvbmZpZy5jdXN0b21BZGRJdGVtVGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuY29uZmlnLmN1c3RvbUFkZEl0ZW1UZXh0KHZhbHVlKSA6IHRoaXMuY29uZmlnLmN1c3RvbUFkZEl0ZW1UZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2U6IGNhbkFkZEl0ZW0sXG4gICAgICBub3RpY2U6IG5vdGljZVxuICAgIH07XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9zZWFyY2hDaG9pY2VzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIG5ld1ZhbHVlID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xuICAgIHZhciBjdXJyZW50VmFsdWUgPSB0eXBlb2YgdGhpcy5fY3VycmVudFZhbHVlID09PSAnc3RyaW5nJyA/IHRoaXMuX2N1cnJlbnRWYWx1ZS50cmltKCkgOiB0aGlzLl9jdXJyZW50VmFsdWU7XG4gICAgaWYgKG5ld1ZhbHVlLmxlbmd0aCA8IDEgJiYgbmV3VmFsdWUgPT09IFwiXCIuY29uY2F0KGN1cnJlbnRWYWx1ZSwgXCIgXCIpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gSWYgbmV3IHZhbHVlIG1hdGNoZXMgdGhlIGRlc2lyZWQgbGVuZ3RoIGFuZCBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgdmFsdWUgd2l0aCBhIHNwYWNlXG4gICAgdmFyIGhheXN0YWNrID0gdGhpcy5fc3RvcmUuc2VhcmNoYWJsZUNob2ljZXM7XG4gICAgdmFyIG5lZWRsZSA9IG5ld1ZhbHVlO1xuICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih0aGlzLmNvbmZpZy5mdXNlT3B0aW9ucywge1xuICAgICAga2V5czogX19zcHJlYWRBcnJheShbXSwgdGhpcy5jb25maWcuc2VhcmNoRmllbGRzLCB0cnVlKSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzOiB0cnVlXG4gICAgfSk7XG4gICAgdmFyIGZ1c2UgPSBuZXcgZnVzZV9qc18xLmRlZmF1bHQoaGF5c3RhY2ssIG9wdGlvbnMpO1xuICAgIHZhciByZXN1bHRzID0gZnVzZS5zZWFyY2gobmVlZGxlKTsgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlzay9GdXNlL2lzc3Vlcy8zMDNcbiAgICB0aGlzLl9jdXJyZW50VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB0aGlzLl9oaWdobGlnaHRQb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5faXNTZWFyY2hpbmcgPSB0cnVlO1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKCgwLCBjaG9pY2VzXzEuZmlsdGVyQ2hvaWNlcykocmVzdWx0cykpO1xuICAgIHJldHVybiByZXN1bHRzLmxlbmd0aDtcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgLy8gY2FwdHVyZSBldmVudHMgLSBjYW4gY2FuY2VsIGV2ZW50IHByb2Nlc3Npbmcgb3IgcHJvcGFnYXRpb25cbiAgICBkb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0cnVlKTtcbiAgICB0aGlzLmNvbnRhaW5lck91dGVyLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdHJ1ZSk7XG4gICAgdGhpcy5jb250YWluZXJPdXRlci5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0cnVlKTtcbiAgICAvLyBwYXNzaXZlIGV2ZW50cyAtIGRvZXNuJ3QgY2FsbCBgcHJldmVudERlZmF1bHRgIG9yIGBzdG9wUHJvcGFnYXRpb25gXG4gICAgZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljaywge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblRvdWNoTW92ZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuZHJvcGRvd24uZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLl9vbk1vdXNlT3Zlciwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLl9pc1NlbGVjdE9uZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyT3V0ZXIuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXMsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmNvbnRhaW5lck91dGVyLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX29uQmx1ciwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5pbnB1dC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fb25LZXlVcCwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuaW5wdXQuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXMsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmlucHV0LmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX29uQmx1ciwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmlucHV0LmVsZW1lbnQuZm9ybSkge1xuICAgICAgdGhpcy5pbnB1dC5lbGVtZW50LmZvcm0uYWRkRXZlbnRMaXN0ZW5lcigncmVzZXQnLCB0aGlzLl9vbkZvcm1SZXNldCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVycygpO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBkb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0cnVlKTtcbiAgICB0aGlzLmNvbnRhaW5lck91dGVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdHJ1ZSk7XG4gICAgdGhpcy5jb250YWluZXJPdXRlci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICBkb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIHRoaXMuZHJvcGRvd24uZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLl9vbk1vdXNlT3Zlcik7XG4gICAgaWYgKHRoaXMuX2lzU2VsZWN0T25lRWxlbWVudCkge1xuICAgICAgdGhpcy5jb250YWluZXJPdXRlci5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25Gb2N1cyk7XG4gICAgICB0aGlzLmNvbnRhaW5lck91dGVyLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX29uQmx1cik7XG4gICAgfVxuICAgIHRoaXMuaW5wdXQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX29uS2V5VXApO1xuICAgIHRoaXMuaW5wdXQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXMpO1xuICAgIHRoaXMuaW5wdXQuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fb25CbHVyKTtcbiAgICBpZiAodGhpcy5pbnB1dC5lbGVtZW50LmZvcm0pIHtcbiAgICAgIHRoaXMuaW5wdXQuZWxlbWVudC5mb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2V0JywgdGhpcy5fb25Gb3JtUmVzZXQpO1xuICAgIH1cbiAgICB0aGlzLmlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9vbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgdmFyIGFjdGl2ZUl0ZW1zID0gdGhpcy5fc3RvcmUuYWN0aXZlSXRlbXM7XG4gICAgdmFyIGhhc0ZvY3VzZWRJbnB1dCA9IHRoaXMuaW5wdXQuaXNGb2N1c3NlZDtcbiAgICB2YXIgaGFzQWN0aXZlRHJvcGRvd24gPSB0aGlzLmRyb3Bkb3duLmlzQWN0aXZlO1xuICAgIHZhciBoYXNJdGVtcyA9IHRoaXMuaXRlbUxpc3QuaGFzQ2hpbGRyZW4oKTtcbiAgICB2YXIga2V5U3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlDb2RlKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgIHZhciB3YXNQcmludGFibGVDaGFyID0gL1teXFx4MDAtXFx4MUZdLy50ZXN0KGtleVN0cmluZyk7XG4gICAgdmFyIEJBQ0tfS0VZID0gY29uc3RhbnRzXzEuS0VZX0NPREVTLkJBQ0tfS0VZLFxuICAgICAgREVMRVRFX0tFWSA9IGNvbnN0YW50c18xLktFWV9DT0RFUy5ERUxFVEVfS0VZLFxuICAgICAgRU5URVJfS0VZID0gY29uc3RhbnRzXzEuS0VZX0NPREVTLkVOVEVSX0tFWSxcbiAgICAgIEFfS0VZID0gY29uc3RhbnRzXzEuS0VZX0NPREVTLkFfS0VZLFxuICAgICAgRVNDX0tFWSA9IGNvbnN0YW50c18xLktFWV9DT0RFUy5FU0NfS0VZLFxuICAgICAgVVBfS0VZID0gY29uc3RhbnRzXzEuS0VZX0NPREVTLlVQX0tFWSxcbiAgICAgIERPV05fS0VZID0gY29uc3RhbnRzXzEuS0VZX0NPREVTLkRPV05fS0VZLFxuICAgICAgUEFHRV9VUF9LRVkgPSBjb25zdGFudHNfMS5LRVlfQ09ERVMuUEFHRV9VUF9LRVksXG4gICAgICBQQUdFX0RPV05fS0VZID0gY29uc3RhbnRzXzEuS0VZX0NPREVTLlBBR0VfRE9XTl9LRVk7XG4gICAgaWYgKCF0aGlzLl9pc1RleHRFbGVtZW50ICYmICFoYXNBY3RpdmVEcm9wZG93biAmJiB3YXNQcmludGFibGVDaGFyKSB7XG4gICAgICB0aGlzLnNob3dEcm9wZG93bigpO1xuICAgICAgaWYgKCF0aGlzLmlucHV0LmlzRm9jdXNzZWQpIHtcbiAgICAgICAgLypcbiAgICAgICAgICBXZSB1cGRhdGUgdGhlIGlucHV0IHZhbHVlIHdpdGggdGhlIHByZXNzZWQga2V5IGFzXG4gICAgICAgICAgdGhlIGlucHV0IHdhcyBub3QgZm9jdXNzZWQgYXQgdGhlIHRpbWUgb2Yga2V5IHByZXNzXG4gICAgICAgICAgdGhlcmVmb3JlIGRvZXMgbm90IGhhdmUgdGhlIHZhbHVlIG9mIHRoZSBrZXkuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5wdXQudmFsdWUgKz0gZXZlbnQua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoa2V5Q29kZSkge1xuICAgICAgY2FzZSBBX0tFWTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uU2VsZWN0S2V5KGV2ZW50LCBoYXNJdGVtcyk7XG4gICAgICBjYXNlIEVOVEVSX0tFWTpcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRW50ZXJLZXkoZXZlbnQsIGFjdGl2ZUl0ZW1zLCBoYXNBY3RpdmVEcm9wZG93bik7XG4gICAgICBjYXNlIEVTQ19LRVk6XG4gICAgICAgIHJldHVybiB0aGlzLl9vbkVzY2FwZUtleShoYXNBY3RpdmVEcm9wZG93bik7XG4gICAgICBjYXNlIFVQX0tFWTpcbiAgICAgIGNhc2UgUEFHRV9VUF9LRVk6XG4gICAgICBjYXNlIERPV05fS0VZOlxuICAgICAgY2FzZSBQQUdFX0RPV05fS0VZOlxuICAgICAgICByZXR1cm4gdGhpcy5fb25EaXJlY3Rpb25LZXkoZXZlbnQsIGhhc0FjdGl2ZURyb3Bkb3duKTtcbiAgICAgIGNhc2UgREVMRVRFX0tFWTpcbiAgICAgIGNhc2UgQkFDS19LRVk6XG4gICAgICAgIHJldHVybiB0aGlzLl9vbkRlbGV0ZUtleShldmVudCwgYWN0aXZlSXRlbXMsIGhhc0ZvY3VzZWRJbnB1dCk7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX29uS2V5VXAgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdGFyZ2V0ID0gX2EudGFyZ2V0LFxuICAgICAga2V5Q29kZSA9IF9hLmtleUNvZGU7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5pbnB1dC52YWx1ZTtcbiAgICB2YXIgYWN0aXZlSXRlbXMgPSB0aGlzLl9zdG9yZS5hY3RpdmVJdGVtcztcbiAgICB2YXIgY2FuQWRkSXRlbSA9IHRoaXMuX2NhbkFkZEl0ZW0oYWN0aXZlSXRlbXMsIHZhbHVlKTtcbiAgICB2YXIgYmFja0tleSA9IGNvbnN0YW50c18xLktFWV9DT0RFUy5CQUNLX0tFWSxcbiAgICAgIGRlbGV0ZUtleSA9IGNvbnN0YW50c18xLktFWV9DT0RFUy5ERUxFVEVfS0VZO1xuICAgIC8vIFdlIGFyZSB0eXBpbmcgaW50byBhIHRleHQgaW5wdXQgYW5kIGhhdmUgYSB2YWx1ZSwgd2Ugd2FudCB0byBzaG93IGEgZHJvcGRvd25cbiAgICAvLyBub3RpY2UuIE90aGVyd2lzZSBoaWRlIHRoZSBkcm9wZG93blxuICAgIGlmICh0aGlzLl9pc1RleHRFbGVtZW50KSB7XG4gICAgICB2YXIgY2FuU2hvd0Ryb3Bkb3duTm90aWNlID0gY2FuQWRkSXRlbS5ub3RpY2UgJiYgdmFsdWU7XG4gICAgICBpZiAoY2FuU2hvd0Ryb3Bkb3duTm90aWNlKSB7XG4gICAgICAgIHZhciBkcm9wZG93bkl0ZW0gPSB0aGlzLl9nZXRUZW1wbGF0ZSgnbm90aWNlJywgY2FuQWRkSXRlbS5ub3RpY2UpO1xuICAgICAgICB0aGlzLmRyb3Bkb3duLmVsZW1lbnQuaW5uZXJIVE1MID0gZHJvcGRvd25JdGVtLm91dGVySFRNTDtcbiAgICAgICAgdGhpcy5zaG93RHJvcGRvd24odHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZGVEcm9wZG93bih0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdhc1JlbW92YWxLZXlDb2RlID0ga2V5Q29kZSA9PT0gYmFja0tleSB8fCBrZXlDb2RlID09PSBkZWxldGVLZXk7XG4gICAgICB2YXIgdXNlckhhc1JlbW92ZWRWYWx1ZSA9IHdhc1JlbW92YWxLZXlDb2RlICYmIHRhcmdldCAmJiAhdGFyZ2V0LnZhbHVlO1xuICAgICAgdmFyIGNhblJlYWN0aXZhdGVDaG9pY2VzID0gIXRoaXMuX2lzVGV4dEVsZW1lbnQgJiYgdGhpcy5faXNTZWFyY2hpbmc7XG4gICAgICB2YXIgY2FuU2VhcmNoID0gdGhpcy5fY2FuU2VhcmNoICYmIGNhbkFkZEl0ZW0ucmVzcG9uc2U7XG4gICAgICBpZiAodXNlckhhc1JlbW92ZWRWYWx1ZSAmJiBjYW5SZWFjdGl2YXRlQ2hvaWNlcykge1xuICAgICAgICB0aGlzLl9pc1NlYXJjaGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaCgoMCwgY2hvaWNlc18xLmFjdGl2YXRlQ2hvaWNlcykodHJ1ZSkpO1xuICAgICAgfSBlbHNlIGlmIChjYW5TZWFyY2gpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlU2VhcmNoKHRoaXMuaW5wdXQucmF3VmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jYW5TZWFyY2ggPSB0aGlzLmNvbmZpZy5zZWFyY2hFbmFibGVkO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5fb25TZWxlY3RLZXkgPSBmdW5jdGlvbiAoZXZlbnQsIGhhc0l0ZW1zKSB7XG4gICAgdmFyIGN0cmxLZXkgPSBldmVudC5jdHJsS2V5LFxuICAgICAgbWV0YUtleSA9IGV2ZW50Lm1ldGFLZXk7XG4gICAgdmFyIGhhc0N0cmxEb3duS2V5UHJlc3NlZCA9IGN0cmxLZXkgfHwgbWV0YUtleTtcbiAgICAvLyBJZiBDVFJMICsgQSBvciBDTUQgKyBBIGhhdmUgYmVlbiBwcmVzc2VkIGFuZCB0aGVyZSBhcmUgaXRlbXMgdG8gc2VsZWN0XG4gICAgaWYgKGhhc0N0cmxEb3duS2V5UHJlc3NlZCAmJiBoYXNJdGVtcykge1xuICAgICAgdGhpcy5fY2FuU2VhcmNoID0gZmFsc2U7XG4gICAgICB2YXIgc2hvdWxkSGlnaHRsaWdodEFsbCA9IHRoaXMuY29uZmlnLnJlbW92ZUl0ZW1zICYmICF0aGlzLmlucHV0LnZhbHVlICYmIHRoaXMuaW5wdXQuZWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChzaG91bGRIaWdodGxpZ2h0QWxsKSB7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0QWxsKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5fb25FbnRlcktleSA9IGZ1bmN0aW9uIChldmVudCwgYWN0aXZlSXRlbXMsIGhhc0FjdGl2ZURyb3Bkb3duKSB7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgZW50ZXJLZXkgPSBjb25zdGFudHNfMS5LRVlfQ09ERVMuRU5URVJfS0VZO1xuICAgIHZhciB0YXJnZXRXYXNCdXR0b24gPSB0YXJnZXQgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1idXR0b24nKTtcbiAgICBpZiAodGhpcy5faXNUZXh0RWxlbWVudCAmJiB0YXJnZXQgJiYgdGFyZ2V0LnZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmlucHV0LnZhbHVlO1xuICAgICAgdmFyIGNhbkFkZEl0ZW0gPSB0aGlzLl9jYW5BZGRJdGVtKGFjdGl2ZUl0ZW1zLCB2YWx1ZSk7XG4gICAgICBpZiAoY2FuQWRkSXRlbS5yZXNwb25zZSkge1xuICAgICAgICB0aGlzLmhpZGVEcm9wZG93bih0cnVlKTtcbiAgICAgICAgdGhpcy5fYWRkSXRlbSh7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbmdlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jbGVhcklucHV0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0YXJnZXRXYXNCdXR0b24pIHtcbiAgICAgIHRoaXMuX2hhbmRsZUJ1dHRvbkFjdGlvbihhY3RpdmVJdGVtcywgdGFyZ2V0KTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGlmIChoYXNBY3RpdmVEcm9wZG93bikge1xuICAgICAgdmFyIGhpZ2hsaWdodGVkQ2hvaWNlID0gdGhpcy5kcm9wZG93bi5nZXRDaGlsZChcIi5cIi5jb25jYXQodGhpcy5jb25maWcuY2xhc3NOYW1lcy5oaWdobGlnaHRlZFN0YXRlKSk7XG4gICAgICBpZiAoaGlnaGxpZ2h0ZWRDaG9pY2UpIHtcbiAgICAgICAgLy8gYWRkIGVudGVyIGtleUNvZGUgdmFsdWVcbiAgICAgICAgaWYgKGFjdGl2ZUl0ZW1zWzBdKSB7XG4gICAgICAgICAgYWN0aXZlSXRlbXNbMF0ua2V5Q29kZSA9IGVudGVyS2V5OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oYW5kbGVDaG9pY2VBY3Rpb24oYWN0aXZlSXRlbXMsIGhpZ2hsaWdodGVkQ2hvaWNlKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9pc1NlbGVjdE9uZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX29uRXNjYXBlS2V5ID0gZnVuY3Rpb24gKGhhc0FjdGl2ZURyb3Bkb3duKSB7XG4gICAgaWYgKGhhc0FjdGl2ZURyb3Bkb3duKSB7XG4gICAgICB0aGlzLmhpZGVEcm9wZG93bih0cnVlKTtcbiAgICAgIHRoaXMuY29udGFpbmVyT3V0ZXIuZm9jdXMoKTtcbiAgICB9XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9vbkRpcmVjdGlvbktleSA9IGZ1bmN0aW9uIChldmVudCwgaGFzQWN0aXZlRHJvcGRvd24pIHtcbiAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGUsXG4gICAgICBtZXRhS2V5ID0gZXZlbnQubWV0YUtleTtcbiAgICB2YXIgZG93bktleSA9IGNvbnN0YW50c18xLktFWV9DT0RFUy5ET1dOX0tFWSxcbiAgICAgIHBhZ2VVcEtleSA9IGNvbnN0YW50c18xLktFWV9DT0RFUy5QQUdFX1VQX0tFWSxcbiAgICAgIHBhZ2VEb3duS2V5ID0gY29uc3RhbnRzXzEuS0VZX0NPREVTLlBBR0VfRE9XTl9LRVk7XG4gICAgLy8gSWYgdXAgb3IgZG93biBrZXkgaXMgcHJlc3NlZCwgdHJhdmVyc2UgdGhyb3VnaCBvcHRpb25zXG4gICAgaWYgKGhhc0FjdGl2ZURyb3Bkb3duIHx8IHRoaXMuX2lzU2VsZWN0T25lRWxlbWVudCkge1xuICAgICAgdGhpcy5zaG93RHJvcGRvd24oKTtcbiAgICAgIHRoaXMuX2NhblNlYXJjaCA9IGZhbHNlO1xuICAgICAgdmFyIGRpcmVjdGlvbkludCA9IGtleUNvZGUgPT09IGRvd25LZXkgfHwga2V5Q29kZSA9PT0gcGFnZURvd25LZXkgPyAxIDogLTE7XG4gICAgICB2YXIgc2tpcEtleSA9IG1ldGFLZXkgfHwga2V5Q29kZSA9PT0gcGFnZURvd25LZXkgfHwga2V5Q29kZSA9PT0gcGFnZVVwS2V5O1xuICAgICAgdmFyIHNlbGVjdGFibGVDaG9pY2VJZGVudGlmaWVyID0gJ1tkYXRhLWNob2ljZS1zZWxlY3RhYmxlXSc7XG4gICAgICB2YXIgbmV4dEVsID0gdm9pZCAwO1xuICAgICAgaWYgKHNraXBLZXkpIHtcbiAgICAgICAgaWYgKGRpcmVjdGlvbkludCA+IDApIHtcbiAgICAgICAgICBuZXh0RWwgPSB0aGlzLmRyb3Bkb3duLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIlwiLmNvbmNhdChzZWxlY3RhYmxlQ2hvaWNlSWRlbnRpZmllciwgXCI6bGFzdC1vZi10eXBlXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0RWwgPSB0aGlzLmRyb3Bkb3duLmVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RhYmxlQ2hvaWNlSWRlbnRpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjdXJyZW50RWwgPSB0aGlzLmRyb3Bkb3duLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5cIi5jb25jYXQodGhpcy5jb25maWcuY2xhc3NOYW1lcy5oaWdobGlnaHRlZFN0YXRlKSk7XG4gICAgICAgIGlmIChjdXJyZW50RWwpIHtcbiAgICAgICAgICBuZXh0RWwgPSAoMCwgdXRpbHNfMS5nZXRBZGphY2VudEVsKShjdXJyZW50RWwsIHNlbGVjdGFibGVDaG9pY2VJZGVudGlmaWVyLCBkaXJlY3Rpb25JbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRFbCA9IHRoaXMuZHJvcGRvd24uZWxlbWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdGFibGVDaG9pY2VJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5leHRFbCkge1xuICAgICAgICAvLyBXZSBwcmV2ZW50IGRlZmF1bHQgdG8gc3RvcCB0aGUgY3Vyc29yIG1vdmluZ1xuICAgICAgICAvLyB3aGVuIHByZXNzaW5nIHRoZSBhcnJvd1xuICAgICAgICBpZiAoISgwLCB1dGlsc18xLmlzU2Nyb2xsZWRJbnRvVmlldykobmV4dEVsLCB0aGlzLmNob2ljZUxpc3QuZWxlbWVudCwgZGlyZWN0aW9uSW50KSkge1xuICAgICAgICAgIHRoaXMuY2hvaWNlTGlzdC5zY3JvbGxUb0NoaWxkRWxlbWVudChuZXh0RWwsIGRpcmVjdGlvbkludCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGlnaGxpZ2h0Q2hvaWNlKG5leHRFbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgdG8gbWFpbnRhaW4gY3Vyc29yIHBvc2l0aW9uIHdoaWxzdFxuICAgICAgLy8gdHJhdmVyc2luZyBkcm9wZG93biBvcHRpb25zXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX29uRGVsZXRlS2V5ID0gZnVuY3Rpb24gKGV2ZW50LCBhY3RpdmVJdGVtcywgaGFzRm9jdXNlZElucHV0KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAvLyBJZiBiYWNrc3BhY2Ugb3IgZGVsZXRlIGtleSBpcyBwcmVzc2VkIGFuZCB0aGUgaW5wdXQgaGFzIG5vIHZhbHVlXG4gICAgaWYgKCF0aGlzLl9pc1NlbGVjdE9uZUVsZW1lbnQgJiYgIXRhcmdldC52YWx1ZSAmJiBoYXNGb2N1c2VkSW5wdXQpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUJhY2tzcGFjZShhY3RpdmVJdGVtcyk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX29uVG91Y2hNb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93YXNUYXApIHtcbiAgICAgIHRoaXMuX3dhc1RhcCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX29uVG91Y2hFbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gKGV2ZW50IHx8IGV2ZW50LnRvdWNoZXNbMF0pLnRhcmdldDtcbiAgICB2YXIgdG91Y2hXYXNXaXRoaW5Db250YWluZXIgPSB0aGlzLl93YXNUYXAgJiYgdGhpcy5jb250YWluZXJPdXRlci5lbGVtZW50LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgaWYgKHRvdWNoV2FzV2l0aGluQ29udGFpbmVyKSB7XG4gICAgICB2YXIgY29udGFpbmVyV2FzRXhhY3RUYXJnZXQgPSB0YXJnZXQgPT09IHRoaXMuY29udGFpbmVyT3V0ZXIuZWxlbWVudCB8fCB0YXJnZXQgPT09IHRoaXMuY29udGFpbmVySW5uZXIuZWxlbWVudDtcbiAgICAgIGlmIChjb250YWluZXJXYXNFeGFjdFRhcmdldCkge1xuICAgICAgICBpZiAodGhpcy5faXNUZXh0RWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pc1NlbGVjdE11bHRpcGxlRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFByZXZlbnRzIGZvY3VzIGV2ZW50IGZpcmluZ1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX3dhc1RhcCA9IHRydWU7XG4gIH07XG4gIC8qKlxuICAgKiBIYW5kbGVzIG1vdXNlZG93biBldmVudCBpbiBjYXB0dXJlIG1vZGUgZm9yIGNvbnRhaW5ldE91dGVyLmVsZW1lbnRcbiAgICovXG4gIENob2ljZXMucHJvdG90eXBlLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIGhhdmUgb3VyIG1vdXNlIGRvd24gb24gdGhlIHNjcm9sbGJhciBhbmQgYXJlIG9uIElFMTEuLi5cbiAgICBpZiAoSVNfSUUxMSAmJiB0aGlzLmNob2ljZUxpc3QuZWxlbWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAvLyBjaGVjayBpZiBjbGljayB3YXMgb24gYSBzY3JvbGxiYXIgYXJlYVxuICAgICAgdmFyIGZpcnN0Q2hvaWNlID0gdGhpcy5jaG9pY2VMaXN0LmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICB2YXIgaXNPblNjcm9sbGJhciA9IHRoaXMuX2RpcmVjdGlvbiA9PT0gJ2x0cicgPyBldmVudC5vZmZzZXRYID49IGZpcnN0Q2hvaWNlLm9mZnNldFdpZHRoIDogZXZlbnQub2Zmc2V0WCA8IGZpcnN0Q2hvaWNlLm9mZnNldExlZnQ7XG4gICAgICB0aGlzLl9pc1Njcm9sbGluZ09uSWUgPSBpc09uU2Nyb2xsYmFyO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0ID09PSB0aGlzLmlucHV0LmVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGl0ZW0gPSB0YXJnZXQuY2xvc2VzdCgnW2RhdGEtYnV0dG9uXSxbZGF0YS1pdGVtXSxbZGF0YS1jaG9pY2VdJyk7XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgdmFyIGhhc1NoaWZ0S2V5ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICB2YXIgYWN0aXZlSXRlbXMgPSB0aGlzLl9zdG9yZS5hY3RpdmVJdGVtcztcbiAgICAgIHZhciBkYXRhc2V0ID0gaXRlbS5kYXRhc2V0O1xuICAgICAgaWYgKCdidXR0b24nIGluIGRhdGFzZXQpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlQnV0dG9uQWN0aW9uKGFjdGl2ZUl0ZW1zLCBpdGVtKTtcbiAgICAgIH0gZWxzZSBpZiAoJ2l0ZW0nIGluIGRhdGFzZXQpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlSXRlbUFjdGlvbihhY3RpdmVJdGVtcywgaXRlbSwgaGFzU2hpZnRLZXkpO1xuICAgICAgfSBlbHNlIGlmICgnY2hvaWNlJyBpbiBkYXRhc2V0KSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUNob2ljZUFjdGlvbihhY3RpdmVJdGVtcywgaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG4gIC8qKlxuICAgKiBIYW5kbGVzIG1vdXNlb3ZlciBldmVudCBvdmVyIHRoaXMuZHJvcGRvd25cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudFxuICAgKi9cbiAgQ2hvaWNlcy5wcm90b3R5cGUuX29uTW91c2VPdmVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHRhcmdldCA9IF9hLnRhcmdldDtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgJ2Nob2ljZScgaW4gdGFyZ2V0LmRhdGFzZXQpIHtcbiAgICAgIHRoaXMuX2hpZ2hsaWdodENob2ljZSh0YXJnZXQpO1xuICAgIH1cbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX29uQ2xpY2sgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgIHZhciBjbGlja1dhc1dpdGhpbkNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyT3V0ZXIuZWxlbWVudC5jb250YWlucyh0YXJnZXQpO1xuICAgIGlmIChjbGlja1dhc1dpdGhpbkNvbnRhaW5lcikge1xuICAgICAgaWYgKCF0aGlzLmRyb3Bkb3duLmlzQWN0aXZlICYmICF0aGlzLmNvbnRhaW5lck91dGVyLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVGV4dEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gdGhpcy5pbnB1dC5lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2hvd0Ryb3Bkb3duKCk7XG4gICAgICAgICAgdGhpcy5jb250YWluZXJPdXRlci5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzU2VsZWN0T25lRWxlbWVudCAmJiB0YXJnZXQgIT09IHRoaXMuaW5wdXQuZWxlbWVudCAmJiAhdGhpcy5kcm9wZG93bi5lbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgdGhpcy5oaWRlRHJvcGRvd24oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhhc0hpZ2hsaWdodGVkSXRlbXMgPSB0aGlzLl9zdG9yZS5oaWdobGlnaHRlZEFjdGl2ZUl0ZW1zLmxlbmd0aCA+IDA7XG4gICAgICBpZiAoaGFzSGlnaGxpZ2h0ZWRJdGVtcykge1xuICAgICAgICB0aGlzLnVuaGlnaGxpZ2h0QWxsKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRhaW5lck91dGVyLnJlbW92ZUZvY3VzU3RhdGUoKTtcbiAgICAgIHRoaXMuaGlkZURyb3Bkb3duKHRydWUpO1xuICAgIH1cbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX29uRm9jdXMgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgdGFyZ2V0ID0gX2EudGFyZ2V0O1xuICAgIHZhciBmb2N1c1dhc1dpdGhpbkNvbnRhaW5lciA9IHRhcmdldCAmJiB0aGlzLmNvbnRhaW5lck91dGVyLmVsZW1lbnQuY29udGFpbnModGFyZ2V0KTtcbiAgICBpZiAoIWZvY3VzV2FzV2l0aGluQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBmb2N1c0FjdGlvbnMgPSAoX2IgPSB7fSwgX2JbY29uc3RhbnRzXzEuVEVYVF9UWVBFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0YXJnZXQgPT09IF90aGlzLmlucHV0LmVsZW1lbnQpIHtcbiAgICAgICAgX3RoaXMuY29udGFpbmVyT3V0ZXIuYWRkRm9jdXNTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0sIF9iW2NvbnN0YW50c18xLlNFTEVDVF9PTkVfVFlQRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5jb250YWluZXJPdXRlci5hZGRGb2N1c1N0YXRlKCk7XG4gICAgICBpZiAodGFyZ2V0ID09PSBfdGhpcy5pbnB1dC5lbGVtZW50KSB7XG4gICAgICAgIF90aGlzLnNob3dEcm9wZG93bih0cnVlKTtcbiAgICAgIH1cbiAgICB9LCBfYltjb25zdGFudHNfMS5TRUxFQ1RfTVVMVElQTEVfVFlQRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGFyZ2V0ID09PSBfdGhpcy5pbnB1dC5lbGVtZW50KSB7XG4gICAgICAgIF90aGlzLnNob3dEcm9wZG93bih0cnVlKTtcbiAgICAgICAgLy8gSWYgZWxlbWVudCBpcyBhIHNlbGVjdCBib3gsIHRoZSBmb2N1c2VkIGVsZW1lbnQgaXMgdGhlIGNvbnRhaW5lciBhbmQgdGhlIGRyb3Bkb3duXG4gICAgICAgIC8vIGlzbid0IGFscmVhZHkgb3BlbiwgZm9jdXMgYW5kIHNob3cgZHJvcGRvd25cbiAgICAgICAgX3RoaXMuY29udGFpbmVyT3V0ZXIuYWRkRm9jdXNTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0sIF9iKTtcbiAgICBmb2N1c0FjdGlvbnNbdGhpcy5wYXNzZWRFbGVtZW50LmVsZW1lbnQudHlwZV0oKTtcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX29uQmx1ciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYjtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciB0YXJnZXQgPSBfYS50YXJnZXQ7XG4gICAgdmFyIGJsdXJXYXNXaXRoaW5Db250YWluZXIgPSB0YXJnZXQgJiYgdGhpcy5jb250YWluZXJPdXRlci5lbGVtZW50LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgaWYgKGJsdXJXYXNXaXRoaW5Db250YWluZXIgJiYgIXRoaXMuX2lzU2Nyb2xsaW5nT25JZSkge1xuICAgICAgdmFyIGFjdGl2ZUl0ZW1zID0gdGhpcy5fc3RvcmUuYWN0aXZlSXRlbXM7XG4gICAgICB2YXIgaGFzSGlnaGxpZ2h0ZWRJdGVtc18xID0gYWN0aXZlSXRlbXMuc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5oaWdobGlnaHRlZDtcbiAgICAgIH0pO1xuICAgICAgdmFyIGJsdXJBY3Rpb25zID0gKF9iID0ge30sIF9iW2NvbnN0YW50c18xLlRFWFRfVFlQRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IF90aGlzLmlucHV0LmVsZW1lbnQpIHtcbiAgICAgICAgICBfdGhpcy5jb250YWluZXJPdXRlci5yZW1vdmVGb2N1c1N0YXRlKCk7XG4gICAgICAgICAgaWYgKGhhc0hpZ2hsaWdodGVkSXRlbXNfMSkge1xuICAgICAgICAgICAgX3RoaXMudW5oaWdobGlnaHRBbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMuaGlkZURyb3Bkb3duKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCBfYltjb25zdGFudHNfMS5TRUxFQ1RfT05FX1RZUEVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5jb250YWluZXJPdXRlci5yZW1vdmVGb2N1c1N0YXRlKCk7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IF90aGlzLmlucHV0LmVsZW1lbnQgfHwgdGFyZ2V0ID09PSBfdGhpcy5jb250YWluZXJPdXRlci5lbGVtZW50ICYmICFfdGhpcy5fY2FuU2VhcmNoKSB7XG4gICAgICAgICAgX3RoaXMuaGlkZURyb3Bkb3duKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCBfYltjb25zdGFudHNfMS5TRUxFQ1RfTVVMVElQTEVfVFlQRV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IF90aGlzLmlucHV0LmVsZW1lbnQpIHtcbiAgICAgICAgICBfdGhpcy5jb250YWluZXJPdXRlci5yZW1vdmVGb2N1c1N0YXRlKCk7XG4gICAgICAgICAgX3RoaXMuaGlkZURyb3Bkb3duKHRydWUpO1xuICAgICAgICAgIGlmIChoYXNIaWdobGlnaHRlZEl0ZW1zXzEpIHtcbiAgICAgICAgICAgIF90aGlzLnVuaGlnaGxpZ2h0QWxsKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfYik7XG4gICAgICBibHVyQWN0aW9uc1t0aGlzLnBhc3NlZEVsZW1lbnQuZWxlbWVudC50eXBlXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbiBJRTExLCBjbGlja2luZyB0aGUgc2NvbGxiYXIgYmx1cnMgb3VyIGlucHV0IGFuZCB0aHVzXG4gICAgICAvLyBjbG9zZXMgdGhlIGRyb3Bkb3duLiBUbyBzdG9wIHRoaXMsIHdlIHJlZm9jdXMgb3VyIGlucHV0XG4gICAgICAvLyBpZiB3ZSBrbm93IHdlIGFyZSBvbiBJRSAqYW5kKiBhcmUgc2Nyb2xsaW5nLlxuICAgICAgdGhpcy5faXNTY3JvbGxpbmdPbkllID0gZmFsc2U7XG4gICAgICB0aGlzLmlucHV0LmVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9vbkZvcm1SZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaCgoMCwgbWlzY18xLnJlc2V0VG8pKHRoaXMuX2luaXRpYWxTdGF0ZSkpO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5faGlnaGxpZ2h0Q2hvaWNlID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoZWwgPT09IHZvaWQgMCkge1xuICAgICAgZWwgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgY2hvaWNlcyA9IEFycmF5LmZyb20odGhpcy5kcm9wZG93bi5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWNob2ljZS1zZWxlY3RhYmxlXScpKTtcbiAgICBpZiAoIWNob2ljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXNzZWRFbCA9IGVsO1xuICAgIHZhciBoaWdobGlnaHRlZENob2ljZXMgPSBBcnJheS5mcm9tKHRoaXMuZHJvcGRvd24uZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLlwiLmNvbmNhdCh0aGlzLmNvbmZpZy5jbGFzc05hbWVzLmhpZ2hsaWdodGVkU3RhdGUpKSk7XG4gICAgLy8gUmVtb3ZlIGFueSBoaWdobGlnaHRlZCBjaG9pY2VzXG4gICAgaGlnaGxpZ2h0ZWRDaG9pY2VzLmZvckVhY2goZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgY2hvaWNlLmNsYXNzTGlzdC5yZW1vdmUoX3RoaXMuY29uZmlnLmNsYXNzTmFtZXMuaGlnaGxpZ2h0ZWRTdGF0ZSk7XG4gICAgICBjaG9pY2Uuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgJ2ZhbHNlJyk7XG4gICAgfSk7XG4gICAgaWYgKHBhc3NlZEVsKSB7XG4gICAgICB0aGlzLl9oaWdobGlnaHRQb3NpdGlvbiA9IGNob2ljZXMuaW5kZXhPZihwYXNzZWRFbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhpZ2hsaWdodCBjaG9pY2UgYmFzZWQgb24gbGFzdCBrbm93biBoaWdobGlnaHQgbG9jYXRpb25cbiAgICAgIGlmIChjaG9pY2VzLmxlbmd0aCA+IHRoaXMuX2hpZ2hsaWdodFBvc2l0aW9uKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYW4gb3B0aW9uIHRvIGhpZ2hsaWdodFxuICAgICAgICBwYXNzZWRFbCA9IGNob2ljZXNbdGhpcy5faGlnaGxpZ2h0UG9zaXRpb25dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGhpZ2hsaWdodCB0aGUgb3B0aW9uIGJlZm9yZVxuICAgICAgICBwYXNzZWRFbCA9IGNob2ljZXNbY2hvaWNlcy5sZW5ndGggLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmICghcGFzc2VkRWwpIHtcbiAgICAgICAgcGFzc2VkRWwgPSBjaG9pY2VzWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXNzZWRFbC5jbGFzc0xpc3QuYWRkKHRoaXMuY29uZmlnLmNsYXNzTmFtZXMuaGlnaGxpZ2h0ZWRTdGF0ZSk7XG4gICAgcGFzc2VkRWwuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICB0aGlzLnBhc3NlZEVsZW1lbnQudHJpZ2dlckV2ZW50KGNvbnN0YW50c18xLkVWRU5UUy5oaWdobGlnaHRDaG9pY2UsIHtcbiAgICAgIGVsOiBwYXNzZWRFbFxuICAgIH0pO1xuICAgIGlmICh0aGlzLmRyb3Bkb3duLmlzQWN0aXZlKSB7XG4gICAgICAvLyBJRTExIGlnbm9yZXMgYXJpYS1sYWJlbCBhbmQgYmxvY2tzIHZpcnR1YWwga2V5Ym9hcmRcbiAgICAgIC8vIGlmIGFyaWEtYWN0aXZlZGVzY2VuZGFudCBpcyBzZXQgd2l0aG91dCBhIGRyb3Bkb3duXG4gICAgICB0aGlzLmlucHV0LnNldEFjdGl2ZURlc2NlbmRhbnQocGFzc2VkRWwuaWQpO1xuICAgICAgdGhpcy5jb250YWluZXJPdXRlci5zZXRBY3RpdmVEZXNjZW5kYW50KHBhc3NlZEVsLmlkKTtcbiAgICB9XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9hZGRJdGVtID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHZhbHVlID0gX2EudmFsdWUsXG4gICAgICBfYiA9IF9hLmxhYmVsLFxuICAgICAgbGFiZWwgPSBfYiA9PT0gdm9pZCAwID8gbnVsbCA6IF9iLFxuICAgICAgX2MgPSBfYS5jaG9pY2VJZCxcbiAgICAgIGNob2ljZUlkID0gX2MgPT09IHZvaWQgMCA/IC0xIDogX2MsXG4gICAgICBfZCA9IF9hLmdyb3VwSWQsXG4gICAgICBncm91cElkID0gX2QgPT09IHZvaWQgMCA/IC0xIDogX2QsXG4gICAgICBfZSA9IF9hLmN1c3RvbVByb3BlcnRpZXMsXG4gICAgICBjdXN0b21Qcm9wZXJ0aWVzID0gX2UgPT09IHZvaWQgMCA/IHt9IDogX2UsXG4gICAgICBfZiA9IF9hLnBsYWNlaG9sZGVyLFxuICAgICAgcGxhY2Vob2xkZXIgPSBfZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZixcbiAgICAgIF9nID0gX2Eua2V5Q29kZSxcbiAgICAgIGtleUNvZGUgPSBfZyA9PT0gdm9pZCAwID8gLTEgOiBfZztcbiAgICB2YXIgcGFzc2VkVmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUudHJpbSgpIDogdmFsdWU7XG4gICAgdmFyIGl0ZW1zID0gdGhpcy5fc3RvcmUuaXRlbXM7XG4gICAgdmFyIHBhc3NlZExhYmVsID0gbGFiZWwgfHwgcGFzc2VkVmFsdWU7XG4gICAgdmFyIHBhc3NlZE9wdGlvbklkID0gY2hvaWNlSWQgfHwgLTE7XG4gICAgdmFyIGdyb3VwID0gZ3JvdXBJZCA+PSAwID8gdGhpcy5fc3RvcmUuZ2V0R3JvdXBCeUlkKGdyb3VwSWQpIDogbnVsbDtcbiAgICB2YXIgaWQgPSBpdGVtcyA/IGl0ZW1zLmxlbmd0aCArIDEgOiAxO1xuICAgIC8vIElmIGEgcHJlcGVuZGVkIHZhbHVlIGhhcyBiZWVuIHBhc3NlZCwgcHJlcGVuZCBpdFxuICAgIGlmICh0aGlzLmNvbmZpZy5wcmVwZW5kVmFsdWUpIHtcbiAgICAgIHBhc3NlZFZhbHVlID0gdGhpcy5jb25maWcucHJlcGVuZFZhbHVlICsgcGFzc2VkVmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLy8gSWYgYW4gYXBwZW5kZWQgdmFsdWUgaGFzIGJlZW4gcGFzc2VkLCBhcHBlbmQgaXRcbiAgICBpZiAodGhpcy5jb25maWcuYXBwZW5kVmFsdWUpIHtcbiAgICAgIHBhc3NlZFZhbHVlICs9IHRoaXMuY29uZmlnLmFwcGVuZFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKCgwLCBpdGVtc18xLmFkZEl0ZW0pKHtcbiAgICAgIHZhbHVlOiBwYXNzZWRWYWx1ZSxcbiAgICAgIGxhYmVsOiBwYXNzZWRMYWJlbCxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGNob2ljZUlkOiBwYXNzZWRPcHRpb25JZCxcbiAgICAgIGdyb3VwSWQ6IGdyb3VwSWQsXG4gICAgICBjdXN0b21Qcm9wZXJ0aWVzOiBjdXN0b21Qcm9wZXJ0aWVzLFxuICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAga2V5Q29kZToga2V5Q29kZVxuICAgIH0pKTtcbiAgICBpZiAodGhpcy5faXNTZWxlY3RPbmVFbGVtZW50KSB7XG4gICAgICB0aGlzLnJlbW92ZUFjdGl2ZUl0ZW1zKGlkKTtcbiAgICB9XG4gICAgLy8gVHJpZ2dlciBjaGFuZ2UgZXZlbnRcbiAgICB0aGlzLnBhc3NlZEVsZW1lbnQudHJpZ2dlckV2ZW50KGNvbnN0YW50c18xLkVWRU5UUy5hZGRJdGVtLCB7XG4gICAgICBpZDogaWQsXG4gICAgICB2YWx1ZTogcGFzc2VkVmFsdWUsXG4gICAgICBsYWJlbDogcGFzc2VkTGFiZWwsXG4gICAgICBjdXN0b21Qcm9wZXJ0aWVzOiBjdXN0b21Qcm9wZXJ0aWVzLFxuICAgICAgZ3JvdXBWYWx1ZTogZ3JvdXAgJiYgZ3JvdXAudmFsdWUgPyBncm91cC52YWx1ZSA6IG51bGwsXG4gICAgICBrZXlDb2RlOiBrZXlDb2RlXG4gICAgfSk7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgaWQgPSBpdGVtLmlkLFxuICAgICAgdmFsdWUgPSBpdGVtLnZhbHVlLFxuICAgICAgbGFiZWwgPSBpdGVtLmxhYmVsLFxuICAgICAgY3VzdG9tUHJvcGVydGllcyA9IGl0ZW0uY3VzdG9tUHJvcGVydGllcyxcbiAgICAgIGNob2ljZUlkID0gaXRlbS5jaG9pY2VJZCxcbiAgICAgIGdyb3VwSWQgPSBpdGVtLmdyb3VwSWQ7XG4gICAgdmFyIGdyb3VwID0gZ3JvdXBJZCAmJiBncm91cElkID49IDAgPyB0aGlzLl9zdG9yZS5nZXRHcm91cEJ5SWQoZ3JvdXBJZCkgOiBudWxsO1xuICAgIGlmICghaWQgfHwgIWNob2ljZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKCgwLCBpdGVtc18xLnJlbW92ZUl0ZW0pKGlkLCBjaG9pY2VJZCkpO1xuICAgIHRoaXMucGFzc2VkRWxlbWVudC50cmlnZ2VyRXZlbnQoY29uc3RhbnRzXzEuRVZFTlRTLnJlbW92ZUl0ZW0sIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgIGN1c3RvbVByb3BlcnRpZXM6IGN1c3RvbVByb3BlcnRpZXMsXG4gICAgICBncm91cFZhbHVlOiBncm91cCAmJiBncm91cC52YWx1ZSA/IGdyb3VwLnZhbHVlIDogbnVsbFxuICAgIH0pO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5fYWRkQ2hvaWNlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIHZhbHVlID0gX2EudmFsdWUsXG4gICAgICBfYiA9IF9hLmxhYmVsLFxuICAgICAgbGFiZWwgPSBfYiA9PT0gdm9pZCAwID8gbnVsbCA6IF9iLFxuICAgICAgX2MgPSBfYS5pc1NlbGVjdGVkLFxuICAgICAgaXNTZWxlY3RlZCA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLFxuICAgICAgX2QgPSBfYS5pc0Rpc2FibGVkLFxuICAgICAgaXNEaXNhYmxlZCA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kLFxuICAgICAgX2UgPSBfYS5ncm91cElkLFxuICAgICAgZ3JvdXBJZCA9IF9lID09PSB2b2lkIDAgPyAtMSA6IF9lLFxuICAgICAgX2YgPSBfYS5jdXN0b21Qcm9wZXJ0aWVzLFxuICAgICAgY3VzdG9tUHJvcGVydGllcyA9IF9mID09PSB2b2lkIDAgPyB7fSA6IF9mLFxuICAgICAgX2cgPSBfYS5wbGFjZWhvbGRlcixcbiAgICAgIHBsYWNlaG9sZGVyID0gX2cgPT09IHZvaWQgMCA/IGZhbHNlIDogX2csXG4gICAgICBfaCA9IF9hLmtleUNvZGUsXG4gICAgICBrZXlDb2RlID0gX2ggPT09IHZvaWQgMCA/IC0xIDogX2g7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgdW5pcXVlIGlkXG4gICAgdmFyIGNob2ljZXMgPSB0aGlzLl9zdG9yZS5jaG9pY2VzO1xuICAgIHZhciBjaG9pY2VMYWJlbCA9IGxhYmVsIHx8IHZhbHVlO1xuICAgIHZhciBjaG9pY2VJZCA9IGNob2ljZXMgPyBjaG9pY2VzLmxlbmd0aCArIDEgOiAxO1xuICAgIHZhciBjaG9pY2VFbGVtZW50SWQgPSBcIlwiLmNvbmNhdCh0aGlzLl9iYXNlSWQsIFwiLVwiKS5jb25jYXQodGhpcy5faWROYW1lcy5pdGVtQ2hvaWNlLCBcIi1cIikuY29uY2F0KGNob2ljZUlkKTtcbiAgICB0aGlzLl9zdG9yZS5kaXNwYXRjaCgoMCwgY2hvaWNlc18xLmFkZENob2ljZSkoe1xuICAgICAgaWQ6IGNob2ljZUlkLFxuICAgICAgZ3JvdXBJZDogZ3JvdXBJZCxcbiAgICAgIGVsZW1lbnRJZDogY2hvaWNlRWxlbWVudElkLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgbGFiZWw6IGNob2ljZUxhYmVsLFxuICAgICAgZGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICBjdXN0b21Qcm9wZXJ0aWVzOiBjdXN0b21Qcm9wZXJ0aWVzLFxuICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxuICAgICAga2V5Q29kZToga2V5Q29kZVxuICAgIH0pKTtcbiAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy5fYWRkSXRlbSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbGFiZWw6IGNob2ljZUxhYmVsLFxuICAgICAgICBjaG9pY2VJZDogY2hvaWNlSWQsXG4gICAgICAgIGN1c3RvbVByb3BlcnRpZXM6IGN1c3RvbVByb3BlcnRpZXMsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcbiAgICAgICAga2V5Q29kZToga2V5Q29kZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5fYWRkR3JvdXAgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBncm91cCA9IF9hLmdyb3VwLFxuICAgICAgaWQgPSBfYS5pZCxcbiAgICAgIF9iID0gX2EudmFsdWVLZXksXG4gICAgICB2YWx1ZUtleSA9IF9iID09PSB2b2lkIDAgPyAndmFsdWUnIDogX2IsXG4gICAgICBfYyA9IF9hLmxhYmVsS2V5LFxuICAgICAgbGFiZWxLZXkgPSBfYyA9PT0gdm9pZCAwID8gJ2xhYmVsJyA6IF9jO1xuICAgIHZhciBncm91cENob2ljZXMgPSAoMCwgdXRpbHNfMS5pc1R5cGUpKCdPYmplY3QnLCBncm91cCkgPyBncm91cC5jaG9pY2VzIDogQXJyYXkuZnJvbShncm91cC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnT1BUSU9OJykpO1xuICAgIHZhciBncm91cElkID0gaWQgfHwgTWF0aC5mbG9vcihuZXcgRGF0ZSgpLnZhbHVlT2YoKSAqIE1hdGgucmFuZG9tKCkpO1xuICAgIHZhciBpc0Rpc2FibGVkID0gZ3JvdXAuZGlzYWJsZWQgPyBncm91cC5kaXNhYmxlZCA6IGZhbHNlO1xuICAgIGlmIChncm91cENob2ljZXMpIHtcbiAgICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKCgwLCBncm91cHNfMS5hZGRHcm91cCkoe1xuICAgICAgICB2YWx1ZTogZ3JvdXAubGFiZWwsXG4gICAgICAgIGlkOiBncm91cElkLFxuICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgIGRpc2FibGVkOiBpc0Rpc2FibGVkXG4gICAgICB9KSk7XG4gICAgICB2YXIgYWRkR3JvdXBDaG9pY2VzID0gZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgICB2YXIgaXNPcHREaXNhYmxlZCA9IGNob2ljZS5kaXNhYmxlZCB8fCBjaG9pY2UucGFyZW50Tm9kZSAmJiBjaG9pY2UucGFyZW50Tm9kZS5kaXNhYmxlZDtcbiAgICAgICAgX3RoaXMuX2FkZENob2ljZSh7XG4gICAgICAgICAgdmFsdWU6IGNob2ljZVt2YWx1ZUtleV0sXG4gICAgICAgICAgbGFiZWw6ICgwLCB1dGlsc18xLmlzVHlwZSkoJ09iamVjdCcsIGNob2ljZSkgPyBjaG9pY2VbbGFiZWxLZXldIDogY2hvaWNlLmlubmVySFRNTCxcbiAgICAgICAgICBpc1NlbGVjdGVkOiBjaG9pY2Uuc2VsZWN0ZWQsXG4gICAgICAgICAgaXNEaXNhYmxlZDogaXNPcHREaXNhYmxlZCxcbiAgICAgICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgICAgIGN1c3RvbVByb3BlcnRpZXM6IGNob2ljZS5jdXN0b21Qcm9wZXJ0aWVzLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBjaG9pY2UucGxhY2Vob2xkZXJcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZ3JvdXBDaG9pY2VzLmZvckVhY2goYWRkR3JvdXBDaG9pY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RvcmUuZGlzcGF0Y2goKDAsIGdyb3Vwc18xLmFkZEdyb3VwKSh7XG4gICAgICAgIHZhbHVlOiBncm91cC5sYWJlbCxcbiAgICAgICAgaWQ6IGdyb3VwLmlkLFxuICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICBkaXNhYmxlZDogZ3JvdXAuZGlzYWJsZWRcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9nZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gKF9hID0gdGhpcy5fdGVtcGxhdGVzW3RlbXBsYXRlXSkuY2FsbC5hcHBseShfYSwgX19zcHJlYWRBcnJheShbdGhpcywgdGhpcy5jb25maWddLCBhcmdzLCBmYWxzZSkpO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5fY3JlYXRlVGVtcGxhdGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFja09uQ3JlYXRlVGVtcGxhdGVzID0gdGhpcy5jb25maWcuY2FsbGJhY2tPbkNyZWF0ZVRlbXBsYXRlcztcbiAgICB2YXIgdXNlclRlbXBsYXRlcyA9IHt9O1xuICAgIGlmIChjYWxsYmFja09uQ3JlYXRlVGVtcGxhdGVzICYmIHR5cGVvZiBjYWxsYmFja09uQ3JlYXRlVGVtcGxhdGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1c2VyVGVtcGxhdGVzID0gY2FsbGJhY2tPbkNyZWF0ZVRlbXBsYXRlcy5jYWxsKHRoaXMsIHV0aWxzXzEuc3RyVG9FbCk7XG4gICAgfVxuICAgIHRoaXMuX3RlbXBsYXRlcyA9ICgwLCBkZWVwbWVyZ2VfMS5kZWZhdWx0KSh0ZW1wbGF0ZXNfMS5kZWZhdWx0LCB1c2VyVGVtcGxhdGVzKTtcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX2NyZWF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY29udGFpbmVyT3V0ZXIgPSBuZXcgY29tcG9uZW50c18xLkNvbnRhaW5lcih7XG4gICAgICBlbGVtZW50OiB0aGlzLl9nZXRUZW1wbGF0ZSgnY29udGFpbmVyT3V0ZXInLCB0aGlzLl9kaXJlY3Rpb24sIHRoaXMuX2lzU2VsZWN0RWxlbWVudCwgdGhpcy5faXNTZWxlY3RPbmVFbGVtZW50LCB0aGlzLmNvbmZpZy5zZWFyY2hFbmFibGVkLCB0aGlzLnBhc3NlZEVsZW1lbnQuZWxlbWVudC50eXBlLCB0aGlzLmNvbmZpZy5sYWJlbElkKSxcbiAgICAgIGNsYXNzTmFtZXM6IHRoaXMuY29uZmlnLmNsYXNzTmFtZXMsXG4gICAgICB0eXBlOiB0aGlzLnBhc3NlZEVsZW1lbnQuZWxlbWVudC50eXBlLFxuICAgICAgcG9zaXRpb246IHRoaXMuY29uZmlnLnBvc2l0aW9uXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJJbm5lciA9IG5ldyBjb21wb25lbnRzXzEuQ29udGFpbmVyKHtcbiAgICAgIGVsZW1lbnQ6IHRoaXMuX2dldFRlbXBsYXRlKCdjb250YWluZXJJbm5lcicpLFxuICAgICAgY2xhc3NOYW1lczogdGhpcy5jb25maWcuY2xhc3NOYW1lcyxcbiAgICAgIHR5cGU6IHRoaXMucGFzc2VkRWxlbWVudC5lbGVtZW50LnR5cGUsXG4gICAgICBwb3NpdGlvbjogdGhpcy5jb25maWcucG9zaXRpb25cbiAgICB9KTtcbiAgICB0aGlzLmlucHV0ID0gbmV3IGNvbXBvbmVudHNfMS5JbnB1dCh7XG4gICAgICBlbGVtZW50OiB0aGlzLl9nZXRUZW1wbGF0ZSgnaW5wdXQnLCB0aGlzLl9wbGFjZWhvbGRlclZhbHVlKSxcbiAgICAgIGNsYXNzTmFtZXM6IHRoaXMuY29uZmlnLmNsYXNzTmFtZXMsXG4gICAgICB0eXBlOiB0aGlzLnBhc3NlZEVsZW1lbnQuZWxlbWVudC50eXBlLFxuICAgICAgcHJldmVudFBhc3RlOiAhdGhpcy5jb25maWcucGFzdGVcbiAgICB9KTtcbiAgICB0aGlzLmNob2ljZUxpc3QgPSBuZXcgY29tcG9uZW50c18xLkxpc3Qoe1xuICAgICAgZWxlbWVudDogdGhpcy5fZ2V0VGVtcGxhdGUoJ2Nob2ljZUxpc3QnLCB0aGlzLl9pc1NlbGVjdE9uZUVsZW1lbnQpXG4gICAgfSk7XG4gICAgdGhpcy5pdGVtTGlzdCA9IG5ldyBjb21wb25lbnRzXzEuTGlzdCh7XG4gICAgICBlbGVtZW50OiB0aGlzLl9nZXRUZW1wbGF0ZSgnaXRlbUxpc3QnLCB0aGlzLl9pc1NlbGVjdE9uZUVsZW1lbnQpXG4gICAgfSk7XG4gICAgdGhpcy5kcm9wZG93biA9IG5ldyBjb21wb25lbnRzXzEuRHJvcGRvd24oe1xuICAgICAgZWxlbWVudDogdGhpcy5fZ2V0VGVtcGxhdGUoJ2Ryb3Bkb3duJyksXG4gICAgICBjbGFzc05hbWVzOiB0aGlzLmNvbmZpZy5jbGFzc05hbWVzLFxuICAgICAgdHlwZTogdGhpcy5wYXNzZWRFbGVtZW50LmVsZW1lbnQudHlwZVxuICAgIH0pO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5fY3JlYXRlU3RydWN0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEhpZGUgb3JpZ2luYWwgZWxlbWVudFxuICAgIHRoaXMucGFzc2VkRWxlbWVudC5jb25jZWFsKCk7XG4gICAgLy8gV3JhcCBpbnB1dCBpbiBjb250YWluZXIgcHJlc2VydmluZyBET00gb3JkZXJpbmdcbiAgICB0aGlzLmNvbnRhaW5lcklubmVyLndyYXAodGhpcy5wYXNzZWRFbGVtZW50LmVsZW1lbnQpO1xuICAgIC8vIFdyYXBwZXIgaW5uZXIgY29udGFpbmVyIHdpdGggb3V0ZXIgY29udGFpbmVyXG4gICAgdGhpcy5jb250YWluZXJPdXRlci53cmFwKHRoaXMuY29udGFpbmVySW5uZXIuZWxlbWVudCk7XG4gICAgaWYgKHRoaXMuX2lzU2VsZWN0T25lRWxlbWVudCkge1xuICAgICAgdGhpcy5pbnB1dC5wbGFjZWhvbGRlciA9IHRoaXMuY29uZmlnLnNlYXJjaFBsYWNlaG9sZGVyVmFsdWUgfHwgJyc7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wbGFjZWhvbGRlclZhbHVlKSB7XG4gICAgICB0aGlzLmlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5fcGxhY2Vob2xkZXJWYWx1ZTtcbiAgICAgIHRoaXMuaW5wdXQuc2V0V2lkdGgoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXJPdXRlci5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVySW5uZXIuZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXJPdXRlci5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZHJvcGRvd24uZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXJJbm5lci5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaXRlbUxpc3QuZWxlbWVudCk7XG4gICAgaWYgKCF0aGlzLl9pc1RleHRFbGVtZW50KSB7XG4gICAgICB0aGlzLmRyb3Bkb3duLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jaG9pY2VMaXN0LmVsZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2lzU2VsZWN0T25lRWxlbWVudCkge1xuICAgICAgdGhpcy5jb250YWluZXJJbm5lci5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaW5wdXQuZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNvbmZpZy5zZWFyY2hFbmFibGVkKSB7XG4gICAgICB0aGlzLmRyb3Bkb3duLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuaW5wdXQuZWxlbWVudCwgdGhpcy5kcm9wZG93bi5lbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNTZWxlY3RFbGVtZW50KSB7XG4gICAgICB0aGlzLl9oaWdobGlnaHRQb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLl9pc1NlYXJjaGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fc3RhcnRMb2FkaW5nKCk7XG4gICAgICBpZiAodGhpcy5fcHJlc2V0R3JvdXBzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9hZGRQcmVkZWZpbmVkR3JvdXBzKHRoaXMuX3ByZXNldEdyb3Vwcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hZGRQcmVkZWZpbmVkQ2hvaWNlcyh0aGlzLl9wcmVzZXRDaG9pY2VzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0b3BMb2FkaW5nKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc1RleHRFbGVtZW50KSB7XG4gICAgICB0aGlzLl9hZGRQcmVkZWZpbmVkSXRlbXModGhpcy5fcHJlc2V0SXRlbXMpO1xuICAgIH1cbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX2FkZFByZWRlZmluZWRHcm91cHMgPSBmdW5jdGlvbiAoZ3JvdXBzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBJZiB3ZSBoYXZlIGEgcGxhY2Vob2xkZXIgb3B0aW9uXG4gICAgdmFyIHBsYWNlaG9sZGVyQ2hvaWNlID0gdGhpcy5wYXNzZWRFbGVtZW50LnBsYWNlaG9sZGVyT3B0aW9uO1xuICAgIGlmIChwbGFjZWhvbGRlckNob2ljZSAmJiBwbGFjZWhvbGRlckNob2ljZS5wYXJlbnROb2RlICYmIHBsYWNlaG9sZGVyQ2hvaWNlLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgIHRoaXMuX2FkZENob2ljZSh7XG4gICAgICAgIHZhbHVlOiBwbGFjZWhvbGRlckNob2ljZS52YWx1ZSxcbiAgICAgICAgbGFiZWw6IHBsYWNlaG9sZGVyQ2hvaWNlLmlubmVySFRNTCxcbiAgICAgICAgaXNTZWxlY3RlZDogcGxhY2Vob2xkZXJDaG9pY2Uuc2VsZWN0ZWQsXG4gICAgICAgIGlzRGlzYWJsZWQ6IHBsYWNlaG9sZGVyQ2hvaWNlLmRpc2FibGVkLFxuICAgICAgICBwbGFjZWhvbGRlcjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgcmV0dXJuIF90aGlzLl9hZGRHcm91cCh7XG4gICAgICAgIGdyb3VwOiBncm91cCxcbiAgICAgICAgaWQ6IGdyb3VwLmlkIHx8IG51bGxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5fYWRkUHJlZGVmaW5lZENob2ljZXMgPSBmdW5jdGlvbiAoY2hvaWNlcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gSWYgc29ydGluZyBpcyBlbmFibGVkIG9yIHRoZSB1c2VyIGlzIHNlYXJjaGluZywgZmlsdGVyIGNob2ljZXNcbiAgICBpZiAodGhpcy5jb25maWcuc2hvdWxkU29ydCkge1xuICAgICAgY2hvaWNlcy5zb3J0KHRoaXMuY29uZmlnLnNvcnRlcik7XG4gICAgfVxuICAgIHZhciBoYXNTZWxlY3RlZENob2ljZSA9IGNob2ljZXMuc29tZShmdW5jdGlvbiAoY2hvaWNlKSB7XG4gICAgICByZXR1cm4gY2hvaWNlLnNlbGVjdGVkO1xuICAgIH0pO1xuICAgIHZhciBmaXJzdEVuYWJsZWRDaG9pY2VJbmRleCA9IGNob2ljZXMuZmluZEluZGV4KGZ1bmN0aW9uIChjaG9pY2UpIHtcbiAgICAgIHJldHVybiBjaG9pY2UuZGlzYWJsZWQgPT09IHVuZGVmaW5lZCB8fCAhY2hvaWNlLmRpc2FibGVkO1xuICAgIH0pO1xuICAgIGNob2ljZXMuZm9yRWFjaChmdW5jdGlvbiAoY2hvaWNlLCBpbmRleCkge1xuICAgICAgdmFyIF9hID0gY2hvaWNlLnZhbHVlLFxuICAgICAgICB2YWx1ZSA9IF9hID09PSB2b2lkIDAgPyAnJyA6IF9hLFxuICAgICAgICBsYWJlbCA9IGNob2ljZS5sYWJlbCxcbiAgICAgICAgY3VzdG9tUHJvcGVydGllcyA9IGNob2ljZS5jdXN0b21Qcm9wZXJ0aWVzLFxuICAgICAgICBwbGFjZWhvbGRlciA9IGNob2ljZS5wbGFjZWhvbGRlcjtcbiAgICAgIGlmIChfdGhpcy5faXNTZWxlY3RFbGVtZW50KSB7XG4gICAgICAgIC8vIElmIHRoZSBjaG9pY2UgaXMgYWN0dWFsbHkgYSBncm91cFxuICAgICAgICBpZiAoY2hvaWNlLmNob2ljZXMpIHtcbiAgICAgICAgICBfdGhpcy5fYWRkR3JvdXAoe1xuICAgICAgICAgICAgZ3JvdXA6IGNob2ljZSxcbiAgICAgICAgICAgIGlkOiBjaG9pY2UuaWQgfHwgbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgY2hvaWNlIGFscmVhZHkgb3IgdGhlIGNob2ljZSBpcyBub3QgdGhlIGZpcnN0IGluXG4gICAgICAgICAgICogdGhlIGFycmF5LCBhZGQgZWFjaCBjaG9pY2Ugbm9ybWFsbHkuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBPdGhlcndpc2Ugd2UgcHJlLXNlbGVjdCB0aGUgZmlyc3QgZW5hYmxlZCBjaG9pY2UgaW4gdGhlIGFycmF5IChcInNlbGVjdC1vbmVcIiBvbmx5KVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHZhciBzaG91bGRQcmVzZWxlY3QgPSBfdGhpcy5faXNTZWxlY3RPbmVFbGVtZW50ICYmICFoYXNTZWxlY3RlZENob2ljZSAmJiBpbmRleCA9PT0gZmlyc3RFbmFibGVkQ2hvaWNlSW5kZXg7XG4gICAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBzaG91bGRQcmVzZWxlY3QgPyB0cnVlIDogY2hvaWNlLnNlbGVjdGVkO1xuICAgICAgICAgIHZhciBpc0Rpc2FibGVkID0gY2hvaWNlLmRpc2FibGVkO1xuICAgICAgICAgIF90aGlzLl9hZGRDaG9pY2Uoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLFxuICAgICAgICAgICAgaXNTZWxlY3RlZDogISFpc1NlbGVjdGVkLFxuICAgICAgICAgICAgaXNEaXNhYmxlZDogISFpc0Rpc2FibGVkLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICEhcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBjdXN0b21Qcm9wZXJ0aWVzOiBjdXN0b21Qcm9wZXJ0aWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl9hZGRDaG9pY2Uoe1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBsYWJlbDogbGFiZWwsXG4gICAgICAgICAgaXNTZWxlY3RlZDogISFjaG9pY2Uuc2VsZWN0ZWQsXG4gICAgICAgICAgaXNEaXNhYmxlZDogISFjaG9pY2UuZGlzYWJsZWQsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6ICEhY2hvaWNlLnBsYWNlaG9sZGVyLFxuICAgICAgICAgIGN1c3RvbVByb3BlcnRpZXM6IGN1c3RvbVByb3BlcnRpZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9hZGRQcmVkZWZpbmVkSXRlbXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgaXRlbS52YWx1ZSkge1xuICAgICAgICBfdGhpcy5fYWRkSXRlbSh7XG4gICAgICAgICAgdmFsdWU6IGl0ZW0udmFsdWUsXG4gICAgICAgICAgbGFiZWw6IGl0ZW0ubGFiZWwsXG4gICAgICAgICAgY2hvaWNlSWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgY3VzdG9tUHJvcGVydGllczogaXRlbS5jdXN0b21Qcm9wZXJ0aWVzLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBpdGVtLnBsYWNlaG9sZGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgICAgICBfdGhpcy5fYWRkSXRlbSh7XG4gICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIENob2ljZXMucHJvdG90eXBlLl9zZXRDaG9pY2VPckl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGl0ZW1UeXBlID0gKDAsIHV0aWxzXzEuZ2V0VHlwZSkoaXRlbSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgaGFuZGxlVHlwZSA9IHtcbiAgICAgIG9iamVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWl0ZW0udmFsdWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBhIHNlbGVjdCBpbnB1dCwgd2UgbmVlZCB0byBjcmVhdGUgYW4gb3B0aW9uIGZpcnN0XG4gICAgICAgIC8vIHRoYXQgaXMgdGhlbiBzZWxlY3RlZC4gRm9yIHRleHQgaW5wdXRzIHdlIGNhbiBqdXN0IGFkZCBpdGVtcyBub3JtYWxseS5cbiAgICAgICAgaWYgKCFfdGhpcy5faXNUZXh0RWxlbWVudCkge1xuICAgICAgICAgIF90aGlzLl9hZGRDaG9pY2Uoe1xuICAgICAgICAgICAgdmFsdWU6IGl0ZW0udmFsdWUsXG4gICAgICAgICAgICBsYWJlbDogaXRlbS5sYWJlbCxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpc0Rpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGN1c3RvbVByb3BlcnRpZXM6IGl0ZW0uY3VzdG9tUHJvcGVydGllcyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBpdGVtLnBsYWNlaG9sZGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuX2FkZEl0ZW0oe1xuICAgICAgICAgICAgdmFsdWU6IGl0ZW0udmFsdWUsXG4gICAgICAgICAgICBsYWJlbDogaXRlbS5sYWJlbCxcbiAgICAgICAgICAgIGNob2ljZUlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgY3VzdG9tUHJvcGVydGllczogaXRlbS5jdXN0b21Qcm9wZXJ0aWVzLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IGl0ZW0ucGxhY2Vob2xkZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN0cmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzLl9pc1RleHRFbGVtZW50KSB7XG4gICAgICAgICAgX3RoaXMuX2FkZENob2ljZSh7XG4gICAgICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgICAgIGxhYmVsOiBpdGVtLFxuICAgICAgICAgICAgaXNTZWxlY3RlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlzRGlzYWJsZWQ6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuX2FkZEl0ZW0oe1xuICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaGFuZGxlVHlwZVtpdGVtVHlwZV0oKTtcbiAgfTtcbiAgQ2hvaWNlcy5wcm90b3R5cGUuX2ZpbmRBbmRTZWxlY3RDaG9pY2VCeVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgY2hvaWNlcyA9IHRoaXMuX3N0b3JlLmNob2ljZXM7XG4gICAgLy8gQ2hlY2sgJ3ZhbHVlJyBwcm9wZXJ0eSBleGlzdHMgYW5kIHRoZSBjaG9pY2UgaXNuJ3QgYWxyZWFkeSBzZWxlY3RlZFxuICAgIHZhciBmb3VuZENob2ljZSA9IGNob2ljZXMuZmluZChmdW5jdGlvbiAoY2hvaWNlKSB7XG4gICAgICByZXR1cm4gX3RoaXMuY29uZmlnLnZhbHVlQ29tcGFyZXIoY2hvaWNlLnZhbHVlLCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgaWYgKGZvdW5kQ2hvaWNlICYmICFmb3VuZENob2ljZS5zZWxlY3RlZCkge1xuICAgICAgdGhpcy5fYWRkSXRlbSh7XG4gICAgICAgIHZhbHVlOiBmb3VuZENob2ljZS52YWx1ZSxcbiAgICAgICAgbGFiZWw6IGZvdW5kQ2hvaWNlLmxhYmVsLFxuICAgICAgICBjaG9pY2VJZDogZm91bmRDaG9pY2UuaWQsXG4gICAgICAgIGdyb3VwSWQ6IGZvdW5kQ2hvaWNlLmdyb3VwSWQsXG4gICAgICAgIGN1c3RvbVByb3BlcnRpZXM6IGZvdW5kQ2hvaWNlLmN1c3RvbVByb3BlcnRpZXMsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBmb3VuZENob2ljZS5wbGFjZWhvbGRlcixcbiAgICAgICAga2V5Q29kZTogZm91bmRDaG9pY2Uua2V5Q29kZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBDaG9pY2VzLnByb3RvdHlwZS5fZ2VuZXJhdGVQbGFjZWhvbGRlclZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pc1NlbGVjdEVsZW1lbnQgJiYgdGhpcy5wYXNzZWRFbGVtZW50LnBsYWNlaG9sZGVyT3B0aW9uKSB7XG4gICAgICB2YXIgcGxhY2Vob2xkZXJPcHRpb24gPSB0aGlzLnBhc3NlZEVsZW1lbnQucGxhY2Vob2xkZXJPcHRpb247XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXJPcHRpb24gPyBwbGFjZWhvbGRlck9wdGlvbi50ZXh0IDogbnVsbDtcbiAgICB9XG4gICAgdmFyIF9hID0gdGhpcy5jb25maWcsXG4gICAgICBwbGFjZWhvbGRlciA9IF9hLnBsYWNlaG9sZGVyLFxuICAgICAgcGxhY2Vob2xkZXJWYWx1ZSA9IF9hLnBsYWNlaG9sZGVyVmFsdWU7XG4gICAgdmFyIGRhdGFzZXQgPSB0aGlzLnBhc3NlZEVsZW1lbnQuZWxlbWVudC5kYXRhc2V0O1xuICAgIGlmIChwbGFjZWhvbGRlcikge1xuICAgICAgaWYgKHBsYWNlaG9sZGVyVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YXNldC5wbGFjZWhvbGRlcikge1xuICAgICAgICByZXR1cm4gZGF0YXNldC5wbGFjZWhvbGRlcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIHJldHVybiBDaG9pY2VzO1xufSgpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDaG9pY2VzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNjEzOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG52YXIgdXRpbHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNzk5KTtcbnZhciBjb25zdGFudHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oODgzKTtcbnZhciBDb250YWluZXIgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250YWluZXIoX2EpIHtcbiAgICB2YXIgZWxlbWVudCA9IF9hLmVsZW1lbnQsXG4gICAgICB0eXBlID0gX2EudHlwZSxcbiAgICAgIGNsYXNzTmFtZXMgPSBfYS5jbGFzc05hbWVzLFxuICAgICAgcG9zaXRpb24gPSBfYS5wb3NpdGlvbjtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICB0aGlzLmlzRmxpcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNGb2N1c3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fb25Gb2N1cyA9IHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkJsdXIgPSB0aGlzLl9vbkJsdXIuYmluZCh0aGlzKTtcbiAgfVxuICBDb250YWluZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXMpO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fb25CbHVyKTtcbiAgfTtcbiAgQ29udGFpbmVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9vbkZvY3VzKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX29uQmx1cik7XG4gIH07XG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBjb250YWluZXIgc2hvdWxkIGJlIGZsaXBwZWQgYmFzZWQgb24gcGFzc2VkXG4gICAqIGRyb3Bkb3duIHBvc2l0aW9uXG4gICAqL1xuICBDb250YWluZXIucHJvdG90eXBlLnNob3VsZEZsaXAgPSBmdW5jdGlvbiAoZHJvcGRvd25Qb3MpIHtcbiAgICBpZiAodHlwZW9mIGRyb3Bkb3duUG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJZiBmbGlwIGlzIGVuYWJsZWQgYW5kIHRoZSBkcm9wZG93biBib3R0b20gcG9zaXRpb24gaXNcbiAgICAvLyBncmVhdGVyIHRoYW4gdGhlIHdpbmRvdyBoZWlnaHQgZmxpcCB0aGUgZHJvcGRvd24uXG4gICAgdmFyIHNob3VsZEZsaXAgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgICBzaG91bGRGbGlwID0gIXdpbmRvdy5tYXRjaE1lZGlhKFwiKG1pbi1oZWlnaHQ6IFwiLmNvbmNhdChkcm9wZG93blBvcyArIDEsIFwicHgpXCIpKS5tYXRjaGVzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHNob3VsZEZsaXAgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkRmxpcDtcbiAgfTtcbiAgQ29udGFpbmVyLnByb3RvdHlwZS5zZXRBY3RpdmVEZXNjZW5kYW50ID0gZnVuY3Rpb24gKGFjdGl2ZURlc2NlbmRhbnRJRCkge1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIGFjdGl2ZURlc2NlbmRhbnRJRCk7XG4gIH07XG4gIENvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlQWN0aXZlRGVzY2VuZGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcbiAgfTtcbiAgQ29udGFpbmVyLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKGRyb3Bkb3duUG9zKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLm9wZW5TdGF0ZSk7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgIGlmICh0aGlzLnNob3VsZEZsaXAoZHJvcGRvd25Qb3MpKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMuZmxpcHBlZFN0YXRlKTtcbiAgICAgIHRoaXMuaXNGbGlwcGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIENvbnRhaW5lci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLm9wZW5TdGF0ZSk7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgIHRoaXMucmVtb3ZlQWN0aXZlRGVzY2VuZGFudCgpO1xuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgLy8gQSBkcm9wZG93biBmbGlwcyBpZiBpdCBkb2VzIG5vdCBoYXZlIHNwYWNlIHdpdGhpbiB0aGUgcGFnZVxuICAgIGlmICh0aGlzLmlzRmxpcHBlZCkge1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLmZsaXBwZWRTdGF0ZSk7XG4gICAgICB0aGlzLmlzRmxpcHBlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgQ29udGFpbmVyLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNGb2N1c3NlZCkge1xuICAgICAgdGhpcy5lbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICB9O1xuICBDb250YWluZXIucHJvdG90eXBlLmFkZEZvY3VzU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLmZvY3VzU3RhdGUpO1xuICB9O1xuICBDb250YWluZXIucHJvdG90eXBlLnJlbW92ZUZvY3VzU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLmZvY3VzU3RhdGUpO1xuICB9O1xuICBDb250YWluZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmNsYXNzTmFtZXMuZGlzYWJsZWRTdGF0ZSk7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IGNvbnN0YW50c18xLlNFTEVDVF9PTkVfVFlQRSkge1xuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuICAgIH1cbiAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgfTtcbiAgQ29udGFpbmVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5kaXNhYmxlZFN0YXRlKTtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICBpZiAodGhpcy50eXBlID09PSBjb25zdGFudHNfMS5TRUxFQ1RfT05FX1RZUEUpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgfVxuICAgIHRoaXMuaXNEaXNhYmxlZCA9IHRydWU7XG4gIH07XG4gIENvbnRhaW5lci5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgKDAsIHV0aWxzXzEud3JhcCkoZWxlbWVudCwgdGhpcy5lbGVtZW50KTtcbiAgfTtcbiAgQ29udGFpbmVyLnByb3RvdHlwZS51bndyYXAgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgLy8gTW92ZSBwYXNzZWQgZWxlbWVudCBvdXRzaWRlIHRoaXMgZWxlbWVudFxuICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIHRoaXMuZWxlbWVudCk7XG4gICAgICAvLyBSZW1vdmUgdGhpcyBlbGVtZW50XG4gICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIH1cbiAgfTtcbiAgQ29udGFpbmVyLnByb3RvdHlwZS5hZGRMb2FkaW5nU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLmxvYWRpbmdTdGF0ZSk7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1idXN5JywgJ3RydWUnKTtcbiAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG4gIH07XG4gIENvbnRhaW5lci5wcm90b3R5cGUucmVtb3ZlTG9hZGluZ1N0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY2xhc3NOYW1lcy5sb2FkaW5nU3RhdGUpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYnVzeScpO1xuICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gIH07XG4gIENvbnRhaW5lci5wcm90b3R5cGUuX29uRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc0ZvY3Vzc2VkID0gdHJ1ZTtcbiAgfTtcbiAgQ29udGFpbmVyLnByb3RvdHlwZS5fb25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNGb2N1c3NlZCA9IGZhbHNlO1xuICB9O1xuICByZXR1cm4gQ29udGFpbmVyO1xufSgpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb250YWluZXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMTc6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbnZhciBEcm9wZG93biA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERyb3Bkb3duKF9hKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBfYS5lbGVtZW50LFxuICAgICAgdHlwZSA9IF9hLnR5cGUsXG4gICAgICBjbGFzc05hbWVzID0gX2EuY2xhc3NOYW1lcztcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERyb3Bkb3duLnByb3RvdHlwZSwgXCJkaXN0YW5jZUZyb21Ub3BXaW5kb3dcIiwge1xuICAgIC8qKlxuICAgICAqIEJvdHRvbSBwb3NpdGlvbiBvZiBkcm9wZG93biBpbiB2aWV3cG9ydCBjb29yZGluYXRlc1xuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b207XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIERyb3Bkb3duLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG4gIC8qKlxuICAgKiBTaG93IGRyb3Bkb3duIHRvIHVzZXIgYnkgYWRkaW5nIGFjdGl2ZSBzdGF0ZSBjbGFzc1xuICAgKi9cbiAgRHJvcGRvd24ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLmFjdGl2ZVN0YXRlKTtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEhpZGUgZHJvcGRvd24gZnJvbSB1c2VyXG4gICAqL1xuICBEcm9wZG93bi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmNsYXNzTmFtZXMuYWN0aXZlU3RhdGUpO1xuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIHJldHVybiBEcm9wZG93bjtcbn0oKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRHJvcGRvd247XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MjA6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbnZhciBfX2ltcG9ydERlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5XcmFwcGVkU2VsZWN0ID0gZXhwb3J0cy5XcmFwcGVkSW5wdXQgPSBleHBvcnRzLkxpc3QgPSBleHBvcnRzLklucHV0ID0gZXhwb3J0cy5Db250YWluZXIgPSBleHBvcnRzLkRyb3Bkb3duID0gdm9pZCAwO1xudmFyIGRyb3Bkb3duXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMTcpKTtcbmV4cG9ydHMuRHJvcGRvd24gPSBkcm9wZG93bl8xLmRlZmF1bHQ7XG52YXIgY29udGFpbmVyXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2MTMpKTtcbmV4cG9ydHMuQ29udGFpbmVyID0gY29udGFpbmVyXzEuZGVmYXVsdDtcbnZhciBpbnB1dF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTEpKTtcbmV4cG9ydHMuSW5wdXQgPSBpbnB1dF8xLmRlZmF1bHQ7XG52YXIgbGlzdF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNjI0KSk7XG5leHBvcnRzLkxpc3QgPSBsaXN0XzEuZGVmYXVsdDtcbnZhciB3cmFwcGVkX2lucHV0XzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg1NDEpKTtcbmV4cG9ydHMuV3JhcHBlZElucHV0ID0gd3JhcHBlZF9pbnB1dF8xLmRlZmF1bHQ7XG52YXIgd3JhcHBlZF9zZWxlY3RfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MikpO1xuZXhwb3J0cy5XcmFwcGVkU2VsZWN0ID0gd3JhcHBlZF9zZWxlY3RfMS5kZWZhdWx0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTE6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbnZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTkpO1xudmFyIGNvbnN0YW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODMpO1xudmFyIElucHV0ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW5wdXQoX2EpIHtcbiAgICB2YXIgZWxlbWVudCA9IF9hLmVsZW1lbnQsXG4gICAgICB0eXBlID0gX2EudHlwZSxcbiAgICAgIGNsYXNzTmFtZXMgPSBfYS5jbGFzc05hbWVzLFxuICAgICAgcHJldmVudFBhc3RlID0gX2EucHJldmVudFBhc3RlO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuICAgIHRoaXMucHJldmVudFBhc3RlID0gcHJldmVudFBhc3RlO1xuICAgIHRoaXMuaXNGb2N1c3NlZCA9IHRoaXMuZWxlbWVudC5pc0VxdWFsTm9kZShkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICB0aGlzLmlzRGlzYWJsZWQgPSBlbGVtZW50LmRpc2FibGVkO1xuICAgIHRoaXMuX29uUGFzdGUgPSB0aGlzLl9vblBhc3RlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25JbnB1dCA9IHRoaXMuX29uSW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkZvY3VzID0gdGhpcy5fb25Gb2N1cy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQmx1ciA9IHRoaXMuX29uQmx1ci5iaW5kKHRoaXMpO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwge1xuICAgIHNldDogZnVuY3Rpb24gKHBsYWNlaG9sZGVyKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElucHV0LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKDAsIHV0aWxzXzEuc2FuaXRpc2UpKHRoaXMuZWxlbWVudC52YWx1ZSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy5lbGVtZW50LnZhbHVlID0gdmFsdWU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dC5wcm90b3R5cGUsIFwicmF3VmFsdWVcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC52YWx1ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgSW5wdXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIHRoaXMuX29uUGFzdGUpO1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uSW5wdXQsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9vbkZvY3VzLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLl9vbkJsdXIsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgfTtcbiAgSW5wdXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX29uSW5wdXQpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwYXN0ZScsIHRoaXMuX29uUGFzdGUpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXMpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fb25CbHVyKTtcbiAgfTtcbiAgSW5wdXQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgIHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICB9O1xuICBJbnB1dC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICcnKTtcbiAgICB0aGlzLmlzRGlzYWJsZWQgPSB0cnVlO1xuICB9O1xuICBJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRm9jdXNzZWQpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgfTtcbiAgSW5wdXQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNGb2N1c3NlZCkge1xuICAgICAgdGhpcy5lbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH07XG4gIElucHV0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChzZXRXaWR0aCkge1xuICAgIGlmIChzZXRXaWR0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBzZXRXaWR0aCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsZW1lbnQudmFsdWUpIHtcbiAgICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9ICcnO1xuICAgIH1cbiAgICBpZiAoc2V0V2lkdGgpIHtcbiAgICAgIHRoaXMuc2V0V2lkdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBTZXQgdGhlIGNvcnJlY3QgaW5wdXQgd2lkdGggYmFzZWQgb24gcGxhY2Vob2xkZXJcbiAgICogdmFsdWUgb3IgaW5wdXQgdmFsdWVcbiAgICovXG4gIElucHV0LnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZXNpemUgaW5wdXQgdG8gY29udGVudHMgb3IgcGxhY2Vob2xkZXJcbiAgICB2YXIgX2EgPSB0aGlzLmVsZW1lbnQsXG4gICAgICBzdHlsZSA9IF9hLnN0eWxlLFxuICAgICAgdmFsdWUgPSBfYS52YWx1ZSxcbiAgICAgIHBsYWNlaG9sZGVyID0gX2EucGxhY2Vob2xkZXI7XG4gICAgc3R5bGUubWluV2lkdGggPSBcIlwiLmNvbmNhdChwbGFjZWhvbGRlci5sZW5ndGggKyAxLCBcImNoXCIpO1xuICAgIHN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQodmFsdWUubGVuZ3RoICsgMSwgXCJjaFwiKTtcbiAgfTtcbiAgSW5wdXQucHJvdG90eXBlLnNldEFjdGl2ZURlc2NlbmRhbnQgPSBmdW5jdGlvbiAoYWN0aXZlRGVzY2VuZGFudElEKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgYWN0aXZlRGVzY2VuZGFudElEKTtcbiAgfTtcbiAgSW5wdXQucHJvdG90eXBlLnJlbW92ZUFjdGl2ZURlc2NlbmRhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyk7XG4gIH07XG4gIElucHV0LnByb3RvdHlwZS5fb25JbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50eXBlICE9PSBjb25zdGFudHNfMS5TRUxFQ1RfT05FX1RZUEUpIHtcbiAgICAgIHRoaXMuc2V0V2lkdGgoKTtcbiAgICB9XG4gIH07XG4gIElucHV0LnByb3RvdHlwZS5fb25QYXN0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICh0aGlzLnByZXZlbnRQYXN0ZSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG4gIElucHV0LnByb3RvdHlwZS5fb25Gb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzRm9jdXNzZWQgPSB0cnVlO1xuICB9O1xuICBJbnB1dC5wcm90b3R5cGUuX29uQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzRm9jdXNzZWQgPSBmYWxzZTtcbiAgfTtcbiAgcmV0dXJuIElucHV0O1xufSgpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBJbnB1dDtcblxuLyoqKi8gfSksXG5cbi8qKiovIDYyNDpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xudmFyIGNvbnN0YW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODMpO1xudmFyIExpc3QgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaXN0KF9hKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBfYS5lbGVtZW50O1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5zY3JvbGxQb3MgPSB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgfVxuICBMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XG4gIH07XG4gIExpc3QucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICB9O1xuICBMaXN0LnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH07XG4gIExpc3QucHJvdG90eXBlLmhhc0NoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaGFzQ2hpbGROb2RlcygpO1xuICB9O1xuICBMaXN0LnByb3RvdHlwZS5zY3JvbGxUb1RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgfTtcbiAgTGlzdC5wcm90b3R5cGUuc2Nyb2xsVG9DaGlsZEVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxpc3RIZWlnaHQgPSB0aGlzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIC8vIFNjcm9sbCBwb3NpdGlvbiBvZiBkcm9wZG93blxuICAgIHZhciBsaXN0U2Nyb2xsUG9zaXRpb24gPSB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wICsgbGlzdEhlaWdodDtcbiAgICB2YXIgZWxlbWVudEhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIC8vIERpc3RhbmNlIGZyb20gYm90dG9tIG9mIGVsZW1lbnQgdG8gdG9wIG9mIHBhcmVudFxuICAgIHZhciBlbGVtZW50UG9zID0gZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50SGVpZ2h0O1xuICAgIC8vIERpZmZlcmVuY2UgYmV0d2VlbiB0aGUgZWxlbWVudCBhbmQgc2Nyb2xsIHBvc2l0aW9uXG4gICAgdmFyIGRlc3RpbmF0aW9uID0gZGlyZWN0aW9uID4gMCA/IHRoaXMuZWxlbWVudC5zY3JvbGxUb3AgKyBlbGVtZW50UG9zIC0gbGlzdFNjcm9sbFBvc2l0aW9uIDogZWxlbWVudC5vZmZzZXRUb3A7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9hbmltYXRlU2Nyb2xsKGRlc3RpbmF0aW9uLCBkaXJlY3Rpb24pO1xuICAgIH0pO1xuICB9O1xuICBMaXN0LnByb3RvdHlwZS5fc2Nyb2xsRG93biA9IGZ1bmN0aW9uIChzY3JvbGxQb3MsIHN0cmVuZ3RoLCBkZXN0aW5hdGlvbikge1xuICAgIHZhciBlYXNpbmcgPSAoZGVzdGluYXRpb24gLSBzY3JvbGxQb3MpIC8gc3RyZW5ndGg7XG4gICAgdmFyIGRpc3RhbmNlID0gZWFzaW5nID4gMSA/IGVhc2luZyA6IDE7XG4gICAgdGhpcy5lbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFBvcyArIGRpc3RhbmNlO1xuICB9O1xuICBMaXN0LnByb3RvdHlwZS5fc2Nyb2xsVXAgPSBmdW5jdGlvbiAoc2Nyb2xsUG9zLCBzdHJlbmd0aCwgZGVzdGluYXRpb24pIHtcbiAgICB2YXIgZWFzaW5nID0gKHNjcm9sbFBvcyAtIGRlc3RpbmF0aW9uKSAvIHN0cmVuZ3RoO1xuICAgIHZhciBkaXN0YW5jZSA9IGVhc2luZyA+IDEgPyBlYXNpbmcgOiAxO1xuICAgIHRoaXMuZWxlbWVudC5zY3JvbGxUb3AgPSBzY3JvbGxQb3MgLSBkaXN0YW5jZTtcbiAgfTtcbiAgTGlzdC5wcm90b3R5cGUuX2FuaW1hdGVTY3JvbGwgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIGRpcmVjdGlvbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIHN0cmVuZ3RoID0gY29uc3RhbnRzXzEuU0NST0xMSU5HX1NQRUVEO1xuICAgIHZhciBjaG9pY2VMaXN0U2Nyb2xsVG9wID0gdGhpcy5lbGVtZW50LnNjcm9sbFRvcDtcbiAgICB2YXIgY29udGludWVBbmltYXRpb24gPSBmYWxzZTtcbiAgICBpZiAoZGlyZWN0aW9uID4gMCkge1xuICAgICAgdGhpcy5fc2Nyb2xsRG93bihjaG9pY2VMaXN0U2Nyb2xsVG9wLCBzdHJlbmd0aCwgZGVzdGluYXRpb24pO1xuICAgICAgaWYgKGNob2ljZUxpc3RTY3JvbGxUb3AgPCBkZXN0aW5hdGlvbikge1xuICAgICAgICBjb250aW51ZUFuaW1hdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Njcm9sbFVwKGNob2ljZUxpc3RTY3JvbGxUb3AsIHN0cmVuZ3RoLCBkZXN0aW5hdGlvbik7XG4gICAgICBpZiAoY2hvaWNlTGlzdFNjcm9sbFRvcCA+IGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIGNvbnRpbnVlQW5pbWF0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRpbnVlQW5pbWF0aW9uKSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fYW5pbWF0ZVNjcm9sbChkZXN0aW5hdGlvbiwgZGlyZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIExpc3Q7XG59KCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IExpc3Q7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MzA6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbnZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTkpO1xudmFyIFdyYXBwZWRFbGVtZW50ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV3JhcHBlZEVsZW1lbnQoX2EpIHtcbiAgICB2YXIgZWxlbWVudCA9IF9hLmVsZW1lbnQsXG4gICAgICBjbGFzc05hbWVzID0gX2EuY2xhc3NOYW1lcztcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpICYmICEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxTZWxlY3RFbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBlbGVtZW50IHBhc3NlZCcpO1xuICAgIH1cbiAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlZEVsZW1lbnQucHJvdG90eXBlLCBcImlzQWN0aXZlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZGF0YXNldC5jaG9pY2UgPT09ICdhY3RpdmUnO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlZEVsZW1lbnQucHJvdG90eXBlLCBcImRpclwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmRpcjtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRFbGVtZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50LnZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIHlvdSBtdXN0IGRlZmluZSBzZXR0ZXIgaGVyZSBvdGhlcndpc2UgaXQgd2lsbCBiZSByZWFkb25seSBwcm9wZXJ0eVxuICAgICAgdGhpcy5lbGVtZW50LnZhbHVlID0gdmFsdWU7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIFdyYXBwZWRFbGVtZW50LnByb3RvdHlwZS5jb25jZWFsID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIEhpZGUgcGFzc2VkIGlucHV0XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5jbGFzc05hbWVzLmlucHV0KTtcbiAgICB0aGlzLmVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIHRhYiBpbmRleFxuICAgIHRoaXMuZWxlbWVudC50YWJJbmRleCA9IC0xO1xuICAgIC8vIEJhY2t1cCBvcmlnaW5hbCBzdHlsZXMgaWYgYW55XG4gICAgdmFyIG9yaWdTdHlsZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgaWYgKG9yaWdTdHlsZSkge1xuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1jaG9pY2Utb3JpZy1zdHlsZScsIG9yaWdTdHlsZSk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtY2hvaWNlJywgJ2FjdGl2ZScpO1xuICB9O1xuICBXcmFwcGVkRWxlbWVudC5wcm90b3R5cGUucmV2ZWFsID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFJlaW5zdGF0ZSBwYXNzZWQgZWxlbWVudFxuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuY2xhc3NOYW1lcy5pbnB1dCk7XG4gICAgdGhpcy5lbGVtZW50LmhpZGRlbiA9IGZhbHNlO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgLy8gUmVjb3ZlciBvcmlnaW5hbCBzdHlsZXMgaWYgYW55XG4gICAgdmFyIG9yaWdTdHlsZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtY2hvaWNlLW9yaWctc3R5bGUnKTtcbiAgICBpZiAob3JpZ1N0eWxlKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWNob2ljZS1vcmlnLXN0eWxlJyk7XG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsIG9yaWdTdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtY2hvaWNlJyk7XG4gICAgLy8gUmUtYXNzaWduIHZhbHVlcyAtIHRoaXMgaXMgd2VpcmQsIEkga25vd1xuICAgIC8vIEB0b2RvIEZpZ3VyZSBvdXQgd2h5IHdlIG5lZWQgdG8gZG8gdGhpc1xuICAgIHRoaXMuZWxlbWVudC52YWx1ZSA9IHRoaXMuZWxlbWVudC52YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWFzc2lnblxuICB9O1xuXG4gIFdyYXBwZWRFbGVtZW50LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICB0aGlzLmVsZW1lbnQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgfTtcbiAgV3JhcHBlZEVsZW1lbnQucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnJyk7XG4gICAgdGhpcy5lbGVtZW50LmRpc2FibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmlzRGlzYWJsZWQgPSB0cnVlO1xuICB9O1xuICBXcmFwcGVkRWxlbWVudC5wcm90b3R5cGUudHJpZ2dlckV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgZGF0YSkge1xuICAgICgwLCB1dGlsc18xLmRpc3BhdGNoRXZlbnQpKHRoaXMuZWxlbWVudCwgZXZlbnRUeXBlLCBkYXRhKTtcbiAgfTtcbiAgcmV0dXJuIFdyYXBwZWRFbGVtZW50O1xufSgpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBXcmFwcGVkRWxlbWVudDtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU0MTpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxudmFyIF9fZXh0ZW5kcyA9IHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24gKCkge1xuICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgICBfX3Byb3RvX186IFtdXG4gICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XG4gICAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTtcbiAgICB9O1xuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICBmdW5jdGlvbiBfXygpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICAgIH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG59KCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbnZhciB3cmFwcGVkX2VsZW1lbnRfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDczMCkpO1xudmFyIFdyYXBwZWRJbnB1dCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhXcmFwcGVkSW5wdXQsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFdyYXBwZWRJbnB1dChfYSkge1xuICAgIHZhciBlbGVtZW50ID0gX2EuZWxlbWVudCxcbiAgICAgIGNsYXNzTmFtZXMgPSBfYS5jbGFzc05hbWVzLFxuICAgICAgZGVsaW1pdGVyID0gX2EuZGVsaW1pdGVyO1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICBjbGFzc05hbWVzOiBjbGFzc05hbWVzXG4gICAgfSkgfHwgdGhpcztcbiAgICBfdGhpcy5kZWxpbWl0ZXIgPSBkZWxpbWl0ZXI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkSW5wdXQucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQudmFsdWU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gICAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIFdyYXBwZWRJbnB1dDtcbn0od3JhcHBlZF9lbGVtZW50XzEuZGVmYXVsdCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFdyYXBwZWRJbnB1dDtcblxuLyoqKi8gfSksXG5cbi8qKiovIDk4Mjpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxudmFyIF9fZXh0ZW5kcyA9IHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24gKCkge1xuICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgICBfX3Byb3RvX186IFtdXG4gICAgfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XG4gICAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTtcbiAgICB9O1xuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICBmdW5jdGlvbiBfXygpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBkO1xuICAgIH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gIH07XG59KCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbnZhciB3cmFwcGVkX2VsZW1lbnRfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDczMCkpO1xudmFyIFdyYXBwZWRTZWxlY3QgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoV3JhcHBlZFNlbGVjdCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gV3JhcHBlZFNlbGVjdChfYSkge1xuICAgIHZhciBlbGVtZW50ID0gX2EuZWxlbWVudCxcbiAgICAgIGNsYXNzTmFtZXMgPSBfYS5jbGFzc05hbWVzLFxuICAgICAgdGVtcGxhdGUgPSBfYS50ZW1wbGF0ZTtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgY2xhc3NOYW1lczogY2xhc3NOYW1lc1xuICAgIH0pIHx8IHRoaXM7XG4gICAgX3RoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRTZWxlY3QucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyT3B0aW9uXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3Rvcignb3B0aW9uW3ZhbHVlPVwiXCJdJykgfHxcbiAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgbGF5ZXIgZm9yIHRoZSBub24tc3RhbmRhcmQgcGxhY2Vob2xkZXIgYXR0cmlidXRlIHN1cHBvcnRlZCBpbiBvbGRlciB2ZXJzaW9ucy5cbiAgICAgIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdvcHRpb25bcGxhY2Vob2xkZXJdJyk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcmFwcGVkU2VsZWN0LnByb3RvdHlwZSwgXCJvcHRpb25Hcm91cHNcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdPUFRHUk9VUCcpKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRTZWxlY3QucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lbGVtZW50Lm9wdGlvbnMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHZhciBhZGRPcHRpb25Ub0ZyYWdtZW50ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgc3RhbmRhcmQgc2VsZWN0IG9wdGlvblxuICAgICAgICB2YXIgb3B0aW9uID0gX3RoaXMudGVtcGxhdGUoZGF0YSk7XG4gICAgICAgIC8vIEFwcGVuZCBpdCB0byBmcmFnbWVudFxuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgfTtcbiAgICAgIC8vIEFkZCBlYWNoIGxpc3QgaXRlbSB0byBsaXN0XG4gICAgICBvcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbkRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGFkZE9wdGlvblRvRnJhZ21lbnQob3B0aW9uRGF0YSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYXBwZW5kRG9jRnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBXcmFwcGVkU2VsZWN0LnByb3RvdHlwZS5hcHBlbmREb2NGcmFnbWVudCA9IGZ1bmN0aW9uIChmcmFnbWVudCkge1xuICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSAnJztcbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICB9O1xuICByZXR1cm4gV3JhcHBlZFNlbGVjdDtcbn0od3JhcHBlZF9lbGVtZW50XzEuZGVmYXVsdCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFdyYXBwZWRTZWxlY3Q7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4ODM6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuU0NST0xMSU5HX1NQRUVEID0gZXhwb3J0cy5TRUxFQ1RfTVVMVElQTEVfVFlQRSA9IGV4cG9ydHMuU0VMRUNUX09ORV9UWVBFID0gZXhwb3J0cy5URVhUX1RZUEUgPSBleHBvcnRzLktFWV9DT0RFUyA9IGV4cG9ydHMuQUNUSU9OX1RZUEVTID0gZXhwb3J0cy5FVkVOVFMgPSB2b2lkIDA7XG5leHBvcnRzLkVWRU5UUyA9IHtcbiAgc2hvd0Ryb3Bkb3duOiAnc2hvd0Ryb3Bkb3duJyxcbiAgaGlkZURyb3Bkb3duOiAnaGlkZURyb3Bkb3duJyxcbiAgY2hhbmdlOiAnY2hhbmdlJyxcbiAgY2hvaWNlOiAnY2hvaWNlJyxcbiAgc2VhcmNoOiAnc2VhcmNoJyxcbiAgYWRkSXRlbTogJ2FkZEl0ZW0nLFxuICByZW1vdmVJdGVtOiAncmVtb3ZlSXRlbScsXG4gIGhpZ2hsaWdodEl0ZW06ICdoaWdobGlnaHRJdGVtJyxcbiAgaGlnaGxpZ2h0Q2hvaWNlOiAnaGlnaGxpZ2h0Q2hvaWNlJyxcbiAgdW5oaWdobGlnaHRJdGVtOiAndW5oaWdobGlnaHRJdGVtJ1xufTtcbmV4cG9ydHMuQUNUSU9OX1RZUEVTID0ge1xuICBBRERfQ0hPSUNFOiAnQUREX0NIT0lDRScsXG4gIEZJTFRFUl9DSE9JQ0VTOiAnRklMVEVSX0NIT0lDRVMnLFxuICBBQ1RJVkFURV9DSE9JQ0VTOiAnQUNUSVZBVEVfQ0hPSUNFUycsXG4gIENMRUFSX0NIT0lDRVM6ICdDTEVBUl9DSE9JQ0VTJyxcbiAgQUREX0dST1VQOiAnQUREX0dST1VQJyxcbiAgQUREX0lURU06ICdBRERfSVRFTScsXG4gIFJFTU9WRV9JVEVNOiAnUkVNT1ZFX0lURU0nLFxuICBISUdITElHSFRfSVRFTTogJ0hJR0hMSUdIVF9JVEVNJyxcbiAgQ0xFQVJfQUxMOiAnQ0xFQVJfQUxMJyxcbiAgUkVTRVRfVE86ICdSRVNFVF9UTycsXG4gIFNFVF9JU19MT0FESU5HOiAnU0VUX0lTX0xPQURJTkcnXG59O1xuZXhwb3J0cy5LRVlfQ09ERVMgPSB7XG4gIEJBQ0tfS0VZOiA0NixcbiAgREVMRVRFX0tFWTogOCxcbiAgRU5URVJfS0VZOiAxMyxcbiAgQV9LRVk6IDY1LFxuICBFU0NfS0VZOiAyNyxcbiAgVVBfS0VZOiAzOCxcbiAgRE9XTl9LRVk6IDQwLFxuICBQQUdFX1VQX0tFWTogMzMsXG4gIFBBR0VfRE9XTl9LRVk6IDM0XG59O1xuZXhwb3J0cy5URVhUX1RZUEUgPSAndGV4dCc7XG5leHBvcnRzLlNFTEVDVF9PTkVfVFlQRSA9ICdzZWxlY3Qtb25lJztcbmV4cG9ydHMuU0VMRUNUX01VTFRJUExFX1RZUEUgPSAnc2VsZWN0LW11bHRpcGxlJztcbmV4cG9ydHMuU0NST0xMSU5HX1NQRUVEID0gNDtcblxuLyoqKi8gfSksXG5cbi8qKiovIDc4OTpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5ERUZBVUxUX0NPTkZJRyA9IGV4cG9ydHMuREVGQVVMVF9DTEFTU05BTUVTID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5OSk7XG5leHBvcnRzLkRFRkFVTFRfQ0xBU1NOQU1FUyA9IHtcbiAgY29udGFpbmVyT3V0ZXI6ICdjaG9pY2VzJyxcbiAgY29udGFpbmVySW5uZXI6ICdjaG9pY2VzX19pbm5lcicsXG4gIGlucHV0OiAnY2hvaWNlc19faW5wdXQnLFxuICBpbnB1dENsb25lZDogJ2Nob2ljZXNfX2lucHV0LS1jbG9uZWQnLFxuICBsaXN0OiAnY2hvaWNlc19fbGlzdCcsXG4gIGxpc3RJdGVtczogJ2Nob2ljZXNfX2xpc3QtLW11bHRpcGxlJyxcbiAgbGlzdFNpbmdsZTogJ2Nob2ljZXNfX2xpc3QtLXNpbmdsZScsXG4gIGxpc3REcm9wZG93bjogJ2Nob2ljZXNfX2xpc3QtLWRyb3Bkb3duJyxcbiAgaXRlbTogJ2Nob2ljZXNfX2l0ZW0nLFxuICBpdGVtU2VsZWN0YWJsZTogJ2Nob2ljZXNfX2l0ZW0tLXNlbGVjdGFibGUnLFxuICBpdGVtRGlzYWJsZWQ6ICdjaG9pY2VzX19pdGVtLS1kaXNhYmxlZCcsXG4gIGl0ZW1DaG9pY2U6ICdjaG9pY2VzX19pdGVtLS1jaG9pY2UnLFxuICBwbGFjZWhvbGRlcjogJ2Nob2ljZXNfX3BsYWNlaG9sZGVyJyxcbiAgZ3JvdXA6ICdjaG9pY2VzX19ncm91cCcsXG4gIGdyb3VwSGVhZGluZzogJ2Nob2ljZXNfX2hlYWRpbmcnLFxuICBidXR0b246ICdjaG9pY2VzX19idXR0b24nLFxuICBhY3RpdmVTdGF0ZTogJ2lzLWFjdGl2ZScsXG4gIGZvY3VzU3RhdGU6ICdpcy1mb2N1c2VkJyxcbiAgb3BlblN0YXRlOiAnaXMtb3BlbicsXG4gIGRpc2FibGVkU3RhdGU6ICdpcy1kaXNhYmxlZCcsXG4gIGhpZ2hsaWdodGVkU3RhdGU6ICdpcy1oaWdobGlnaHRlZCcsXG4gIHNlbGVjdGVkU3RhdGU6ICdpcy1zZWxlY3RlZCcsXG4gIGZsaXBwZWRTdGF0ZTogJ2lzLWZsaXBwZWQnLFxuICBsb2FkaW5nU3RhdGU6ICdpcy1sb2FkaW5nJyxcbiAgbm9SZXN1bHRzOiAnaGFzLW5vLXJlc3VsdHMnLFxuICBub0Nob2ljZXM6ICdoYXMtbm8tY2hvaWNlcydcbn07XG5leHBvcnRzLkRFRkFVTFRfQ09ORklHID0ge1xuICBpdGVtczogW10sXG4gIGNob2ljZXM6IFtdLFxuICBzaWxlbnQ6IGZhbHNlLFxuICByZW5kZXJDaG9pY2VMaW1pdDogLTEsXG4gIG1heEl0ZW1Db3VudDogLTEsXG4gIGFkZEl0ZW1zOiB0cnVlLFxuICBhZGRJdGVtRmlsdGVyOiBudWxsLFxuICByZW1vdmVJdGVtczogdHJ1ZSxcbiAgcmVtb3ZlSXRlbUJ1dHRvbjogZmFsc2UsXG4gIGVkaXRJdGVtczogZmFsc2UsXG4gIGFsbG93SFRNTDogdHJ1ZSxcbiAgZHVwbGljYXRlSXRlbXNBbGxvd2VkOiB0cnVlLFxuICBkZWxpbWl0ZXI6ICcsJyxcbiAgcGFzdGU6IHRydWUsXG4gIHNlYXJjaEVuYWJsZWQ6IHRydWUsXG4gIHNlYXJjaENob2ljZXM6IHRydWUsXG4gIHNlYXJjaEZsb29yOiAxLFxuICBzZWFyY2hSZXN1bHRMaW1pdDogNCxcbiAgc2VhcmNoRmllbGRzOiBbJ2xhYmVsJywgJ3ZhbHVlJ10sXG4gIHBvc2l0aW9uOiAnYXV0bycsXG4gIHJlc2V0U2Nyb2xsUG9zaXRpb246IHRydWUsXG4gIHNob3VsZFNvcnQ6IHRydWUsXG4gIHNob3VsZFNvcnRJdGVtczogZmFsc2UsXG4gIHNvcnRlcjogdXRpbHNfMS5zb3J0QnlBbHBoYSxcbiAgcGxhY2Vob2xkZXI6IHRydWUsXG4gIHBsYWNlaG9sZGVyVmFsdWU6IG51bGwsXG4gIHNlYXJjaFBsYWNlaG9sZGVyVmFsdWU6IG51bGwsXG4gIHByZXBlbmRWYWx1ZTogbnVsbCxcbiAgYXBwZW5kVmFsdWU6IG51bGwsXG4gIHJlbmRlclNlbGVjdGVkQ2hvaWNlczogJ2F1dG8nLFxuICBsb2FkaW5nVGV4dDogJ0xvYWRpbmcuLi4nLFxuICBub1Jlc3VsdHNUZXh0OiAnTm8gcmVzdWx0cyBmb3VuZCcsXG4gIG5vQ2hvaWNlc1RleHQ6ICdObyBjaG9pY2VzIHRvIGNob29zZSBmcm9tJyxcbiAgaXRlbVNlbGVjdFRleHQ6ICdQcmVzcyB0byBzZWxlY3QnLFxuICB1bmlxdWVJdGVtVGV4dDogJ09ubHkgdW5pcXVlIHZhbHVlcyBjYW4gYmUgYWRkZWQnLFxuICBjdXN0b21BZGRJdGVtVGV4dDogJ09ubHkgdmFsdWVzIG1hdGNoaW5nIHNwZWNpZmljIGNvbmRpdGlvbnMgY2FuIGJlIGFkZGVkJyxcbiAgYWRkSXRlbVRleHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBcIlByZXNzIEVudGVyIHRvIGFkZCA8Yj5cXFwiXCIuY29uY2F0KCgwLCB1dGlsc18xLnNhbml0aXNlKSh2YWx1ZSksIFwiXFxcIjwvYj5cIik7XG4gIH0sXG4gIG1heEl0ZW1UZXh0OiBmdW5jdGlvbiAobWF4SXRlbUNvdW50KSB7XG4gICAgcmV0dXJuIFwiT25seSBcIi5jb25jYXQobWF4SXRlbUNvdW50LCBcIiB2YWx1ZXMgY2FuIGJlIGFkZGVkXCIpO1xuICB9LFxuICB2YWx1ZUNvbXBhcmVyOiBmdW5jdGlvbiAodmFsdWUxLCB2YWx1ZTIpIHtcbiAgICByZXR1cm4gdmFsdWUxID09PSB2YWx1ZTI7XG4gIH0sXG4gIGZ1c2VPcHRpb25zOiB7XG4gICAgaW5jbHVkZVNjb3JlOiB0cnVlXG4gIH0sXG4gIGxhYmVsSWQ6ICcnLFxuICBjYWxsYmFja09uSW5pdDogbnVsbCxcbiAgY2FsbGJhY2tPbkNyZWF0ZVRlbXBsYXRlczogbnVsbCxcbiAgY2xhc3NOYW1lczogZXhwb3J0cy5ERUZBVUxUX0NMQVNTTkFNRVNcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxODpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTc4OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NDg6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDM1OTpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMjg1OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MzM6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDE4Nzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxudmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgIGRlc2MgPSB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG52YXIgX19leHBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhciB8fCBmdW5jdGlvbiAobSwgZXhwb3J0cykge1xuICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMTgpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDk3OCksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oOTQ4KSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygzNTkpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDI4NSksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNTMzKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygyODcpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oODM3KSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg1OTgpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDM2OSksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMzcpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg5MjMpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDg3NiksIGV4cG9ydHMpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMjg3OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMzI6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDgzNzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTk4OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMzY5OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA0Nzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTIzOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NzY6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDc5OTpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5wYXJzZUN1c3RvbVByb3BlcnRpZXMgPSBleHBvcnRzLmRpZmYgPSBleHBvcnRzLmNsb25lT2JqZWN0ID0gZXhwb3J0cy5leGlzdHNJbkFycmF5ID0gZXhwb3J0cy5kaXNwYXRjaEV2ZW50ID0gZXhwb3J0cy5zb3J0QnlTY29yZSA9IGV4cG9ydHMuc29ydEJ5QWxwaGEgPSBleHBvcnRzLnN0clRvRWwgPSBleHBvcnRzLnNhbml0aXNlID0gZXhwb3J0cy5pc1Njcm9sbGVkSW50b1ZpZXcgPSBleHBvcnRzLmdldEFkamFjZW50RWwgPSBleHBvcnRzLndyYXAgPSBleHBvcnRzLmlzVHlwZSA9IGV4cG9ydHMuZ2V0VHlwZSA9IGV4cG9ydHMuZ2VuZXJhdGVJZCA9IGV4cG9ydHMuZ2VuZXJhdGVDaGFycyA9IGV4cG9ydHMuZ2V0UmFuZG9tTnVtYmVyID0gdm9pZCAwO1xudmFyIGdldFJhbmRvbU51bWJlciA9IGZ1bmN0aW9uIChtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW4pO1xufTtcbmV4cG9ydHMuZ2V0UmFuZG9tTnVtYmVyID0gZ2V0UmFuZG9tTnVtYmVyO1xudmFyIGdlbmVyYXRlQ2hhcnMgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHtcbiAgICBsZW5ndGg6IGxlbmd0aFxuICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmdldFJhbmRvbU51bWJlcikoMCwgMzYpLnRvU3RyaW5nKDM2KTtcbiAgfSkuam9pbignJyk7XG59O1xuZXhwb3J0cy5nZW5lcmF0ZUNoYXJzID0gZ2VuZXJhdGVDaGFycztcbnZhciBnZW5lcmF0ZUlkID0gZnVuY3Rpb24gKGVsZW1lbnQsIHByZWZpeCkge1xuICB2YXIgaWQgPSBlbGVtZW50LmlkIHx8IGVsZW1lbnQubmFtZSAmJiBcIlwiLmNvbmNhdChlbGVtZW50Lm5hbWUsIFwiLVwiKS5jb25jYXQoKDAsIGV4cG9ydHMuZ2VuZXJhdGVDaGFycykoMikpIHx8ICgwLCBleHBvcnRzLmdlbmVyYXRlQ2hhcnMpKDQpO1xuICBpZCA9IGlkLnJlcGxhY2UoLyg6fFxcLnxcXFt8XFxdfCwpL2csICcnKTtcbiAgaWQgPSBcIlwiLmNvbmNhdChwcmVmaXgsIFwiLVwiKS5jb25jYXQoaWQpO1xuICByZXR1cm4gaWQ7XG59O1xuZXhwb3J0cy5nZW5lcmF0ZUlkID0gZ2VuZXJhdGVJZDtcbnZhciBnZXRUeXBlID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikuc2xpY2UoOCwgLTEpO1xufTtcbmV4cG9ydHMuZ2V0VHlwZSA9IGdldFR5cGU7XG52YXIgaXNUeXBlID0gZnVuY3Rpb24gKHR5cGUsIG9iaikge1xuICByZXR1cm4gb2JqICE9PSB1bmRlZmluZWQgJiYgb2JqICE9PSBudWxsICYmICgwLCBleHBvcnRzLmdldFR5cGUpKG9iaikgPT09IHR5cGU7XG59O1xuZXhwb3J0cy5pc1R5cGUgPSBpc1R5cGU7XG52YXIgd3JhcCA9IGZ1bmN0aW9uIChlbGVtZW50LCB3cmFwcGVyKSB7XG4gIGlmICh3cmFwcGVyID09PSB2b2lkIDApIHtcbiAgICB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIH1cbiAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgIGlmIChlbGVtZW50Lm5leHRTaWJsaW5nKSB7XG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIGVsZW1lbnQubmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiB3cmFwcGVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xufTtcbmV4cG9ydHMud3JhcCA9IHdyYXA7XG52YXIgZ2V0QWRqYWNlbnRFbCA9IGZ1bmN0aW9uIChzdGFydEVsLCBzZWxlY3RvciwgZGlyZWN0aW9uKSB7XG4gIGlmIChkaXJlY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIGRpcmVjdGlvbiA9IDE7XG4gIH1cbiAgdmFyIHByb3AgPSBcIlwiLmNvbmNhdChkaXJlY3Rpb24gPiAwID8gJ25leHQnIDogJ3ByZXZpb3VzJywgXCJFbGVtZW50U2libGluZ1wiKTtcbiAgdmFyIHNpYmxpbmcgPSBzdGFydEVsW3Byb3BdO1xuICB3aGlsZSAoc2libGluZykge1xuICAgIGlmIChzaWJsaW5nLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICByZXR1cm4gc2libGluZztcbiAgICB9XG4gICAgc2libGluZyA9IHNpYmxpbmdbcHJvcF07XG4gIH1cbiAgcmV0dXJuIHNpYmxpbmc7XG59O1xuZXhwb3J0cy5nZXRBZGphY2VudEVsID0gZ2V0QWRqYWNlbnRFbDtcbnZhciBpc1Njcm9sbGVkSW50b1ZpZXcgPSBmdW5jdGlvbiAoZWxlbWVudCwgcGFyZW50LCBkaXJlY3Rpb24pIHtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgZGlyZWN0aW9uID0gMTtcbiAgfVxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGlzVmlzaWJsZTtcbiAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAvLyBJbiB2aWV3IGZyb20gYm90dG9tXG4gICAgaXNWaXNpYmxlID0gcGFyZW50LnNjcm9sbFRvcCArIHBhcmVudC5vZmZzZXRIZWlnaHQgPj0gZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiB2aWV3IGZyb20gdG9wXG4gICAgaXNWaXNpYmxlID0gZWxlbWVudC5vZmZzZXRUb3AgPj0gcGFyZW50LnNjcm9sbFRvcDtcbiAgfVxuICByZXR1cm4gaXNWaXNpYmxlO1xufTtcbmV4cG9ydHMuaXNTY3JvbGxlZEludG9WaWV3ID0gaXNTY3JvbGxlZEludG9WaWV3O1xudmFyIHNhbml0aXNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpO1xufTtcbmV4cG9ydHMuc2FuaXRpc2UgPSBzYW5pdGlzZTtcbmV4cG9ydHMuc3RyVG9FbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRtcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIGNsZWFuZWRJbnB1dCA9IHN0ci50cmltKCk7XG4gICAgdG1wRWwuaW5uZXJIVE1MID0gY2xlYW5lZElucHV0O1xuICAgIHZhciBmaXJsZENoaWxkID0gdG1wRWwuY2hpbGRyZW5bMF07XG4gICAgd2hpbGUgKHRtcEVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHRtcEVsLnJlbW92ZUNoaWxkKHRtcEVsLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmlybGRDaGlsZDtcbiAgfTtcbn0oKTtcbnZhciBzb3J0QnlBbHBoYSA9IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgdmFyIHZhbHVlID0gX2EudmFsdWUsXG4gICAgX2MgPSBfYS5sYWJlbCxcbiAgICBsYWJlbCA9IF9jID09PSB2b2lkIDAgPyB2YWx1ZSA6IF9jO1xuICB2YXIgdmFsdWUyID0gX2IudmFsdWUsXG4gICAgX2QgPSBfYi5sYWJlbCxcbiAgICBsYWJlbDIgPSBfZCA9PT0gdm9pZCAwID8gdmFsdWUyIDogX2Q7XG4gIHJldHVybiBsYWJlbC5sb2NhbGVDb21wYXJlKGxhYmVsMiwgW10sIHtcbiAgICBzZW5zaXRpdml0eTogJ2Jhc2UnLFxuICAgIGlnbm9yZVB1bmN0dWF0aW9uOiB0cnVlLFxuICAgIG51bWVyaWM6IHRydWVcbiAgfSk7XG59O1xuZXhwb3J0cy5zb3J0QnlBbHBoYSA9IHNvcnRCeUFscGhhO1xudmFyIHNvcnRCeVNjb3JlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIF9hID0gYS5zY29yZSxcbiAgICBzY29yZUEgPSBfYSA9PT0gdm9pZCAwID8gMCA6IF9hO1xuICB2YXIgX2IgPSBiLnNjb3JlLFxuICAgIHNjb3JlQiA9IF9iID09PSB2b2lkIDAgPyAwIDogX2I7XG4gIHJldHVybiBzY29yZUEgLSBzY29yZUI7XG59O1xuZXhwb3J0cy5zb3J0QnlTY29yZSA9IHNvcnRCeVNjb3JlO1xudmFyIGRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgdHlwZSwgY3VzdG9tQXJncykge1xuICBpZiAoY3VzdG9tQXJncyA9PT0gdm9pZCAwKSB7XG4gICAgY3VzdG9tQXJncyA9IG51bGw7XG4gIH1cbiAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KHR5cGUsIHtcbiAgICBkZXRhaWw6IGN1c3RvbUFyZ3MsXG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn07XG5leHBvcnRzLmRpc3BhdGNoRXZlbnQgPSBkaXNwYXRjaEV2ZW50O1xudmFyIGV4aXN0c0luQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXksIHZhbHVlLCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gdm9pZCAwKSB7XG4gICAga2V5ID0gJ3ZhbHVlJztcbiAgfVxuICByZXR1cm4gYXJyYXkuc29tZShmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gaXRlbVtrZXldID09PSB2YWx1ZS50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtW2tleV0gPT09IHZhbHVlO1xuICB9KTtcbn07XG5leHBvcnRzLmV4aXN0c0luQXJyYXkgPSBleGlzdHNJbkFycmF5O1xudmFyIGNsb25lT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn07XG5leHBvcnRzLmNsb25lT2JqZWN0ID0gY2xvbmVPYmplY3Q7XG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2Yga2V5cyBwcmVzZW50IG9uIHRoZSBmaXJzdCBidXQgbWlzc2luZyBvbiB0aGUgc2Vjb25kIG9iamVjdFxuICovXG52YXIgZGlmZiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpLnNvcnQoKTtcbiAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYikuc29ydCgpO1xuICByZXR1cm4gYUtleXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGJLZXlzLmluZGV4T2YoaSkgPCAwO1xuICB9KTtcbn07XG5leHBvcnRzLmRpZmYgPSBkaWZmO1xudmFyIHBhcnNlQ3VzdG9tUHJvcGVydGllcyA9IGZ1bmN0aW9uIChjdXN0b21Qcm9wZXJ0aWVzKSB7XG4gIGlmICh0eXBlb2YgY3VzdG9tUHJvcGVydGllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY3VzdG9tUHJvcGVydGllcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGN1c3RvbVByb3BlcnRpZXM7XG4gICAgfVxuICB9XG4gIHJldHVybiB7fTtcbn07XG5leHBvcnRzLnBhcnNlQ3VzdG9tUHJvcGVydGllcyA9IHBhcnNlQ3VzdG9tUHJvcGVydGllcztcblxuLyoqKi8gfSksXG5cbi8qKiovIDI3Mzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cblxudmFyIF9fc3ByZWFkQXJyYXkgPSB0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHRTdGF0ZSA9IHZvaWQgMDtcbmV4cG9ydHMuZGVmYXVsdFN0YXRlID0gW107XG5mdW5jdGlvbiBjaG9pY2VzKHN0YXRlLCBhY3Rpb24pIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICBzdGF0ZSA9IGV4cG9ydHMuZGVmYXVsdFN0YXRlO1xuICB9XG4gIGlmIChhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIGFjdGlvbiA9IHt9O1xuICB9XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdBRERfQ0hPSUNFJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGFkZENob2ljZUFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgdmFyIGNob2ljZSA9IHtcbiAgICAgICAgICBpZDogYWRkQ2hvaWNlQWN0aW9uLmlkLFxuICAgICAgICAgIGVsZW1lbnRJZDogYWRkQ2hvaWNlQWN0aW9uLmVsZW1lbnRJZCxcbiAgICAgICAgICBncm91cElkOiBhZGRDaG9pY2VBY3Rpb24uZ3JvdXBJZCxcbiAgICAgICAgICB2YWx1ZTogYWRkQ2hvaWNlQWN0aW9uLnZhbHVlLFxuICAgICAgICAgIGxhYmVsOiBhZGRDaG9pY2VBY3Rpb24ubGFiZWwgfHwgYWRkQ2hvaWNlQWN0aW9uLnZhbHVlLFxuICAgICAgICAgIGRpc2FibGVkOiBhZGRDaG9pY2VBY3Rpb24uZGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBzY29yZTogOTk5OSxcbiAgICAgICAgICBjdXN0b21Qcm9wZXJ0aWVzOiBhZGRDaG9pY2VBY3Rpb24uY3VzdG9tUHJvcGVydGllcyxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogYWRkQ2hvaWNlQWN0aW9uLnBsYWNlaG9sZGVyIHx8IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIC8qXG4gICAgICAgICAgQSBkaXNhYmxlZCBjaG9pY2UgYXBwZWFycyBpbiB0aGUgY2hvaWNlIGRyb3Bkb3duIGJ1dCBjYW5ub3QgYmUgc2VsZWN0ZWRcbiAgICAgICAgICBBIHNlbGVjdGVkIGNob2ljZSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgcGFzc2VkIGlucHV0J3MgdmFsdWUgKGFkZGVkIGFzIGFuIGl0ZW0pXG4gICAgICAgICAgQW4gYWN0aXZlIGNob2ljZSBhcHBlYXJzIHdpdGhpbiB0aGUgY2hvaWNlIGRyb3Bkb3duXG4gICAgICAgICovXG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHN0YXRlLCB0cnVlKSwgW2Nob2ljZV0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICBjYXNlICdBRERfSVRFTSc6XG4gICAgICB7XG4gICAgICAgIHZhciBhZGRJdGVtQWN0aW9uXzEgPSBhY3Rpb247XG4gICAgICAgIC8vIFdoZW4gYW4gaXRlbSBpcyBhZGRlZCBhbmQgaXQgaGFzIGFuIGFzc29jaWF0ZWQgY2hvaWNlLFxuICAgICAgICAvLyB3ZSB3YW50IHRvIGRpc2FibGUgaXQgc28gaXQgY2FuJ3QgYmUgY2hvc2VuIGFnYWluXG4gICAgICAgIGlmIChhZGRJdGVtQWN0aW9uXzEuY2hvaWNlSWQgPiAtMSkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGNob2ljZSA9IG9iajtcbiAgICAgICAgICAgIGlmIChjaG9pY2UuaWQgPT09IHBhcnNlSW50KFwiXCIuY29uY2F0KGFkZEl0ZW1BY3Rpb25fMS5jaG9pY2VJZCksIDEwKSkge1xuICAgICAgICAgICAgICBjaG9pY2Uuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNob2ljZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgY2FzZSAnUkVNT1ZFX0lURU0nOlxuICAgICAge1xuICAgICAgICB2YXIgcmVtb3ZlSXRlbUFjdGlvbl8xID0gYWN0aW9uO1xuICAgICAgICAvLyBXaGVuIGFuIGl0ZW0gaXMgcmVtb3ZlZCBhbmQgaXQgaGFzIGFuIGFzc29jaWF0ZWQgY2hvaWNlLFxuICAgICAgICAvLyB3ZSB3YW50IHRvIHJlLWVuYWJsZSBpdCBzbyBpdCBjYW4gYmUgY2hvc2VuIGFnYWluXG4gICAgICAgIGlmIChyZW1vdmVJdGVtQWN0aW9uXzEuY2hvaWNlSWQgJiYgcmVtb3ZlSXRlbUFjdGlvbl8xLmNob2ljZUlkID4gLTEpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubWFwKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBjaG9pY2UgPSBvYmo7XG4gICAgICAgICAgICBpZiAoY2hvaWNlLmlkID09PSBwYXJzZUludChcIlwiLmNvbmNhdChyZW1vdmVJdGVtQWN0aW9uXzEuY2hvaWNlSWQpLCAxMCkpIHtcbiAgICAgICAgICAgICAgY2hvaWNlLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hvaWNlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICBjYXNlICdGSUxURVJfQ0hPSUNFUyc6XG4gICAgICB7XG4gICAgICAgIHZhciBmaWx0ZXJDaG9pY2VzQWN0aW9uXzEgPSBhY3Rpb247XG4gICAgICAgIHJldHVybiBzdGF0ZS5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHZhciBjaG9pY2UgPSBvYmo7XG4gICAgICAgICAgLy8gU2V0IGFjdGl2ZSBzdGF0ZSBiYXNlZCBvbiB3aGV0aGVyIGNob2ljZSBpc1xuICAgICAgICAgIC8vIHdpdGhpbiBmaWx0ZXJlZCByZXN1bHRzXG4gICAgICAgICAgY2hvaWNlLmFjdGl2ZSA9IGZpbHRlckNob2ljZXNBY3Rpb25fMS5yZXN1bHRzLnNvbWUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IF9hLml0ZW0sXG4gICAgICAgICAgICAgIHNjb3JlID0gX2Euc2NvcmU7XG4gICAgICAgICAgICBpZiAoaXRlbS5pZCA9PT0gY2hvaWNlLmlkKSB7XG4gICAgICAgICAgICAgIGNob2ljZS5zY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gY2hvaWNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBjYXNlICdBQ1RJVkFURV9DSE9JQ0VTJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGFjdGl2YXRlQ2hvaWNlc0FjdGlvbl8xID0gYWN0aW9uO1xuICAgICAgICByZXR1cm4gc3RhdGUubWFwKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICB2YXIgY2hvaWNlID0gb2JqO1xuICAgICAgICAgIGNob2ljZS5hY3RpdmUgPSBhY3RpdmF0ZUNob2ljZXNBY3Rpb25fMS5hY3RpdmU7XG4gICAgICAgICAgcmV0dXJuIGNob2ljZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgY2FzZSAnQ0xFQVJfQ0hPSUNFUyc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmRlZmF1bHRTdGF0ZTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gIH1cbn1cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gY2hvaWNlcztcblxuLyoqKi8gfSksXG5cbi8qKiovIDg3MTpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG5cblxudmFyIF9fc3ByZWFkQXJyYXkgPSB0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmRlZmF1bHRTdGF0ZSA9IHZvaWQgMDtcbmV4cG9ydHMuZGVmYXVsdFN0YXRlID0gW107XG5mdW5jdGlvbiBncm91cHMoc3RhdGUsIGFjdGlvbikge1xuICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgIHN0YXRlID0gZXhwb3J0cy5kZWZhdWx0U3RhdGU7XG4gIH1cbiAgaWYgKGFjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgYWN0aW9uID0ge307XG4gIH1cbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ0FERF9HUk9VUCc6XG4gICAgICB7XG4gICAgICAgIHZhciBhZGRHcm91cEFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgc3RhdGUsIHRydWUpLCBbe1xuICAgICAgICAgIGlkOiBhZGRHcm91cEFjdGlvbi5pZCxcbiAgICAgICAgICB2YWx1ZTogYWRkR3JvdXBBY3Rpb24udmFsdWUsXG4gICAgICAgICAgYWN0aXZlOiBhZGRHcm91cEFjdGlvbi5hY3RpdmUsXG4gICAgICAgICAgZGlzYWJsZWQ6IGFkZEdyb3VwQWN0aW9uLmRpc2FibGVkXG4gICAgICAgIH1dLCBmYWxzZSk7XG4gICAgICB9XG4gICAgY2FzZSAnQ0xFQVJfQ0hPSUNFUyc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gIH1cbn1cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZ3JvdXBzO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU1OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdFN0YXRlID0gdm9pZCAwO1xudmFyIHJlZHV4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5MSk7XG52YXIgaXRlbXNfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKSk7XG52YXIgZ3JvdXBzXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4NzEpKTtcbnZhciBjaG9pY2VzXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyNzMpKTtcbnZhciBsb2FkaW5nXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg1MDIpKTtcbnZhciB1dGlsc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTkpO1xuZXhwb3J0cy5kZWZhdWx0U3RhdGUgPSB7XG4gIGdyb3VwczogW10sXG4gIGl0ZW1zOiBbXSxcbiAgY2hvaWNlczogW10sXG4gIGxvYWRpbmc6IGZhbHNlXG59O1xudmFyIGFwcFJlZHVjZXIgPSAoMCwgcmVkdXhfMS5jb21iaW5lUmVkdWNlcnMpKHtcbiAgaXRlbXM6IGl0ZW1zXzEuZGVmYXVsdCxcbiAgZ3JvdXBzOiBncm91cHNfMS5kZWZhdWx0LFxuICBjaG9pY2VzOiBjaG9pY2VzXzEuZGVmYXVsdCxcbiAgbG9hZGluZzogbG9hZGluZ18xLmRlZmF1bHRcbn0pO1xudmFyIHJvb3RSZWR1Y2VyID0gZnVuY3Rpb24gKHBhc3NlZFN0YXRlLCBhY3Rpb24pIHtcbiAgdmFyIHN0YXRlID0gcGFzc2VkU3RhdGU7XG4gIC8vIElmIHdlIGFyZSBjbGVhcmluZyBhbGwgaXRlbXMsIGdyb3VwcyBhbmQgb3B0aW9ucyB3ZSByZWFzc2lnblxuICAvLyBzdGF0ZSBhbmQgdGhlbiBwYXNzIHRoYXQgc3RhdGUgdG8gb3VyIHByb3BlciByZWR1Y2VyLiBUaGlzIGlzbid0XG4gIC8vIG11dGF0aW5nIG91ciBhY3R1YWwgc3RhdGVcbiAgLy8gU2VlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNTY0MTk5MlxuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdDTEVBUl9BTEwnKSB7XG4gICAgc3RhdGUgPSBleHBvcnRzLmRlZmF1bHRTdGF0ZTtcbiAgfSBlbHNlIGlmIChhY3Rpb24udHlwZSA9PT0gJ1JFU0VUX1RPJykge1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5jbG9uZU9iamVjdCkoYWN0aW9uLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gYXBwUmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbn07XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHJvb3RSZWR1Y2VyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTI6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbnZhciBfX3NwcmVhZEFycmF5ID0gdGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5kZWZhdWx0U3RhdGUgPSB2b2lkIDA7XG5leHBvcnRzLmRlZmF1bHRTdGF0ZSA9IFtdO1xuZnVuY3Rpb24gaXRlbXMoc3RhdGUsIGFjdGlvbikge1xuICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgIHN0YXRlID0gZXhwb3J0cy5kZWZhdWx0U3RhdGU7XG4gIH1cbiAgaWYgKGFjdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgYWN0aW9uID0ge307XG4gIH1cbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ0FERF9JVEVNJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGFkZEl0ZW1BY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIC8vIEFkZCBvYmplY3QgdG8gaXRlbXMgYXJyYXlcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBzdGF0ZSwgdHJ1ZSksIFt7XG4gICAgICAgICAgaWQ6IGFkZEl0ZW1BY3Rpb24uaWQsXG4gICAgICAgICAgY2hvaWNlSWQ6IGFkZEl0ZW1BY3Rpb24uY2hvaWNlSWQsXG4gICAgICAgICAgZ3JvdXBJZDogYWRkSXRlbUFjdGlvbi5ncm91cElkLFxuICAgICAgICAgIHZhbHVlOiBhZGRJdGVtQWN0aW9uLnZhbHVlLFxuICAgICAgICAgIGxhYmVsOiBhZGRJdGVtQWN0aW9uLmxhYmVsLFxuICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICBoaWdobGlnaHRlZDogZmFsc2UsXG4gICAgICAgICAgY3VzdG9tUHJvcGVydGllczogYWRkSXRlbUFjdGlvbi5jdXN0b21Qcm9wZXJ0aWVzLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBhZGRJdGVtQWN0aW9uLnBsYWNlaG9sZGVyIHx8IGZhbHNlLFxuICAgICAgICAgIGtleUNvZGU6IG51bGxcbiAgICAgICAgfV0sIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlLm1hcChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBvYmo7XG4gICAgICAgICAgaXRlbS5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBjYXNlICdSRU1PVkVfSVRFTSc6XG4gICAgICB7XG4gICAgICAgIC8vIFNldCBpdGVtIHRvIGluYWN0aXZlXG4gICAgICAgIHJldHVybiBzdGF0ZS5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHZhciBpdGVtID0gb2JqO1xuICAgICAgICAgIGlmIChpdGVtLmlkID09PSBhY3Rpb24uaWQpIHtcbiAgICAgICAgICAgIGl0ZW0uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBjYXNlICdISUdITElHSFRfSVRFTSc6XG4gICAgICB7XG4gICAgICAgIHZhciBoaWdobGlnaHRJdGVtQWN0aW9uXzEgPSBhY3Rpb247XG4gICAgICAgIHJldHVybiBzdGF0ZS5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHZhciBpdGVtID0gb2JqO1xuICAgICAgICAgIGlmIChpdGVtLmlkID09PSBoaWdobGlnaHRJdGVtQWN0aW9uXzEuaWQpIHtcbiAgICAgICAgICAgIGl0ZW0uaGlnaGxpZ2h0ZWQgPSBoaWdobGlnaHRJdGVtQWN0aW9uXzEuaGlnaGxpZ2h0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gIH1cbn1cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gaXRlbXM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDI6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZGVmYXVsdFN0YXRlID0gdm9pZCAwO1xuZXhwb3J0cy5kZWZhdWx0U3RhdGUgPSBmYWxzZTtcbnZhciBnZW5lcmFsID0gZnVuY3Rpb24gKHN0YXRlLCBhY3Rpb24pIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICBzdGF0ZSA9IGV4cG9ydHMuZGVmYXVsdFN0YXRlO1xuICB9XG4gIGlmIChhY3Rpb24gPT09IHZvaWQgMCkge1xuICAgIGFjdGlvbiA9IHt9O1xuICB9XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdTRVRfSVNfTE9BRElORyc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uaXNMb2FkaW5nO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgfVxufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZ2VuZXJhbDtcblxuLyoqKi8gfSksXG5cbi8qKiovIDc0NDpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxudmFyIF9fc3ByZWFkQXJyYXkgPSB0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbnZhciByZWR1eF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTEpO1xudmFyIGluZGV4XzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2NTUpKTtcbnZhciBTdG9yZSA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0b3JlKCkge1xuICAgIHRoaXMuX3N0b3JlID0gKDAsIHJlZHV4XzEuY3JlYXRlU3RvcmUpKGluZGV4XzEuZGVmYXVsdCwgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18oKSk7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBzdG9yZSB0byBmdW5jdGlvbiBjYWxsICh3cmFwcGVkIFJlZHV4IG1ldGhvZClcbiAgICovXG4gIFN0b3JlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob25DaGFuZ2UpIHtcbiAgICB0aGlzLl9zdG9yZS5zdWJzY3JpYmUob25DaGFuZ2UpO1xuICB9O1xuICAvKipcbiAgICogRGlzcGF0Y2ggZXZlbnQgdG8gc3RvcmUgKHdyYXBwZWQgUmVkdXggbWV0aG9kKVxuICAgKi9cbiAgU3RvcmUucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG9yZS5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xuICAgIC8qKlxuICAgICAqIEdldCBzdG9yZSBvYmplY3QgKHdyYXBwaW5nIFJlZHV4IG1ldGhvZClcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmUucHJvdG90eXBlLCBcIml0ZW1zXCIsIHtcbiAgICAvKipcbiAgICAgKiBHZXQgaXRlbXMgZnJvbSBzdG9yZVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXRlbXM7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG9yZS5wcm90b3R5cGUsIFwiYWN0aXZlSXRlbXNcIiwge1xuICAgIC8qKlxuICAgICAqIEdldCBhY3RpdmUgaXRlbXMgZnJvbSBzdG9yZVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmFjdGl2ZSA9PT0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmUucHJvdG90eXBlLCBcImhpZ2hsaWdodGVkQWN0aXZlSXRlbXNcIiwge1xuICAgIC8qKlxuICAgICAqIEdldCBoaWdobGlnaHRlZCBpdGVtcyBmcm9tIHN0b3JlXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uYWN0aXZlICYmIGl0ZW0uaGlnaGxpZ2h0ZWQ7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0b3JlLnByb3RvdHlwZSwgXCJjaG9pY2VzXCIsIHtcbiAgICAvKipcbiAgICAgKiBHZXQgY2hvaWNlcyBmcm9tIHN0b3JlXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jaG9pY2VzO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmUucHJvdG90eXBlLCBcImFjdGl2ZUNob2ljZXNcIiwge1xuICAgIC8qKlxuICAgICAqIEdldCBhY3RpdmUgY2hvaWNlcyBmcm9tIHN0b3JlXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaG9pY2VzLmZpbHRlcihmdW5jdGlvbiAoY2hvaWNlKSB7XG4gICAgICAgIHJldHVybiBjaG9pY2UuYWN0aXZlID09PSB0cnVlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG9yZS5wcm90b3R5cGUsIFwic2VsZWN0YWJsZUNob2ljZXNcIiwge1xuICAgIC8qKlxuICAgICAqIEdldCBzZWxlY3RhYmxlIGNob2ljZXMgZnJvbSBzdG9yZVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hvaWNlcy5maWx0ZXIoZnVuY3Rpb24gKGNob2ljZSkge1xuICAgICAgICByZXR1cm4gY2hvaWNlLmRpc2FibGVkICE9PSB0cnVlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG9yZS5wcm90b3R5cGUsIFwic2VhcmNoYWJsZUNob2ljZXNcIiwge1xuICAgIC8qKlxuICAgICAqIEdldCBjaG9pY2VzIHRoYXQgY2FuIGJlIHNlYXJjaGVkIChleGNsdWRpbmcgcGxhY2Vob2xkZXJzKVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0YWJsZUNob2ljZXMuZmlsdGVyKGZ1bmN0aW9uIChjaG9pY2UpIHtcbiAgICAgICAgcmV0dXJuIGNob2ljZS5wbGFjZWhvbGRlciAhPT0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmUucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyQ2hvaWNlXCIsIHtcbiAgICAvKipcbiAgICAgKiBHZXQgcGxhY2Vob2xkZXIgY2hvaWNlIGZyb20gc3RvcmVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KFtdLCB0aGlzLmNob2ljZXMsIHRydWUpLnJldmVyc2UoKS5maW5kKGZ1bmN0aW9uIChjaG9pY2UpIHtcbiAgICAgICAgcmV0dXJuIGNob2ljZS5wbGFjZWhvbGRlciA9PT0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmUucHJvdG90eXBlLCBcImdyb3Vwc1wiLCB7XG4gICAgLyoqXG4gICAgICogR2V0IGdyb3VwcyBmcm9tIHN0b3JlXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5ncm91cHM7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG9yZS5wcm90b3R5cGUsIFwiYWN0aXZlR3JvdXBzXCIsIHtcbiAgICAvKipcbiAgICAgKiBHZXQgYWN0aXZlIGdyb3VwcyBmcm9tIHN0b3JlXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2EgPSB0aGlzLFxuICAgICAgICBncm91cHMgPSBfYS5ncm91cHMsXG4gICAgICAgIGNob2ljZXMgPSBfYS5jaG9pY2VzO1xuICAgICAgcmV0dXJuIGdyb3Vwcy5maWx0ZXIoZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IGdyb3VwLmFjdGl2ZSA9PT0gdHJ1ZSAmJiBncm91cC5kaXNhYmxlZCA9PT0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNBY3RpdmVPcHRpb25zID0gY2hvaWNlcy5zb21lKGZ1bmN0aW9uIChjaG9pY2UpIHtcbiAgICAgICAgICByZXR1cm4gY2hvaWNlLmFjdGl2ZSA9PT0gdHJ1ZSAmJiBjaG9pY2UuZGlzYWJsZWQgPT09IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlzQWN0aXZlICYmIGhhc0FjdGl2ZU9wdGlvbnM7XG4gICAgICB9LCBbXSk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBHZXQgbG9hZGluZyBzdGF0ZSBmcm9tIHN0b3JlXG4gICAqL1xuICBTdG9yZS5wcm90b3R5cGUuaXNMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmxvYWRpbmc7XG4gIH07XG4gIC8qKlxuICAgKiBHZXQgc2luZ2xlIGNob2ljZSBieSBpdCdzIElEXG4gICAqL1xuICBTdG9yZS5wcm90b3R5cGUuZ2V0Q2hvaWNlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUNob2ljZXMuZmluZChmdW5jdGlvbiAoY2hvaWNlKSB7XG4gICAgICByZXR1cm4gY2hvaWNlLmlkID09PSBwYXJzZUludChpZCwgMTApO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogR2V0IGdyb3VwIGJ5IGdyb3VwIGlkXG4gICAqL1xuICBTdG9yZS5wcm90b3R5cGUuZ2V0R3JvdXBCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3JvdXBzLmZpbmQoZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICByZXR1cm4gZ3JvdXAuaWQgPT09IGlkO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gU3RvcmU7XG59KCk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFN0b3JlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNjg2OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cblxuXG4vKipcbiAqIEhlbHBlcnMgdG8gY3JlYXRlIEhUTUwgZWxlbWVudHMgdXNlZCBieSBDaG9pY2VzXG4gKiBDYW4gYmUgb3ZlcnJpZGRlbiBieSBwcm92aWRpbmcgYGNhbGxiYWNrT25DcmVhdGVUZW1wbGF0ZXNgIG9wdGlvblxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG52YXIgdGVtcGxhdGVzID0ge1xuICBjb250YWluZXJPdXRlcjogZnVuY3Rpb24gKF9hLCBkaXIsIGlzU2VsZWN0RWxlbWVudCwgaXNTZWxlY3RPbmVFbGVtZW50LCBzZWFyY2hFbmFibGVkLCBwYXNzZWRFbGVtZW50VHlwZSwgbGFiZWxJZCkge1xuICAgIHZhciBjb250YWluZXJPdXRlciA9IF9hLmNsYXNzTmFtZXMuY29udGFpbmVyT3V0ZXI7XG4gICAgdmFyIGRpdiA9IE9iamVjdC5hc3NpZ24oZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIHtcbiAgICAgIGNsYXNzTmFtZTogY29udGFpbmVyT3V0ZXJcbiAgICB9KTtcbiAgICBkaXYuZGF0YXNldC50eXBlID0gcGFzc2VkRWxlbWVudFR5cGU7XG4gICAgaWYgKGRpcikge1xuICAgICAgZGl2LmRpciA9IGRpcjtcbiAgICB9XG4gICAgaWYgKGlzU2VsZWN0T25lRWxlbWVudCkge1xuICAgICAgZGl2LnRhYkluZGV4ID0gMDtcbiAgICB9XG4gICAgaWYgKGlzU2VsZWN0RWxlbWVudCkge1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZSgncm9sZScsIHNlYXJjaEVuYWJsZWQgPyAnY29tYm9ib3gnIDogJ2xpc3Rib3gnKTtcbiAgICAgIGlmIChzZWFyY2hFbmFibGVkKSB7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtYXV0b2NvbXBsZXRlJywgJ2xpc3QnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1oYXNwb3B1cCcsICd0cnVlJyk7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgIGlmIChsYWJlbElkKSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCBsYWJlbElkKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpdjtcbiAgfSxcbiAgY29udGFpbmVySW5uZXI6IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjb250YWluZXJJbm5lciA9IF9hLmNsYXNzTmFtZXMuY29udGFpbmVySW5uZXI7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIHtcbiAgICAgIGNsYXNzTmFtZTogY29udGFpbmVySW5uZXJcbiAgICB9KTtcbiAgfSxcbiAgaXRlbUxpc3Q6IGZ1bmN0aW9uIChfYSwgaXNTZWxlY3RPbmVFbGVtZW50KSB7XG4gICAgdmFyIF9iID0gX2EuY2xhc3NOYW1lcyxcbiAgICAgIGxpc3QgPSBfYi5saXN0LFxuICAgICAgbGlzdFNpbmdsZSA9IF9iLmxpc3RTaW5nbGUsXG4gICAgICBsaXN0SXRlbXMgPSBfYi5saXN0SXRlbXM7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIHtcbiAgICAgIGNsYXNzTmFtZTogXCJcIi5jb25jYXQobGlzdCwgXCIgXCIpLmNvbmNhdChpc1NlbGVjdE9uZUVsZW1lbnQgPyBsaXN0U2luZ2xlIDogbGlzdEl0ZW1zKVxuICAgIH0pO1xuICB9LFxuICBwbGFjZWhvbGRlcjogZnVuY3Rpb24gKF9hLCB2YWx1ZSkge1xuICAgIHZhciBfYjtcbiAgICB2YXIgYWxsb3dIVE1MID0gX2EuYWxsb3dIVE1MLFxuICAgICAgcGxhY2Vob2xkZXIgPSBfYS5jbGFzc05hbWVzLnBsYWNlaG9sZGVyO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAoX2IgPSB7XG4gICAgICBjbGFzc05hbWU6IHBsYWNlaG9sZGVyXG4gICAgfSwgX2JbYWxsb3dIVE1MID8gJ2lubmVySFRNTCcgOiAnaW5uZXJUZXh0J10gPSB2YWx1ZSwgX2IpKTtcbiAgfSxcbiAgaXRlbTogZnVuY3Rpb24gKF9hLCBfYiwgcmVtb3ZlSXRlbUJ1dHRvbikge1xuICAgIHZhciBfYywgX2Q7XG4gICAgdmFyIGFsbG93SFRNTCA9IF9hLmFsbG93SFRNTCxcbiAgICAgIF9lID0gX2EuY2xhc3NOYW1lcyxcbiAgICAgIGl0ZW0gPSBfZS5pdGVtLFxuICAgICAgYnV0dG9uID0gX2UuYnV0dG9uLFxuICAgICAgaGlnaGxpZ2h0ZWRTdGF0ZSA9IF9lLmhpZ2hsaWdodGVkU3RhdGUsXG4gICAgICBpdGVtU2VsZWN0YWJsZSA9IF9lLml0ZW1TZWxlY3RhYmxlLFxuICAgICAgcGxhY2Vob2xkZXIgPSBfZS5wbGFjZWhvbGRlcjtcbiAgICB2YXIgaWQgPSBfYi5pZCxcbiAgICAgIHZhbHVlID0gX2IudmFsdWUsXG4gICAgICBsYWJlbCA9IF9iLmxhYmVsLFxuICAgICAgY3VzdG9tUHJvcGVydGllcyA9IF9iLmN1c3RvbVByb3BlcnRpZXMsXG4gICAgICBhY3RpdmUgPSBfYi5hY3RpdmUsXG4gICAgICBkaXNhYmxlZCA9IF9iLmRpc2FibGVkLFxuICAgICAgaGlnaGxpZ2h0ZWQgPSBfYi5oaWdobGlnaHRlZCxcbiAgICAgIGlzUGxhY2Vob2xkZXIgPSBfYi5wbGFjZWhvbGRlcjtcbiAgICB2YXIgZGl2ID0gT2JqZWN0LmFzc2lnbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgKF9jID0ge1xuICAgICAgY2xhc3NOYW1lOiBpdGVtXG4gICAgfSwgX2NbYWxsb3dIVE1MID8gJ2lubmVySFRNTCcgOiAnaW5uZXJUZXh0J10gPSBsYWJlbCwgX2MpKTtcbiAgICBPYmplY3QuYXNzaWduKGRpdi5kYXRhc2V0LCB7XG4gICAgICBpdGVtOiAnJyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGN1c3RvbVByb3BlcnRpZXM6IGN1c3RvbVByb3BlcnRpZXNcbiAgICB9KTtcbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICB9XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICB9XG4gICAgaWYgKGlzUGxhY2Vob2xkZXIpIHtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKHBsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgZGl2LmNsYXNzTGlzdC5hZGQoaGlnaGxpZ2h0ZWQgPyBoaWdobGlnaHRlZFN0YXRlIDogaXRlbVNlbGVjdGFibGUpO1xuICAgIGlmIChyZW1vdmVJdGVtQnV0dG9uKSB7XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgZGl2LmNsYXNzTGlzdC5yZW1vdmUoaXRlbVNlbGVjdGFibGUpO1xuICAgICAgfVxuICAgICAgZGl2LmRhdGFzZXQuZGVsZXRhYmxlID0gJyc7XG4gICAgICAvKiogQHRvZG8gVGhpcyBNVVNUIGJlIGxvY2FsaXphYmxlLCBub3QgaGFyZGNvZGVkISAqL1xuICAgICAgdmFyIFJFTU9WRV9JVEVNX1RFWFQgPSAnUmVtb3ZlIGl0ZW0nO1xuICAgICAgdmFyIHJlbW92ZUJ1dHRvbiA9IE9iamVjdC5hc3NpZ24oZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyksIChfZCA9IHtcbiAgICAgICAgdHlwZTogJ2J1dHRvbicsXG4gICAgICAgIGNsYXNzTmFtZTogYnV0dG9uXG4gICAgICB9LCBfZFthbGxvd0hUTUwgPyAnaW5uZXJIVE1MJyA6ICdpbm5lclRleHQnXSA9IFJFTU9WRV9JVEVNX1RFWFQsIF9kKSk7XG4gICAgICByZW1vdmVCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgXCJcIi5jb25jYXQoUkVNT1ZFX0lURU1fVEVYVCwgXCI6ICdcIikuY29uY2F0KHZhbHVlLCBcIidcIikpO1xuICAgICAgcmVtb3ZlQnV0dG9uLmRhdGFzZXQuYnV0dG9uID0gJyc7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQocmVtb3ZlQnV0dG9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpdjtcbiAgfSxcbiAgY2hvaWNlTGlzdDogZnVuY3Rpb24gKF9hLCBpc1NlbGVjdE9uZUVsZW1lbnQpIHtcbiAgICB2YXIgbGlzdCA9IF9hLmNsYXNzTmFtZXMubGlzdDtcbiAgICB2YXIgZGl2ID0gT2JqZWN0LmFzc2lnbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwge1xuICAgICAgY2xhc3NOYW1lOiBsaXN0XG4gICAgfSk7XG4gICAgaWYgKCFpc1NlbGVjdE9uZUVsZW1lbnQpIHtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJywgJ3RydWUnKTtcbiAgICB9XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgncm9sZScsICdsaXN0Ym94Jyk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfSxcbiAgY2hvaWNlR3JvdXA6IGZ1bmN0aW9uIChfYSwgX2IpIHtcbiAgICB2YXIgX2M7XG4gICAgdmFyIGFsbG93SFRNTCA9IF9hLmFsbG93SFRNTCxcbiAgICAgIF9kID0gX2EuY2xhc3NOYW1lcyxcbiAgICAgIGdyb3VwID0gX2QuZ3JvdXAsXG4gICAgICBncm91cEhlYWRpbmcgPSBfZC5ncm91cEhlYWRpbmcsXG4gICAgICBpdGVtRGlzYWJsZWQgPSBfZC5pdGVtRGlzYWJsZWQ7XG4gICAgdmFyIGlkID0gX2IuaWQsXG4gICAgICB2YWx1ZSA9IF9iLnZhbHVlLFxuICAgICAgZGlzYWJsZWQgPSBfYi5kaXNhYmxlZDtcbiAgICB2YXIgZGl2ID0gT2JqZWN0LmFzc2lnbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwge1xuICAgICAgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChncm91cCwgXCIgXCIpLmNvbmNhdChkaXNhYmxlZCA/IGl0ZW1EaXNhYmxlZCA6ICcnKVxuICAgIH0pO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcbiAgICBPYmplY3QuYXNzaWduKGRpdi5kYXRhc2V0LCB7XG4gICAgICBncm91cDogJycsXG4gICAgICBpZDogaWQsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgIH1cbiAgICBkaXYuYXBwZW5kQ2hpbGQoT2JqZWN0LmFzc2lnbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgKF9jID0ge1xuICAgICAgY2xhc3NOYW1lOiBncm91cEhlYWRpbmdcbiAgICB9LCBfY1thbGxvd0hUTUwgPyAnaW5uZXJIVE1MJyA6ICdpbm5lclRleHQnXSA9IHZhbHVlLCBfYykpKTtcbiAgICByZXR1cm4gZGl2O1xuICB9LFxuICBjaG9pY2U6IGZ1bmN0aW9uIChfYSwgX2IsIHNlbGVjdFRleHQpIHtcbiAgICB2YXIgX2M7XG4gICAgdmFyIGFsbG93SFRNTCA9IF9hLmFsbG93SFRNTCxcbiAgICAgIF9kID0gX2EuY2xhc3NOYW1lcyxcbiAgICAgIGl0ZW0gPSBfZC5pdGVtLFxuICAgICAgaXRlbUNob2ljZSA9IF9kLml0ZW1DaG9pY2UsXG4gICAgICBpdGVtU2VsZWN0YWJsZSA9IF9kLml0ZW1TZWxlY3RhYmxlLFxuICAgICAgc2VsZWN0ZWRTdGF0ZSA9IF9kLnNlbGVjdGVkU3RhdGUsXG4gICAgICBpdGVtRGlzYWJsZWQgPSBfZC5pdGVtRGlzYWJsZWQsXG4gICAgICBwbGFjZWhvbGRlciA9IF9kLnBsYWNlaG9sZGVyO1xuICAgIHZhciBpZCA9IF9iLmlkLFxuICAgICAgdmFsdWUgPSBfYi52YWx1ZSxcbiAgICAgIGxhYmVsID0gX2IubGFiZWwsXG4gICAgICBncm91cElkID0gX2IuZ3JvdXBJZCxcbiAgICAgIGVsZW1lbnRJZCA9IF9iLmVsZW1lbnRJZCxcbiAgICAgIGlzRGlzYWJsZWQgPSBfYi5kaXNhYmxlZCxcbiAgICAgIGlzU2VsZWN0ZWQgPSBfYi5zZWxlY3RlZCxcbiAgICAgIGlzUGxhY2Vob2xkZXIgPSBfYi5wbGFjZWhvbGRlcjtcbiAgICB2YXIgZGl2ID0gT2JqZWN0LmFzc2lnbihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgKF9jID0ge1xuICAgICAgaWQ6IGVsZW1lbnRJZFxuICAgIH0sIF9jW2FsbG93SFRNTCA/ICdpbm5lckhUTUwnIDogJ2lubmVyVGV4dCddID0gbGFiZWwsIF9jLmNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KGl0ZW0sIFwiIFwiKS5jb25jYXQoaXRlbUNob2ljZSksIF9jKSk7XG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKHNlbGVjdGVkU3RhdGUpO1xuICAgIH1cbiAgICBpZiAoaXNQbGFjZWhvbGRlcikge1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQocGxhY2Vob2xkZXIpO1xuICAgIH1cbiAgICBkaXYuc2V0QXR0cmlidXRlKCdyb2xlJywgZ3JvdXBJZCAmJiBncm91cElkID4gMCA/ICd0cmVlaXRlbScgOiAnb3B0aW9uJyk7XG4gICAgT2JqZWN0LmFzc2lnbihkaXYuZGF0YXNldCwge1xuICAgICAgY2hvaWNlOiAnJyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHNlbGVjdFRleHQ6IHNlbGVjdFRleHRcbiAgICB9KTtcbiAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoaXRlbURpc2FibGVkKTtcbiAgICAgIGRpdi5kYXRhc2V0LmNob2ljZURpc2FibGVkID0gJyc7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoaXRlbVNlbGVjdGFibGUpO1xuICAgICAgZGl2LmRhdGFzZXQuY2hvaWNlU2VsZWN0YWJsZSA9ICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGl2O1xuICB9LFxuICBpbnB1dDogZnVuY3Rpb24gKF9hLCBwbGFjZWhvbGRlclZhbHVlKSB7XG4gICAgdmFyIF9iID0gX2EuY2xhc3NOYW1lcyxcbiAgICAgIGlucHV0ID0gX2IuaW5wdXQsXG4gICAgICBpbnB1dENsb25lZCA9IF9iLmlucHV0Q2xvbmVkO1xuICAgIHZhciBpbnAgPSBPYmplY3QuYXNzaWduKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JyksIHtcbiAgICAgIHR5cGU6ICdzZWFyY2gnLFxuICAgICAgbmFtZTogJ3NlYXJjaF90ZXJtcycsXG4gICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KGlucHV0LCBcIiBcIikuY29uY2F0KGlucHV0Q2xvbmVkKSxcbiAgICAgIGF1dG9jb21wbGV0ZTogJ29mZicsXG4gICAgICBhdXRvY2FwaXRhbGl6ZTogJ29mZicsXG4gICAgICBzcGVsbGNoZWNrOiBmYWxzZVxuICAgIH0pO1xuICAgIGlucC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndGV4dGJveCcpO1xuICAgIGlucC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYXV0b2NvbXBsZXRlJywgJ2xpc3QnKTtcbiAgICBpbnAuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgcGxhY2Vob2xkZXJWYWx1ZSk7XG4gICAgcmV0dXJuIGlucDtcbiAgfSxcbiAgZHJvcGRvd246IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiA9IF9hLmNsYXNzTmFtZXMsXG4gICAgICBsaXN0ID0gX2IubGlzdCxcbiAgICAgIGxpc3REcm9wZG93biA9IF9iLmxpc3REcm9wZG93bjtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmNsYXNzTGlzdC5hZGQobGlzdCwgbGlzdERyb3Bkb3duKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfSxcbiAgbm90aWNlOiBmdW5jdGlvbiAoX2EsIGlubmVyVGV4dCwgdHlwZSkge1xuICAgIHZhciBfYjtcbiAgICB2YXIgYWxsb3dIVE1MID0gX2EuYWxsb3dIVE1MLFxuICAgICAgX2MgPSBfYS5jbGFzc05hbWVzLFxuICAgICAgaXRlbSA9IF9jLml0ZW0sXG4gICAgICBpdGVtQ2hvaWNlID0gX2MuaXRlbUNob2ljZSxcbiAgICAgIG5vUmVzdWx0cyA9IF9jLm5vUmVzdWx0cyxcbiAgICAgIG5vQ2hvaWNlcyA9IF9jLm5vQ2hvaWNlcztcbiAgICBpZiAodHlwZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0eXBlID0gJyc7XG4gICAgfVxuICAgIHZhciBjbGFzc2VzID0gW2l0ZW0sIGl0ZW1DaG9pY2VdO1xuICAgIGlmICh0eXBlID09PSAnbm8tY2hvaWNlcycpIHtcbiAgICAgIGNsYXNzZXMucHVzaChub0Nob2ljZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25vLXJlc3VsdHMnKSB7XG4gICAgICBjbGFzc2VzLnB1c2gobm9SZXN1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIChfYiA9IHt9LCBfYlthbGxvd0hUTUwgPyAnaW5uZXJIVE1MJyA6ICdpbm5lclRleHQnXSA9IGlubmVyVGV4dCwgX2IuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJyksIF9iKSk7XG4gIH0sXG4gIG9wdGlvbjogZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGxhYmVsID0gX2EubGFiZWwsXG4gICAgICB2YWx1ZSA9IF9hLnZhbHVlLFxuICAgICAgY3VzdG9tUHJvcGVydGllcyA9IF9hLmN1c3RvbVByb3BlcnRpZXMsXG4gICAgICBhY3RpdmUgPSBfYS5hY3RpdmUsXG4gICAgICBkaXNhYmxlZCA9IF9hLmRpc2FibGVkO1xuICAgIHZhciBvcHQgPSBuZXcgT3B0aW9uKGxhYmVsLCB2YWx1ZSwgZmFsc2UsIGFjdGl2ZSk7XG4gICAgaWYgKGN1c3RvbVByb3BlcnRpZXMpIHtcbiAgICAgIG9wdC5kYXRhc2V0LmN1c3RvbVByb3BlcnRpZXMgPSBcIlwiLmNvbmNhdChjdXN0b21Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgb3B0LmRpc2FibGVkID0gISFkaXNhYmxlZDtcbiAgICByZXR1cm4gb3B0O1xuICB9XG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB0ZW1wbGF0ZXM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5OTY6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblxuXG52YXIgaXNNZXJnZWFibGVPYmplY3QgPSBmdW5jdGlvbiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKVxuXHRcdCYmICFpc1NwZWNpYWwodmFsdWUpXG59O1xuXG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcblx0dmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuXHRyZXR1cm4gc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG5cdFx0fHwgc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJ1xuXHRcdHx8IGlzUmVhY3RFbGVtZW50KHZhbHVlKVxufVxuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gY2FuVXNlU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xuXG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxufVxuXG5mdW5jdGlvbiBlbXB0eVRhcmdldCh2YWwpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge31cbn1cblxuZnVuY3Rpb24gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodmFsdWUsIG9wdGlvbnMpIHtcblx0cmV0dXJuIChvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHQ/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zKVxuXHRcdDogdmFsdWVcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0cmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuXHRpZiAoIW9wdGlvbnMuY3VzdG9tTWVyZ2UpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlXG5cdH1cblx0dmFyIGN1c3RvbU1lcmdlID0gb3B0aW9ucy5jdXN0b21NZXJnZShrZXkpO1xuXHRyZXR1cm4gdHlwZW9mIGN1c3RvbU1lcmdlID09PSAnZnVuY3Rpb24nID8gY3VzdG9tTWVyZ2UgOiBkZWVwbWVyZ2Vcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcblx0XHQ/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnByb3BlcnR5SXNFbnVtZXJhYmxlKHN5bWJvbClcblx0XHR9KVxuXHRcdDogW11cbn1cblxuZnVuY3Rpb24gZ2V0S2V5cyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuY29uY2F0KGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSlcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlJc09uT2JqZWN0KG9iamVjdCwgcHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gcHJvcGVydHkgaW4gb2JqZWN0XG5cdH0gY2F0Y2goXykge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbi8vIFByb3RlY3RzIGZyb20gcHJvdG90eXBlIHBvaXNvbmluZyBhbmQgdW5leHBlY3RlZCBtZXJnaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5mdW5jdGlvbiBwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSB7XG5cdHJldHVybiBwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpIC8vIFByb3BlcnRpZXMgYXJlIHNhZmUgdG8gbWVyZ2UgaWYgdGhleSBkb24ndCBleGlzdCBpbiB0aGUgdGFyZ2V0IHlldCxcblx0XHQmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSAvLyB1bnNhZmUgaWYgdGhleSBleGlzdCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLFxuXHRcdFx0JiYgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBrZXkpKSAvLyBhbmQgYWxzbyB1bnNhZmUgaWYgdGhleSdyZSBub25lbnVtZXJhYmxlLlxufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHR2YXIgZGVzdGluYXRpb24gPSB7fTtcblx0aWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuXHRcdGdldEtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHRhcmdldFtrZXldLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxuXHRnZXRLZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRpZiAocHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmIChwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3Qoc291cmNlW2tleV0pKSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uXG59XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuXHRvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0ID0gb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCB8fCBpc01lcmdlYWJsZU9iamVjdDtcblx0Ly8gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgaXMgYWRkZWQgdG8gYG9wdGlvbnNgIHNvIHRoYXQgY3VzdG9tIGFycmF5TWVyZ2UoKVxuXHQvLyBpbXBsZW1lbnRhdGlvbnMgY2FuIHVzZSBpdC4gVGhlIGNhbGxlciBtYXkgbm90IHJlcGxhY2UgaXQuXG5cdG9wdGlvbnMuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZDtcblxuXHR2YXIgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcblx0dmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdHZhciBzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoID0gc291cmNlSXNBcnJheSA9PT0gdGFyZ2V0SXNBcnJheTtcblxuXHRpZiAoIXNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2gpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2UgaWYgKHNvdXJjZUlzQXJyYXkpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5hcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fVxufVxuXG5kZWVwbWVyZ2UuYWxsID0gZnVuY3Rpb24gZGVlcG1lcmdlQWxsKGFycmF5LCBvcHRpb25zKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheScpXG5cdH1cblxuXHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKHByZXYsIG5leHQpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnMpXG5cdH0sIHt9KVxufTtcblxudmFyIGRlZXBtZXJnZV8xID0gZGVlcG1lcmdlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBtZXJnZV8xO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMjE6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBGdXNlOyB9XG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qKlxuICogRnVzZS5qcyB2Ni42LjIgLSBMaWdodHdlaWdodCBmdXp6eS1zZWFyY2ggKGh0dHA6Ly9mdXNlanMuaW8pXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDIyIEtpcm8gUmlzayAoaHR0cDovL2tpcm8ubWUpXG4gKiBBbGwgUmlnaHRzIFJlc2VydmVkLiBBcGFjaGUgU29mdHdhcmUgTGljZW5zZSAyLjBcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiAhQXJyYXkuaXNBcnJheVxuICAgID8gZ2V0VGFnKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWx1ZSlcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvYmFzZVRvU3RyaW5nLmpzXG5jb25zdCBJTkZJTklUWSA9IDEgLyAwO1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICBsZXQgcmVzdWx0ID0gdmFsdWUgKyAnJztcbiAgcmV0dXJuIHJlc3VsdCA9PSAnMCcgJiYgMSAvIHZhbHVlID09IC1JTkZJTklUWSA/ICctMCcgOiByZXN1bHRcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSlcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZydcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci9pc0Jvb2xlYW4uanNcbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlID09PSB0cnVlIHx8XG4gICAgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSAnW29iamVjdCBCb29sZWFuXScpXG4gIClcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuLy8gQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZSAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNCbGFuayh2YWx1ZSkge1xuICByZXR1cm4gIXZhbHVlLnRyaW0oKS5sZW5ndGhcbn1cblxuLy8gR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuLy8gQWRhcHRlZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvZ2V0VGFnLmpzXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGxcbiAgICA/IHZhbHVlID09PSB1bmRlZmluZWRcbiAgICAgID8gJ1tvYmplY3QgVW5kZWZpbmVkXSdcbiAgICAgIDogJ1tvYmplY3QgTnVsbF0nXG4gICAgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpXG59XG5cbmNvbnN0IEVYVEVOREVEX1NFQVJDSF9VTkFWQUlMQUJMRSA9ICdFeHRlbmRlZCBzZWFyY2ggaXMgbm90IGF2YWlsYWJsZSc7XG5cbmNvbnN0IElOQ09SUkVDVF9JTkRFWF9UWVBFID0gXCJJbmNvcnJlY3QgJ2luZGV4JyB0eXBlXCI7XG5cbmNvbnN0IExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWSA9IChrZXkpID0+XG4gIGBJbnZhbGlkIHZhbHVlIGZvciBrZXkgJHtrZXl9YDtcblxuY29uc3QgUEFUVEVSTl9MRU5HVEhfVE9PX0xBUkdFID0gKG1heCkgPT5cbiAgYFBhdHRlcm4gbGVuZ3RoIGV4Y2VlZHMgbWF4IG9mICR7bWF4fS5gO1xuXG5jb25zdCBNSVNTSU5HX0tFWV9QUk9QRVJUWSA9IChuYW1lKSA9PiBgTWlzc2luZyAke25hbWV9IHByb3BlcnR5IGluIGtleWA7XG5cbmNvbnN0IElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRSA9IChrZXkpID0+XG4gIGBQcm9wZXJ0eSAnd2VpZ2h0JyBpbiBrZXkgJyR7a2V5fScgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgO1xuXG5jb25zdCBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5jbGFzcyBLZXlTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGtleXMpIHtcbiAgICB0aGlzLl9rZXlzID0gW107XG4gICAgdGhpcy5fa2V5TWFwID0ge307XG5cbiAgICBsZXQgdG90YWxXZWlnaHQgPSAwO1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGxldCBvYmogPSBjcmVhdGVLZXkoa2V5KTtcblxuICAgICAgdG90YWxXZWlnaHQgKz0gb2JqLndlaWdodDtcblxuICAgICAgdGhpcy5fa2V5cy5wdXNoKG9iaik7XG4gICAgICB0aGlzLl9rZXlNYXBbb2JqLmlkXSA9IG9iajtcblxuICAgICAgdG90YWxXZWlnaHQgKz0gb2JqLndlaWdodDtcbiAgICB9KTtcblxuICAgIC8vIE5vcm1hbGl6ZSB3ZWlnaHRzIHNvIHRoYXQgdGhlaXIgc3VtIGlzIGVxdWFsIHRvIDFcbiAgICB0aGlzLl9rZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAga2V5LndlaWdodCAvPSB0b3RhbFdlaWdodDtcbiAgICB9KTtcbiAgfVxuICBnZXQoa2V5SWQpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5TWFwW2tleUlkXVxuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleXNcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuX2tleXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KGtleSkge1xuICBsZXQgcGF0aCA9IG51bGw7XG4gIGxldCBpZCA9IG51bGw7XG4gIGxldCBzcmMgPSBudWxsO1xuICBsZXQgd2VpZ2h0ID0gMTtcbiAgbGV0IGdldEZuID0gbnVsbDtcblxuICBpZiAoaXNTdHJpbmcoa2V5KSB8fCBpc0FycmF5KGtleSkpIHtcbiAgICBzcmMgPSBrZXk7XG4gICAgcGF0aCA9IGNyZWF0ZUtleVBhdGgoa2V5KTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFoYXNPd24uY2FsbChrZXksICduYW1lJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihNSVNTSU5HX0tFWV9QUk9QRVJUWSgnbmFtZScpKVxuICAgIH1cblxuICAgIGNvbnN0IG5hbWUgPSBrZXkubmFtZTtcbiAgICBzcmMgPSBuYW1lO1xuXG4gICAgaWYgKGhhc093bi5jYWxsKGtleSwgJ3dlaWdodCcpKSB7XG4gICAgICB3ZWlnaHQgPSBrZXkud2VpZ2h0O1xuXG4gICAgICBpZiAod2VpZ2h0IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOVkFMSURfS0VZX1dFSUdIVF9WQUxVRShuYW1lKSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXRoID0gY3JlYXRlS2V5UGF0aChuYW1lKTtcbiAgICBpZCA9IGNyZWF0ZUtleUlkKG5hbWUpO1xuICAgIGdldEZuID0ga2V5LmdldEZuO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aCwgaWQsIHdlaWdodCwgc3JjLCBnZXRGbiB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVBhdGgoa2V5KSB7XG4gIHJldHVybiBpc0FycmF5KGtleSkgPyBrZXkgOiBrZXkuc3BsaXQoJy4nKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlJZChrZXkpIHtcbiAgcmV0dXJuIGlzQXJyYXkoa2V5KSA/IGtleS5qb2luKCcuJykgOiBrZXlcbn1cblxuZnVuY3Rpb24gZ2V0KG9iaiwgcGF0aCkge1xuICBsZXQgbGlzdCA9IFtdO1xuICBsZXQgYXJyID0gZmFsc2U7XG5cbiAgY29uc3QgZGVlcEdldCA9IChvYmosIHBhdGgsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQob2JqKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghcGF0aFtpbmRleF0pIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGF0aCBsZWZ0LCB3ZSd2ZSBhcnJpdmVkIGF0IHRoZSBvYmplY3Qgd2UgY2FyZSBhYm91dC5cbiAgICAgIGxpc3QucHVzaChvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQga2V5ID0gcGF0aFtpbmRleF07XG5cbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIGxhc3QgdmFsdWUgaW4gdGhlIHBhdGgsIGFuZCBpZiBpdCdzIGEgc3RyaW5nL251bWJlci9ib29sLFxuICAgICAgLy8gYWRkIGl0IHRvIHRoZSBsaXN0XG4gICAgICBpZiAoXG4gICAgICAgIGluZGV4ID09PSBwYXRoLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgKGlzU3RyaW5nKHZhbHVlKSB8fCBpc051bWJlcih2YWx1ZSkgfHwgaXNCb29sZWFuKHZhbHVlKSlcbiAgICAgICkge1xuICAgICAgICBsaXN0LnB1c2godG9TdHJpbmcodmFsdWUpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgYXJyID0gdHJ1ZTtcbiAgICAgICAgLy8gU2VhcmNoIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGRlZXBHZXQodmFsdWVbaV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGF0aC5sZW5ndGgpIHtcbiAgICAgICAgLy8gQW4gb2JqZWN0LiBSZWN1cnNlIGZ1cnRoZXIuXG4gICAgICAgIGRlZXBHZXQodmFsdWUsIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IChzaW5jZSBwYXRoIHVzZWQgdG8gYmUgYSBzdHJpbmcpXG4gIGRlZXBHZXQob2JqLCBpc1N0cmluZyhwYXRoKSA/IHBhdGguc3BsaXQoJy4nKSA6IHBhdGgsIDApO1xuXG4gIHJldHVybiBhcnIgPyBsaXN0IDogbGlzdFswXVxufVxuXG5jb25zdCBNYXRjaE9wdGlvbnMgPSB7XG4gIC8vIFdoZXRoZXIgdGhlIG1hdGNoZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQgc2V0LiBXaGVuIGB0cnVlYCwgZWFjaCByZWNvcmQgaW4gdGhlIHJlc3VsdFxuICAvLyBzZXQgd2lsbCBpbmNsdWRlIHRoZSBpbmRpY2VzIG9mIHRoZSBtYXRjaGVkIGNoYXJhY3RlcnMuXG4gIC8vIFRoZXNlIGNhbiBjb25zZXF1ZW50bHkgYmUgdXNlZCBmb3IgaGlnaGxpZ2h0aW5nIHB1cnBvc2VzLlxuICBpbmNsdWRlTWF0Y2hlczogZmFsc2UsXG4gIC8vIFdoZW4gYHRydWVgLCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gd2lsbCBjb250aW51ZSB0byB0aGUgZW5kIG9mIGEgc2VhcmNoIHBhdHRlcm4gZXZlbiBpZlxuICAvLyBhIHBlcmZlY3QgbWF0Y2ggaGFzIGFscmVhZHkgYmVlbiBsb2NhdGVkIGluIHRoZSBzdHJpbmcuXG4gIGZpbmRBbGxNYXRjaGVzOiBmYWxzZSxcbiAgLy8gTWluaW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IG11c3QgYmUgbWF0Y2hlZCBiZWZvcmUgYSByZXN1bHQgaXMgY29uc2lkZXJlZCBhIG1hdGNoXG4gIG1pbk1hdGNoQ2hhckxlbmd0aDogMVxufTtcblxuY29uc3QgQmFzaWNPcHRpb25zID0ge1xuICAvLyBXaGVuIGB0cnVlYCwgdGhlIGFsZ29yaXRobSBjb250aW51ZXMgc2VhcmNoaW5nIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0IGV2ZW4gaWYgYSBwZXJmZWN0XG4gIC8vIG1hdGNoIGlzIGZvdW5kIGJlZm9yZSB0aGUgZW5kIG9mIHRoZSBzYW1lIGlucHV0LlxuICBpc0Nhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAvLyBXaGVuIHRydWUsIHRoZSBtYXRjaGluZyBmdW5jdGlvbiB3aWxsIGNvbnRpbnVlIHRvIHRoZSBlbmQgb2YgYSBzZWFyY2ggcGF0dGVybiBldmVuIGlmXG4gIGluY2x1ZGVTY29yZTogZmFsc2UsXG4gIC8vIExpc3Qgb2YgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgc2VhcmNoZWQuIFRoaXMgYWxzbyBzdXBwb3J0cyBuZXN0ZWQgcHJvcGVydGllcy5cbiAga2V5czogW10sXG4gIC8vIFdoZXRoZXIgdG8gc29ydCB0aGUgcmVzdWx0IGxpc3QsIGJ5IHNjb3JlXG4gIHNob3VsZFNvcnQ6IHRydWUsXG4gIC8vIERlZmF1bHQgc29ydCBmdW5jdGlvbjogc29ydCBieSBhc2NlbmRpbmcgc2NvcmUsIGFzY2VuZGluZyBpbmRleFxuICBzb3J0Rm46IChhLCBiKSA9PlxuICAgIGEuc2NvcmUgPT09IGIuc2NvcmUgPyAoYS5pZHggPCBiLmlkeCA/IC0xIDogMSkgOiBhLnNjb3JlIDwgYi5zY29yZSA/IC0xIDogMVxufTtcblxuY29uc3QgRnV6enlPcHRpb25zID0ge1xuICAvLyBBcHByb3hpbWF0ZWx5IHdoZXJlIGluIHRoZSB0ZXh0IGlzIHRoZSBwYXR0ZXJuIGV4cGVjdGVkIHRvIGJlIGZvdW5kP1xuICBsb2NhdGlvbjogMCxcbiAgLy8gQXQgd2hhdCBwb2ludCBkb2VzIHRoZSBtYXRjaCBhbGdvcml0aG0gZ2l2ZSB1cC4gQSB0aHJlc2hvbGQgb2YgJzAuMCcgcmVxdWlyZXMgYSBwZXJmZWN0IG1hdGNoXG4gIC8vIChvZiBib3RoIGxldHRlcnMgYW5kIGxvY2F0aW9uKSwgYSB0aHJlc2hvbGQgb2YgJzEuMCcgd291bGQgbWF0Y2ggYW55dGhpbmcuXG4gIHRocmVzaG9sZDogMC42LFxuICAvLyBEZXRlcm1pbmVzIGhvdyBjbG9zZSB0aGUgbWF0Y2ggbXVzdCBiZSB0byB0aGUgZnV6enkgbG9jYXRpb24gKHNwZWNpZmllZCBhYm92ZSkuXG4gIC8vIEFuIGV4YWN0IGxldHRlciBtYXRjaCB3aGljaCBpcyAnZGlzdGFuY2UnIGNoYXJhY3RlcnMgYXdheSBmcm9tIHRoZSBmdXp6eSBsb2NhdGlvblxuICAvLyB3b3VsZCBzY29yZSBhcyBhIGNvbXBsZXRlIG1pc21hdGNoLiBBIGRpc3RhbmNlIG9mICcwJyByZXF1aXJlcyB0aGUgbWF0Y2ggYmUgYXRcbiAgLy8gdGhlIGV4YWN0IGxvY2F0aW9uIHNwZWNpZmllZCwgYSB0aHJlc2hvbGQgb2YgJzEwMDAnIHdvdWxkIHJlcXVpcmUgYSBwZXJmZWN0IG1hdGNoXG4gIC8vIHRvIGJlIHdpdGhpbiA4MDAgY2hhcmFjdGVycyBvZiB0aGUgZnV6enkgbG9jYXRpb24gdG8gYmUgZm91bmQgdXNpbmcgYSAwLjggdGhyZXNob2xkLlxuICBkaXN0YW5jZTogMTAwXG59O1xuXG5jb25zdCBBZHZhbmNlZE9wdGlvbnMgPSB7XG4gIC8vIFdoZW4gYHRydWVgLCBpdCBlbmFibGVzIHRoZSB1c2Ugb2YgdW5peC1saWtlIHNlYXJjaCBjb21tYW5kc1xuICB1c2VFeHRlbmRlZFNlYXJjaDogZmFsc2UsXG4gIC8vIFRoZSBnZXQgZnVuY3Rpb24gdG8gdXNlIHdoZW4gZmV0Y2hpbmcgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgLy8gVGhlIGRlZmF1bHQgd2lsbCBzZWFyY2ggbmVzdGVkIHBhdGhzICppZSBmb28uYmFyLmJheipcbiAgZ2V0Rm46IGdldCxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHNlYXJjaCB3aWxsIGlnbm9yZSBgbG9jYXRpb25gIGFuZCBgZGlzdGFuY2VgLCBzbyBpdCB3b24ndCBtYXR0ZXJcbiAgLy8gd2hlcmUgaW4gdGhlIHN0cmluZyB0aGUgcGF0dGVybiBhcHBlYXJzLlxuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZnVzZWpzLmlvL2NvbmNlcHRzL3Njb3JpbmctdGhlb3J5Lmh0bWwjZnV6emluZXNzLXNjb3JlXG4gIGlnbm9yZUxvY2F0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBgdHJ1ZWAsIHRoZSBjYWxjdWxhdGlvbiBmb3IgdGhlIHJlbGV2YW5jZSBzY29yZSAodXNlZCBmb3Igc29ydGluZykgd2lsbFxuICAvLyBpZ25vcmUgdGhlIGZpZWxkLWxlbmd0aCBub3JtLlxuICAvLyBNb3JlIGluZm86IGh0dHBzOi8vZnVzZWpzLmlvL2NvbmNlcHRzL3Njb3JpbmctdGhlb3J5Lmh0bWwjZmllbGQtbGVuZ3RoLW5vcm1cbiAgaWdub3JlRmllbGROb3JtOiBmYWxzZSxcbiAgLy8gVGhlIHdlaWdodCB0byBkZXRlcm1pbmUgaG93IG11Y2ggZmllbGQgbGVuZ3RoIG5vcm0gZWZmZWN0cyBzY29yaW5nLlxuICBmaWVsZE5vcm1XZWlnaHQ6IDFcbn07XG5cbnZhciBDb25maWcgPSB7XG4gIC4uLkJhc2ljT3B0aW9ucyxcbiAgLi4uTWF0Y2hPcHRpb25zLFxuICAuLi5GdXp6eU9wdGlvbnMsXG4gIC4uLkFkdmFuY2VkT3B0aW9uc1xufTtcblxuY29uc3QgU1BBQ0UgPSAvW14gXSsvZztcblxuLy8gRmllbGQtbGVuZ3RoIG5vcm06IHRoZSBzaG9ydGVyIHRoZSBmaWVsZCwgdGhlIGhpZ2hlciB0aGUgd2VpZ2h0LlxuLy8gU2V0IHRvIDMgZGVjaW1hbHMgdG8gcmVkdWNlIGluZGV4IHNpemUuXG5mdW5jdGlvbiBub3JtKHdlaWdodCA9IDEsIG1hbnRpc3NhID0gMykge1xuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbSA9IE1hdGgucG93KDEwLCBtYW50aXNzYSk7XG5cbiAgcmV0dXJuIHtcbiAgICBnZXQodmFsdWUpIHtcbiAgICAgIGNvbnN0IG51bVRva2VucyA9IHZhbHVlLm1hdGNoKFNQQUNFKS5sZW5ndGg7XG5cbiAgICAgIGlmIChjYWNoZS5oYXMobnVtVG9rZW5zKSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KG51bVRva2VucylcbiAgICAgIH1cblxuICAgICAgLy8gRGVmYXVsdCBmdW5jdGlvbiBpcyAxL3NxcnQoeCksIHdlaWdodCBtYWtlcyB0aGF0IHZhcmlhYmxlXG4gICAgICBjb25zdCBub3JtID0gMSAvIE1hdGgucG93KG51bVRva2VucywgMC41ICogd2VpZ2h0KTtcblxuICAgICAgLy8gSW4gcGxhY2Ugb2YgYHRvRml4ZWQobWFudGlzc2EpYCwgZm9yIGZhc3RlciBjb21wdXRhdGlvblxuICAgICAgY29uc3QgbiA9IHBhcnNlRmxvYXQoTWF0aC5yb3VuZChub3JtICogbSkgLyBtKTtcblxuICAgICAgY2FjaGUuc2V0KG51bVRva2Vucywgbik7XG5cbiAgICAgIHJldHVybiBuXG4gICAgfSxcbiAgICBjbGVhcigpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEZ1c2VJbmRleCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBnZXRGbiA9IENvbmZpZy5nZXRGbixcbiAgICBmaWVsZE5vcm1XZWlnaHQgPSBDb25maWcuZmllbGROb3JtV2VpZ2h0XG4gIH0gPSB7fSkge1xuICAgIHRoaXMubm9ybSA9IG5vcm0oZmllbGROb3JtV2VpZ2h0LCAzKTtcbiAgICB0aGlzLmdldEZuID0gZ2V0Rm47XG4gICAgdGhpcy5pc0NyZWF0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0SW5kZXhSZWNvcmRzKCk7XG4gIH1cbiAgc2V0U291cmNlcyhkb2NzID0gW10pIHtcbiAgICB0aGlzLmRvY3MgPSBkb2NzO1xuICB9XG4gIHNldEluZGV4UmVjb3JkcyhyZWNvcmRzID0gW10pIHtcbiAgICB0aGlzLnJlY29yZHMgPSByZWNvcmRzO1xuICB9XG4gIHNldEtleXMoa2V5cyA9IFtdKSB7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICB0aGlzLl9rZXlzTWFwID0ge307XG4gICAga2V5cy5mb3JFYWNoKChrZXksIGlkeCkgPT4ge1xuICAgICAgdGhpcy5fa2V5c01hcFtrZXkuaWRdID0gaWR4O1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZSgpIHtcbiAgICBpZiAodGhpcy5pc0NyZWF0ZWQgfHwgIXRoaXMuZG9jcy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuaXNDcmVhdGVkID0gdHJ1ZTtcblxuICAgIC8vIExpc3QgaXMgQXJyYXk8U3RyaW5nPlxuICAgIGlmIChpc1N0cmluZyh0aGlzLmRvY3NbMF0pKSB7XG4gICAgICB0aGlzLmRvY3MuZm9yRWFjaCgoZG9jLCBkb2NJbmRleCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRTdHJpbmcoZG9jLCBkb2NJbmRleCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdCBpcyBBcnJheTxPYmplY3Q+XG4gICAgICB0aGlzLmRvY3MuZm9yRWFjaCgoZG9jLCBkb2NJbmRleCkgPT4ge1xuICAgICAgICB0aGlzLl9hZGRPYmplY3QoZG9jLCBkb2NJbmRleCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLm5vcm0uY2xlYXIoKTtcbiAgfVxuICAvLyBBZGRzIGEgZG9jIHRvIHRoZSBlbmQgb2YgdGhlIGluZGV4XG4gIGFkZChkb2MpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnNpemUoKTtcblxuICAgIGlmIChpc1N0cmluZyhkb2MpKSB7XG4gICAgICB0aGlzLl9hZGRTdHJpbmcoZG9jLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hZGRPYmplY3QoZG9jLCBpZHgpO1xuICAgIH1cbiAgfVxuICAvLyBSZW1vdmVzIHRoZSBkb2MgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBvZiB0aGUgaW5kZXhcbiAgcmVtb3ZlQXQoaWR4KSB7XG4gICAgdGhpcy5yZWNvcmRzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgLy8gQ2hhbmdlIHJlZiBpbmRleCBvZiBldmVyeSBzdWJzcXVlbnQgZG9jXG4gICAgZm9yIChsZXQgaSA9IGlkeCwgbGVuID0gdGhpcy5zaXplKCk7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5yZWNvcmRzW2ldLmkgLT0gMTtcbiAgICB9XG4gIH1cbiAgZ2V0VmFsdWVGb3JJdGVtQXRLZXlJZChpdGVtLCBrZXlJZCkge1xuICAgIHJldHVybiBpdGVtW3RoaXMuX2tleXNNYXBba2V5SWRdXVxuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb3Jkcy5sZW5ndGhcbiAgfVxuICBfYWRkU3RyaW5nKGRvYywgZG9jSW5kZXgpIHtcbiAgICBpZiAoIWlzRGVmaW5lZChkb2MpIHx8IGlzQmxhbmsoZG9jKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHJlY29yZCA9IHtcbiAgICAgIHY6IGRvYyxcbiAgICAgIGk6IGRvY0luZGV4LFxuICAgICAgbjogdGhpcy5ub3JtLmdldChkb2MpXG4gICAgfTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgX2FkZE9iamVjdChkb2MsIGRvY0luZGV4KSB7XG4gICAgbGV0IHJlY29yZCA9IHsgaTogZG9jSW5kZXgsICQ6IHt9IH07XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgZXZlcnkga2V5IChpLmUsIHBhdGgpLCBhbmQgZmV0Y2ggdGhlIHZhbHVlIGF0IHRoYXQga2V5XG4gICAgdGhpcy5rZXlzLmZvckVhY2goKGtleSwga2V5SW5kZXgpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGtleS5nZXRGbiA/IGtleS5nZXRGbihkb2MpIDogdGhpcy5nZXRGbihkb2MsIGtleS5wYXRoKTtcblxuICAgICAgaWYgKCFpc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbeyBuZXN0ZWRBcnJJbmRleDogLTEsIHZhbHVlIH1dO1xuXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB7IG5lc3RlZEFyckluZGV4LCB2YWx1ZSB9ID0gc3RhY2sucG9wKCk7XG5cbiAgICAgICAgICBpZiAoIWlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBzdWJSZWNvcmQgPSB7XG4gICAgICAgICAgICAgIHY6IHZhbHVlLFxuICAgICAgICAgICAgICBpOiBuZXN0ZWRBcnJJbmRleCxcbiAgICAgICAgICAgICAgbjogdGhpcy5ub3JtLmdldCh2YWx1ZSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN1YlJlY29yZHMucHVzaChzdWJSZWNvcmQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0sIGspID0+IHtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgbmVzdGVkQXJySW5kZXg6IGssXG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZHM7XG4gICAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKHZhbHVlKSAmJiAhaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IHN1YlJlY29yZCA9IHtcbiAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICBuOiB0aGlzLm5vcm0uZ2V0KHZhbHVlKVxuICAgICAgICB9O1xuXG4gICAgICAgIHJlY29yZC4kW2tleUluZGV4XSA9IHN1YlJlY29yZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMsXG4gICAgICByZWNvcmRzOiB0aGlzLnJlY29yZHNcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5kZXgoXG4gIGtleXMsXG4gIGRvY3MsXG4gIHsgZ2V0Rm4gPSBDb25maWcuZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCA9IENvbmZpZy5maWVsZE5vcm1XZWlnaHQgfSA9IHt9XG4pIHtcbiAgY29uc3QgbXlJbmRleCA9IG5ldyBGdXNlSW5kZXgoeyBnZXRGbiwgZmllbGROb3JtV2VpZ2h0IH0pO1xuICBteUluZGV4LnNldEtleXMoa2V5cy5tYXAoY3JlYXRlS2V5KSk7XG4gIG15SW5kZXguc2V0U291cmNlcyhkb2NzKTtcbiAgbXlJbmRleC5jcmVhdGUoKTtcbiAgcmV0dXJuIG15SW5kZXhcbn1cblxuZnVuY3Rpb24gcGFyc2VJbmRleChcbiAgZGF0YSxcbiAgeyBnZXRGbiA9IENvbmZpZy5nZXRGbiwgZmllbGROb3JtV2VpZ2h0ID0gQ29uZmlnLmZpZWxkTm9ybVdlaWdodCB9ID0ge31cbikge1xuICBjb25zdCB7IGtleXMsIHJlY29yZHMgfSA9IGRhdGE7XG4gIGNvbnN0IG15SW5kZXggPSBuZXcgRnVzZUluZGV4KHsgZ2V0Rm4sIGZpZWxkTm9ybVdlaWdodCB9KTtcbiAgbXlJbmRleC5zZXRLZXlzKGtleXMpO1xuICBteUluZGV4LnNldEluZGV4UmVjb3JkcyhyZWNvcmRzKTtcbiAgcmV0dXJuIG15SW5kZXhcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlJDEoXG4gIHBhdHRlcm4sXG4gIHtcbiAgICBlcnJvcnMgPSAwLFxuICAgIGN1cnJlbnRMb2NhdGlvbiA9IDAsXG4gICAgZXhwZWN0ZWRMb2NhdGlvbiA9IDAsXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgfSA9IHt9XG4pIHtcbiAgY29uc3QgYWNjdXJhY3kgPSBlcnJvcnMgLyBwYXR0ZXJuLmxlbmd0aDtcblxuICBpZiAoaWdub3JlTG9jYXRpb24pIHtcbiAgICByZXR1cm4gYWNjdXJhY3lcbiAgfVxuXG4gIGNvbnN0IHByb3hpbWl0eSA9IE1hdGguYWJzKGV4cGVjdGVkTG9jYXRpb24gLSBjdXJyZW50TG9jYXRpb24pO1xuXG4gIGlmICghZGlzdGFuY2UpIHtcbiAgICAvLyBEb2RnZSBkaXZpZGUgYnkgemVybyBlcnJvci5cbiAgICByZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3lcbiAgfVxuXG4gIHJldHVybiBhY2N1cmFjeSArIHByb3hpbWl0eSAvIGRpc3RhbmNlXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRNYXNrVG9JbmRpY2VzKFxuICBtYXRjaG1hc2sgPSBbXSxcbiAgbWluTWF0Y2hDaGFyTGVuZ3RoID0gQ29uZmlnLm1pbk1hdGNoQ2hhckxlbmd0aFxuKSB7XG4gIGxldCBpbmRpY2VzID0gW107XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGxldCBsZW4gPSBtYXRjaG1hc2subGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaG1hc2tbaV07XG4gICAgaWYgKG1hdGNoICYmIHN0YXJ0ID09PSAtMSkge1xuICAgICAgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoICYmIHN0YXJ0ICE9PSAtMSkge1xuICAgICAgZW5kID0gaSAtIDE7XG4gICAgICBpZiAoZW5kIC0gc3RhcnQgKyAxID49IG1pbk1hdGNoQ2hhckxlbmd0aCkge1xuICAgICAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBlbmRdKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gLTE7XG4gICAgfVxuICB9XG5cbiAgLy8gKGktMSAtIHN0YXJ0KSArIDEgPT4gaSAtIHN0YXJ0XG4gIGlmIChtYXRjaG1hc2tbaSAtIDFdICYmIGkgLSBzdGFydCA+PSBtaW5NYXRjaENoYXJMZW5ndGgpIHtcbiAgICBpbmRpY2VzLnB1c2goW3N0YXJ0LCBpIC0gMV0pO1xuICB9XG5cbiAgcmV0dXJuIGluZGljZXNcbn1cblxuLy8gTWFjaGluZSB3b3JkIHNpemVcbmNvbnN0IE1BWF9CSVRTID0gMzI7XG5cbmZ1bmN0aW9uIHNlYXJjaChcbiAgdGV4dCxcbiAgcGF0dGVybixcbiAgcGF0dGVybkFscGhhYmV0LFxuICB7XG4gICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2UsXG4gICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICBtaW5NYXRjaENoYXJMZW5ndGggPSBDb25maWcubWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgIGluY2x1ZGVNYXRjaGVzID0gQ29uZmlnLmluY2x1ZGVNYXRjaGVzLFxuICAgIGlnbm9yZUxvY2F0aW9uID0gQ29uZmlnLmlnbm9yZUxvY2F0aW9uXG4gIH0gPSB7fVxuKSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IE1BWF9CSVRTKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRShNQVhfQklUUykpXG4gIH1cblxuICBjb25zdCBwYXR0ZXJuTGVuID0gcGF0dGVybi5sZW5ndGg7XG4gIC8vIFNldCBzdGFydGluZyBsb2NhdGlvbiBhdCBiZWdpbm5pbmcgdGV4dCBhbmQgaW5pdGlhbGl6ZSB0aGUgYWxwaGFiZXQuXG4gIGNvbnN0IHRleHRMZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZW4gbG9jYXRpb24gPiB0ZXh0Lmxlbmd0aFxuICBjb25zdCBleHBlY3RlZExvY2F0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jYXRpb24sIHRleHRMZW4pKTtcbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cbiAgbGV0IGN1cnJlbnRUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gIC8vIElzIHRoZXJlIGEgbmVhcmJ5IGV4YWN0IG1hdGNoPyAoc3BlZWR1cClcbiAgbGV0IGJlc3RMb2NhdGlvbiA9IGV4cGVjdGVkTG9jYXRpb247XG5cbiAgLy8gUGVyZm9ybWFuY2U6IG9ubHkgY29tcHV0ZXIgbWF0Y2hlcyB3aGVuIHRoZSBtaW5NYXRjaENoYXJMZW5ndGggPiAxXG4gIC8vIE9SIGlmIGBpbmNsdWRlTWF0Y2hlc2AgaXMgdHJ1ZS5cbiAgY29uc3QgY29tcHV0ZU1hdGNoZXMgPSBtaW5NYXRjaENoYXJMZW5ndGggPiAxIHx8IGluY2x1ZGVNYXRjaGVzO1xuICAvLyBBIG1hc2sgb2YgdGhlIG1hdGNoZXMsIHVzZWQgZm9yIGJ1aWxkaW5nIHRoZSBpbmRpY2VzXG4gIGNvbnN0IG1hdGNoTWFzayA9IGNvbXB1dGVNYXRjaGVzID8gQXJyYXkodGV4dExlbikgOiBbXTtcblxuICBsZXQgaW5kZXg7XG5cbiAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzLCBoZXJlIGZvciBzcGVlZCB1cFxuICB3aGlsZSAoKGluZGV4ID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGJlc3RMb2NhdGlvbikpID4gLTEpIHtcbiAgICBsZXQgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICBjdXJyZW50TG9jYXRpb246IGluZGV4LFxuICAgICAgZXhwZWN0ZWRMb2NhdGlvbixcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgaWdub3JlTG9jYXRpb25cbiAgICB9KTtcblxuICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBNYXRoLm1pbihzY29yZSwgY3VycmVudFRocmVzaG9sZCk7XG4gICAgYmVzdExvY2F0aW9uID0gaW5kZXggKyBwYXR0ZXJuTGVuO1xuXG4gICAgaWYgKGNvbXB1dGVNYXRjaGVzKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IHBhdHRlcm5MZW4pIHtcbiAgICAgICAgbWF0Y2hNYXNrW2luZGV4ICsgaV0gPSAxO1xuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVzZXQgdGhlIGJlc3QgbG9jYXRpb25cbiAgYmVzdExvY2F0aW9uID0gLTE7XG5cbiAgbGV0IGxhc3RCaXRBcnIgPSBbXTtcbiAgbGV0IGZpbmFsU2NvcmUgPSAxO1xuICBsZXQgYmluTWF4ID0gcGF0dGVybkxlbiArIHRleHRMZW47XG5cbiAgY29uc3QgbWFzayA9IDEgPDwgKHBhdHRlcm5MZW4gLSAxKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdHRlcm5MZW47IGkgKz0gMSkge1xuICAgIC8vIFNjYW4gZm9yIHRoZSBiZXN0IG1hdGNoOyBlYWNoIGl0ZXJhdGlvbiBhbGxvd3MgZm9yIG9uZSBtb3JlIGVycm9yLlxuICAgIC8vIFJ1biBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIGhvdyBmYXIgZnJvbSB0aGUgbWF0Y2ggbG9jYXRpb24gd2UgY2FuIHN0cmF5XG4gICAgLy8gYXQgdGhpcyBlcnJvciBsZXZlbC5cbiAgICBsZXQgYmluTWluID0gMDtcbiAgICBsZXQgYmluTWlkID0gYmluTWF4O1xuXG4gICAgd2hpbGUgKGJpbk1pbiA8IGJpbk1pZCkge1xuICAgICAgY29uc3Qgc2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICAgIGVycm9yczogaSxcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBleHBlY3RlZExvY2F0aW9uICsgYmluTWlkLFxuICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICBiaW5NaW4gPSBiaW5NaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaW5NYXggPSBiaW5NaWQ7XG4gICAgICB9XG5cbiAgICAgIGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIHJlc3VsdCBmcm9tIHRoaXMgaXRlcmF0aW9uIGFzIHRoZSBtYXhpbXVtIGZvciB0aGUgbmV4dC5cbiAgICBiaW5NYXggPSBiaW5NaWQ7XG5cbiAgICBsZXQgc3RhcnQgPSBNYXRoLm1heCgxLCBleHBlY3RlZExvY2F0aW9uIC0gYmluTWlkICsgMSk7XG4gICAgbGV0IGZpbmlzaCA9IGZpbmRBbGxNYXRjaGVzXG4gICAgICA/IHRleHRMZW5cbiAgICAgIDogTWF0aC5taW4oZXhwZWN0ZWRMb2NhdGlvbiArIGJpbk1pZCwgdGV4dExlbikgKyBwYXR0ZXJuTGVuO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgYml0IGFycmF5XG4gICAgbGV0IGJpdEFyciA9IEFycmF5KGZpbmlzaCArIDIpO1xuXG4gICAgYml0QXJyW2ZpbmlzaCArIDFdID0gKDEgPDwgaSkgLSAxO1xuXG4gICAgZm9yIChsZXQgaiA9IGZpbmlzaDsgaiA+PSBzdGFydDsgaiAtPSAxKSB7XG4gICAgICBsZXQgY3VycmVudExvY2F0aW9uID0gaiAtIDE7XG4gICAgICBsZXQgY2hhck1hdGNoID0gcGF0dGVybkFscGhhYmV0W3RleHQuY2hhckF0KGN1cnJlbnRMb2NhdGlvbildO1xuXG4gICAgICBpZiAoY29tcHV0ZU1hdGNoZXMpIHtcbiAgICAgICAgLy8gU3BlZWQgdXA6IHF1aWNrIGJvb2wgdG8gaW50IGNvbnZlcnNpb24gKGkuZSwgYGNoYXJNYXRjaCA/IDEgOiAwYClcbiAgICAgICAgbWF0Y2hNYXNrW2N1cnJlbnRMb2NhdGlvbl0gPSArISFjaGFyTWF0Y2g7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0IHBhc3M6IGV4YWN0IG1hdGNoXG4gICAgICBiaXRBcnJbal0gPSAoKGJpdEFycltqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcblxuICAgICAgLy8gU3Vic2VxdWVudCBwYXNzZXM6IGZ1enp5IG1hdGNoXG4gICAgICBpZiAoaSkge1xuICAgICAgICBiaXRBcnJbal0gfD1cbiAgICAgICAgICAoKGxhc3RCaXRBcnJbaiArIDFdIHwgbGFzdEJpdEFycltqXSkgPDwgMSkgfCAxIHwgbGFzdEJpdEFycltqICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChiaXRBcnJbal0gJiBtYXNrKSB7XG4gICAgICAgIGZpbmFsU2NvcmUgPSBjb21wdXRlU2NvcmUkMShwYXR0ZXJuLCB7XG4gICAgICAgICAgZXJyb3JzOiBpLFxuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgICAgIGRpc3RhbmNlLFxuICAgICAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFRoaXMgbWF0Y2ggd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJlIGJldHRlciB0aGFuIGFueSBleGlzdGluZyBtYXRjaC5cbiAgICAgICAgLy8gQnV0IGNoZWNrIGFueXdheS5cbiAgICAgICAgaWYgKGZpbmFsU2NvcmUgPD0gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgICAgIC8vIEluZGVlZCBpdCBpc1xuICAgICAgICAgIGN1cnJlbnRUaHJlc2hvbGQgPSBmaW5hbFNjb3JlO1xuICAgICAgICAgIGJlc3RMb2NhdGlvbiA9IGN1cnJlbnRMb2NhdGlvbjtcblxuICAgICAgICAgIC8vIEFscmVhZHkgcGFzc2VkIGBsb2NgLCBkb3duaGlsbCBmcm9tIGhlcmUgb24gaW4uXG4gICAgICAgICAgaWYgKGJlc3RMb2NhdGlvbiA8PSBleHBlY3RlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdoZW4gcGFzc2luZyBgYmVzdExvY2F0aW9uYCwgZG9uJ3QgZXhjZWVkIG91ciBjdXJyZW50IGRpc3RhbmNlIGZyb20gYGV4cGVjdGVkTG9jYXRpb25gLlxuICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGV4cGVjdGVkTG9jYXRpb24gLSBiZXN0TG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gaG9wZSBmb3IgYSAoYmV0dGVyKSBtYXRjaCBhdCBncmVhdGVyIGVycm9yIGxldmVscy5cbiAgICBjb25zdCBzY29yZSA9IGNvbXB1dGVTY29yZSQxKHBhdHRlcm4sIHtcbiAgICAgIGVycm9yczogaSArIDEsXG4gICAgICBjdXJyZW50TG9jYXRpb246IGV4cGVjdGVkTG9jYXRpb24sXG4gICAgICBleHBlY3RlZExvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHNjb3JlID4gY3VycmVudFRocmVzaG9sZCkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBsYXN0Qml0QXJyID0gYml0QXJyO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlzTWF0Y2g6IGJlc3RMb2NhdGlvbiA+PSAwLFxuICAgIC8vIENvdW50IGV4YWN0IG1hdGNoZXMgKHRob3NlIHdpdGggYSBzY29yZSBvZiAwKSB0byBiZSBcImFsbW9zdFwiIGV4YWN0XG4gICAgc2NvcmU6IE1hdGgubWF4KDAuMDAxLCBmaW5hbFNjb3JlKVxuICB9O1xuXG4gIGlmIChjb21wdXRlTWF0Y2hlcykge1xuICAgIGNvbnN0IGluZGljZXMgPSBjb252ZXJ0TWFza1RvSW5kaWNlcyhtYXRjaE1hc2ssIG1pbk1hdGNoQ2hhckxlbmd0aCk7XG4gICAgaWYgKCFpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LmlzTWF0Y2ggPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICByZXN1bHQuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXR0ZXJuQWxwaGFiZXQocGF0dGVybikge1xuICBsZXQgbWFzayA9IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgY29uc3QgY2hhciA9IHBhdHRlcm4uY2hhckF0KGkpO1xuICAgIG1hc2tbY2hhcl0gPSAobWFza1tjaGFyXSB8fCAwKSB8ICgxIDw8IChsZW4gLSBpIC0gMSkpO1xuICB9XG5cbiAgcmV0dXJuIG1hc2tcbn1cblxuY2xhc3MgQml0YXBTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBpc0Nhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgdGhpcy5jaHVua3MgPSBbXTtcblxuICAgIGlmICghdGhpcy5wYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgYWRkQ2h1bmsgPSAocGF0dGVybiwgc3RhcnRJbmRleCkgPT4ge1xuICAgICAgdGhpcy5jaHVua3MucHVzaCh7XG4gICAgICAgIHBhdHRlcm4sXG4gICAgICAgIGFscGhhYmV0OiBjcmVhdGVQYXR0ZXJuQWxwaGFiZXQocGF0dGVybiksXG4gICAgICAgIHN0YXJ0SW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjb25zdCBsZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA+IE1BWF9CSVRTKSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBjb25zdCByZW1haW5kZXIgPSBsZW4gJSBNQVhfQklUUztcbiAgICAgIGNvbnN0IGVuZCA9IGxlbiAtIHJlbWFpbmRlcjtcblxuICAgICAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLnN1YnN0cihpLCBNQVhfQklUUyksIGkpO1xuICAgICAgICBpICs9IE1BWF9CSVRTO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtYWluZGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBsZW4gLSBNQVhfQklUUztcbiAgICAgICAgYWRkQ2h1bmsodGhpcy5wYXR0ZXJuLnN1YnN0cihzdGFydEluZGV4KSwgc3RhcnRJbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZENodW5rKHRoaXMucGF0dGVybiwgMCk7XG4gICAgfVxuICB9XG5cbiAgc2VhcmNoSW4odGV4dCkge1xuICAgIGNvbnN0IHsgaXNDYXNlU2Vuc2l0aXZlLCBpbmNsdWRlTWF0Y2hlcyB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCFpc0Nhc2VTZW5zaXRpdmUpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLy8gRXhhY3QgbWF0Y2hcbiAgICBpZiAodGhpcy5wYXR0ZXJuID09PSB0ZXh0KSB7XG4gICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICBzY29yZTogMFxuICAgICAgfTtcblxuICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgIHJlc3VsdC5pbmRpY2VzID0gW1swLCB0ZXh0Lmxlbmd0aCAtIDFdXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgdXNlIEJpdGFwIGFsZ29yaXRobVxuICAgIGNvbnN0IHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCxcbiAgICAgIGlnbm9yZUxvY2F0aW9uXG4gICAgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGxldCBhbGxJbmRpY2VzID0gW107XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAwO1xuICAgIGxldCBoYXNNYXRjaGVzID0gZmFsc2U7XG5cbiAgICB0aGlzLmNodW5rcy5mb3JFYWNoKCh7IHBhdHRlcm4sIGFscGhhYmV0LCBzdGFydEluZGV4IH0pID0+IHtcbiAgICAgIGNvbnN0IHsgaXNNYXRjaCwgc2NvcmUsIGluZGljZXMgfSA9IHNlYXJjaCh0ZXh0LCBwYXR0ZXJuLCBhbHBoYWJldCwge1xuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24gKyBzdGFydEluZGV4LFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgICAgbWluTWF0Y2hDaGFyTGVuZ3RoLFxuICAgICAgICBpbmNsdWRlTWF0Y2hlcyxcbiAgICAgICAgaWdub3JlTG9jYXRpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNNYXRjaCkge1xuICAgICAgICBoYXNNYXRjaGVzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdG90YWxTY29yZSArPSBzY29yZTtcblxuICAgICAgaWYgKGlzTWF0Y2ggJiYgaW5kaWNlcykge1xuICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgIGlzTWF0Y2g6IGhhc01hdGNoZXMsXG4gICAgICBzY29yZTogaGFzTWF0Y2hlcyA/IHRvdGFsU2NvcmUgLyB0aGlzLmNodW5rcy5sZW5ndGggOiAxXG4gICAgfTtcblxuICAgIGlmIChoYXNNYXRjaGVzICYmIGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICByZXN1bHQuaW5kaWNlcyA9IGFsbEluZGljZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbmNsYXNzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICB9XG4gIHN0YXRpYyBpc011bHRpTWF0Y2gocGF0dGVybikge1xuICAgIHJldHVybiBnZXRNYXRjaChwYXR0ZXJuLCB0aGlzLm11bHRpUmVnZXgpXG4gIH1cbiAgc3RhdGljIGlzU2luZ2xlTWF0Y2gocGF0dGVybikge1xuICAgIHJldHVybiBnZXRNYXRjaChwYXR0ZXJuLCB0aGlzLnNpbmdsZVJlZ2V4KVxuICB9XG4gIHNlYXJjaCgvKnRleHQqLykge31cbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2gocGF0dGVybiwgZXhwKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBwYXR0ZXJuLm1hdGNoKGV4cCk7XG4gIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6IG51bGxcbn1cblxuLy8gVG9rZW46ICdmaWxlXG5cbmNsYXNzIEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXj1cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL149KC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dCA9PT0gdGhpcy5wYXR0ZXJuO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRoaXMucGF0dGVybi5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIWZpcmVcblxuY2xhc3MgSW52ZXJzZUV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVwiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiEoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGV4dC5pbmRleE9mKHRoaXMucGF0dGVybik7XG4gICAgY29uc3QgaXNNYXRjaCA9IGluZGV4ID09PSAtMTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiBeZmlsZVxuXG5jbGFzcyBQcmVmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3ByZWZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXFxeXCIoLiopXCIkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXFxeKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dC5zdGFydHNXaXRoKHRoaXMucGF0dGVybik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNNYXRjaCxcbiAgICAgIHNjb3JlOiBpc01hdGNoID8gMCA6IDEsXG4gICAgICBpbmRpY2VzOiBbMCwgdGhpcy5wYXR0ZXJuLmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIFRva2VuOiAhXmZpcmVcblxuY2xhc3MgSW52ZXJzZVByZWZpeEV4YWN0TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW52ZXJzZS1wcmVmaXgtZXhhY3QnXG4gIH1cbiAgc3RhdGljIGdldCBtdWx0aVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiFcXF5cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14hXFxeKC4qKSQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gIXRleHQuc3RhcnRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogWzAsIHRleHQubGVuZ3RoIC0gMV1cbiAgICB9XG4gIH1cbn1cblxuLy8gVG9rZW46IC5maWxlJFxuXG5jbGFzcyBTdWZmaXhFeGFjdE1hdGNoIGV4dGVuZHMgQmFzZU1hdGNoIHtcbiAgY29uc3RydWN0b3IocGF0dGVybikge1xuICAgIHN1cGVyKHBhdHRlcm4pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3N1ZmZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eXCIoLiopXCJcXCQkL1xuICB9XG4gIHN0YXRpYyBnZXQgc2luZ2xlUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eKC4qKVxcJCQvXG4gIH1cbiAgc2VhcmNoKHRleHQpIHtcbiAgICBjb25zdCBpc01hdGNoID0gdGV4dC5lbmRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2gsXG4gICAgICBzY29yZTogaXNNYXRjaCA/IDAgOiAxLFxuICAgICAgaW5kaWNlczogW3RleHQubGVuZ3RoIC0gdGhpcy5wYXR0ZXJuLmxlbmd0aCwgdGV4dC5sZW5ndGggLSAxXVxuICAgIH1cbiAgfVxufVxuXG4vLyBUb2tlbjogIS5maWxlJFxuXG5jbGFzcyBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCBleHRlbmRzIEJhc2VNYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgICBzdXBlcihwYXR0ZXJuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdpbnZlcnNlLXN1ZmZpeC1leGFjdCdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eIVwiKC4qKVwiXFwkJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXiEoLiopXFwkJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGNvbnN0IGlzTWF0Y2ggPSAhdGV4dC5lbmRzV2l0aCh0aGlzLnBhdHRlcm4pO1xuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXM6IFswLCB0ZXh0Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIEZ1enp5TWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGxvY2F0aW9uID0gQ29uZmlnLmxvY2F0aW9uLFxuICAgICAgdGhyZXNob2xkID0gQ29uZmlnLnRocmVzaG9sZCxcbiAgICAgIGRpc3RhbmNlID0gQ29uZmlnLmRpc3RhbmNlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMgPSBDb25maWcuaW5jbHVkZU1hdGNoZXMsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyA9IENvbmZpZy5maW5kQWxsTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUgPSBDb25maWcuaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaWdub3JlTG9jYXRpb24gPSBDb25maWcuaWdub3JlTG9jYXRpb25cbiAgICB9ID0ge31cbiAgKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gICAgdGhpcy5fYml0YXBTZWFyY2ggPSBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwge1xuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZSxcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgZmluZEFsbE1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpZ25vcmVMb2NhdGlvblxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2Z1enp5J1xuICB9XG4gIHN0YXRpYyBnZXQgbXVsdGlSZWdleCgpIHtcbiAgICByZXR1cm4gL15cIiguKilcIiQvXG4gIH1cbiAgc3RhdGljIGdldCBzaW5nbGVSZWdleCgpIHtcbiAgICByZXR1cm4gL14oLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIHJldHVybiB0aGlzLl9iaXRhcFNlYXJjaC5zZWFyY2hJbih0ZXh0KVxuICB9XG59XG5cbi8vIFRva2VuOiAnZmlsZVxuXG5jbGFzcyBJbmNsdWRlTWF0Y2ggZXh0ZW5kcyBCYXNlTWF0Y2gge1xuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XG4gICAgc3VwZXIocGF0dGVybik7XG4gIH1cbiAgc3RhdGljIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnaW5jbHVkZSdcbiAgfVxuICBzdGF0aWMgZ2V0IG11bHRpUmVnZXgoKSB7XG4gICAgcmV0dXJuIC9eJ1wiKC4qKVwiJC9cbiAgfVxuICBzdGF0aWMgZ2V0IHNpbmdsZVJlZ2V4KCkge1xuICAgIHJldHVybiAvXicoLiopJC9cbiAgfVxuICBzZWFyY2godGV4dCkge1xuICAgIGxldCBsb2NhdGlvbiA9IDA7XG4gICAgbGV0IGluZGV4O1xuXG4gICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgIGNvbnN0IHBhdHRlcm5MZW4gPSB0aGlzLnBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgLy8gR2V0IGFsbCBleGFjdCBtYXRjaGVzXG4gICAgd2hpbGUgKChpbmRleCA9IHRleHQuaW5kZXhPZih0aGlzLnBhdHRlcm4sIGxvY2F0aW9uKSkgPiAtMSkge1xuICAgICAgbG9jYXRpb24gPSBpbmRleCArIHBhdHRlcm5MZW47XG4gICAgICBpbmRpY2VzLnB1c2goW2luZGV4LCBsb2NhdGlvbiAtIDFdKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc01hdGNoID0gISFpbmRpY2VzLmxlbmd0aDtcblxuICAgIHJldHVybiB7XG4gICAgICBpc01hdGNoLFxuICAgICAgc2NvcmU6IGlzTWF0Y2ggPyAwIDogMSxcbiAgICAgIGluZGljZXNcbiAgICB9XG4gIH1cbn1cblxuLy8g4p2XT3JkZXIgaXMgaW1wb3J0YW50LiBETyBOT1QgQ0hBTkdFLlxuY29uc3Qgc2VhcmNoZXJzID0gW1xuICBFeGFjdE1hdGNoLFxuICBJbmNsdWRlTWF0Y2gsXG4gIFByZWZpeEV4YWN0TWF0Y2gsXG4gIEludmVyc2VQcmVmaXhFeGFjdE1hdGNoLFxuICBJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCxcbiAgU3VmZml4RXhhY3RNYXRjaCxcbiAgSW52ZXJzZUV4YWN0TWF0Y2gsXG4gIEZ1enp5TWF0Y2hcbl07XG5cbmNvbnN0IHNlYXJjaGVyc0xlbiA9IHNlYXJjaGVycy5sZW5ndGg7XG5cbi8vIFJlZ2V4IHRvIHNwbGl0IGJ5IHNwYWNlcywgYnV0IGtlZXAgYW55dGhpbmcgaW4gcXVvdGVzIHRvZ2V0aGVyXG5jb25zdCBTUEFDRV9SRSA9IC8gKyg/PSg/OlteXFxcIl0qXFxcIlteXFxcIl0qXFxcIikqW15cXFwiXSokKS87XG5jb25zdCBPUl9UT0tFTiA9ICd8JztcblxuLy8gUmV0dXJuIGEgMkQgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHF1ZXJ5LCBmb3Igc2ltcGxlciBwYXJzaW5nLlxuLy8gRXhhbXBsZTpcbi8vIFwiXmNvcmUgZ28kIHwgcmIkIHwgcHkkIHh5JFwiID0+IFtbXCJeY29yZVwiLCBcImdvJFwiXSwgW1wicmIkXCJdLCBbXCJweSRcIiwgXCJ4eSRcIl1dXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5KHBhdHRlcm4sIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gcGF0dGVybi5zcGxpdChPUl9UT0tFTikubWFwKChpdGVtKSA9PiB7XG4gICAgbGV0IHF1ZXJ5ID0gaXRlbVxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KFNQQUNFX1JFKVxuICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAmJiAhIWl0ZW0udHJpbSgpKTtcblxuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHF1ZXJ5Lmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBxdWVyeUl0ZW0gPSBxdWVyeVtpXTtcblxuICAgICAgLy8gMS4gSGFuZGxlIG11bHRpcGxlIHF1ZXJ5IG1hdGNoIChpLmUsIG9uY2UgdGhhdCBhcmUgcXVvdGVkLCBsaWtlIGBcImhlbGxvIHdvcmxkXCJgKVxuICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICBsZXQgaWR4ID0gLTE7XG4gICAgICB3aGlsZSAoIWZvdW5kICYmICsraWR4IDwgc2VhcmNoZXJzTGVuKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gc2VhcmNoZXJzW2lkeF07XG4gICAgICAgIGxldCB0b2tlbiA9IHNlYXJjaGVyLmlzTXVsdGlNYXRjaChxdWVyeUl0ZW0pO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2gobmV3IHNlYXJjaGVyKHRva2VuLCBvcHRpb25zKSk7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyLiBIYW5kbGUgc2luZ2xlIHF1ZXJ5IG1hdGNoZXMgKGkuZSwgb25jZSB0aGF0IGFyZSAqbm90KiBxdW90ZWQpXG4gICAgICBpZHggPSAtMTtcbiAgICAgIHdoaWxlICgrK2lkeCA8IHNlYXJjaGVyc0xlbikge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tpZHhdO1xuICAgICAgICBsZXQgdG9rZW4gPSBzZWFyY2hlci5pc1NpbmdsZU1hdGNoKHF1ZXJ5SXRlbSk7XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgc2VhcmNoZXIodG9rZW4sIG9wdGlvbnMpKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfSlcbn1cblxuLy8gVGhlc2UgZXh0ZW5kZWQgbWF0Y2hlcnMgY2FuIHJldHVybiBhbiBhcnJheSBvZiBtYXRjaGVzLCBhcyBvcHBvc2VkXG4vLyB0byBhIHNpbmdsIG1hdGNoXG5jb25zdCBNdWx0aU1hdGNoU2V0ID0gbmV3IFNldChbRnV6enlNYXRjaC50eXBlLCBJbmNsdWRlTWF0Y2gudHlwZV0pO1xuXG4vKipcbiAqIENvbW1hbmQtbGlrZSBzZWFyY2hpbmdcbiAqID09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBHaXZlbiBtdWx0aXBsZSBzZWFyY2ggdGVybXMgZGVsaW1pdGVkIGJ5IHNwYWNlcy5lLmcuIGBeanNjcmlwdCAucHl0aG9uJCBydWJ5ICFqYXZhYCxcbiAqIHNlYXJjaCBpbiBhIGdpdmVuIHRleHQuXG4gKlxuICogU2VhcmNoIHN5bnRheDpcbiAqXG4gKiB8IFRva2VuICAgICAgIHwgTWF0Y2ggdHlwZSAgICAgICAgICAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IC0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8IGBqc2NyaXB0YCAgIHwgZnV6enktbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGZ1enp5IG1hdGNoIGBqc2NyaXB0YCAgICAgICB8XG4gKiB8IGA9c2NoZW1lYCAgIHwgZXhhY3QtbWF0Y2ggICAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGFyZSBgc2NoZW1lYCAgICAgICAgICAgICAgICB8XG4gKiB8IGAncHl0aG9uYCAgIHwgaW5jbHVkZS1tYXRjaCAgICAgICAgICAgICAgfCBJdGVtcyB0aGF0IGluY2x1ZGUgYHB5dGhvbmAgICAgICAgICAgICB8XG4gKiB8IGAhcnVieWAgICAgIHwgaW52ZXJzZS1leGFjdC1tYXRjaCAgICAgICAgfCBJdGVtcyB0aGF0IGRvIG5vdCBpbmNsdWRlIGBydWJ5YCAgICAgICB8XG4gKiB8IGBeamF2YWAgICAgIHwgcHJlZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IHN0YXJ0IHdpdGggYGphdmFgICAgICAgICAgICB8XG4gKiB8IGAhXmVhcmxhbmdgIHwgaW52ZXJzZS1wcmVmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIGBlYXJsYW5nYCB8XG4gKiB8IGAuanMkYCAgICAgIHwgc3VmZml4LWV4YWN0LW1hdGNoICAgICAgICAgfCBJdGVtcyB0aGF0IGVuZCB3aXRoIGAuanNgICAgICAgICAgICAgICB8XG4gKiB8IGAhLmdvJGAgICAgIHwgaW52ZXJzZS1zdWZmaXgtZXhhY3QtbWF0Y2ggfCBJdGVtcyB0aGF0IGRvIG5vdCBlbmQgd2l0aCBgLmdvYCAgICAgICB8XG4gKlxuICogQSBzaW5nbGUgcGlwZSBjaGFyYWN0ZXIgYWN0cyBhcyBhbiBPUiBvcGVyYXRvci4gRm9yIGV4YW1wbGUsIHRoZSBmb2xsb3dpbmdcbiAqIHF1ZXJ5IG1hdGNoZXMgZW50cmllcyB0aGF0IHN0YXJ0IHdpdGggYGNvcmVgIGFuZCBlbmQgd2l0aCBlaXRoZXJgZ29gLCBgcmJgLFxuICogb3JgcHlgLlxuICpcbiAqIGBgYFxuICogXmNvcmUgZ28kIHwgcmIkIHwgcHkkXG4gKiBgYGBcbiAqL1xuY2xhc3MgRXh0ZW5kZWRTZWFyY2gge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwYXR0ZXJuLFxuICAgIHtcbiAgICAgIGlzQ2FzZVNlbnNpdGl2ZSA9IENvbmZpZy5pc0Nhc2VTZW5zaXRpdmUsXG4gICAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICAgIG1pbk1hdGNoQ2hhckxlbmd0aCA9IENvbmZpZy5taW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBpZ25vcmVMb2NhdGlvbiA9IENvbmZpZy5pZ25vcmVMb2NhdGlvbixcbiAgICAgIGZpbmRBbGxNYXRjaGVzID0gQ29uZmlnLmZpbmRBbGxNYXRjaGVzLFxuICAgICAgbG9jYXRpb24gPSBDb25maWcubG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQgPSBDb25maWcudGhyZXNob2xkLFxuICAgICAgZGlzdGFuY2UgPSBDb25maWcuZGlzdGFuY2VcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgdGhpcy5xdWVyeSA9IG51bGw7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgaXNDYXNlU2Vuc2l0aXZlLFxuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBtaW5NYXRjaENoYXJMZW5ndGgsXG4gICAgICBmaW5kQWxsTWF0Y2hlcyxcbiAgICAgIGlnbm9yZUxvY2F0aW9uLFxuICAgICAgbG9jYXRpb24sXG4gICAgICB0aHJlc2hvbGQsXG4gICAgICBkaXN0YW5jZVxuICAgIH07XG5cbiAgICB0aGlzLnBhdHRlcm4gPSBpc0Nhc2VTZW5zaXRpdmUgPyBwYXR0ZXJuIDogcGF0dGVybi50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucXVlcnkgPSBwYXJzZVF1ZXJ5KHRoaXMucGF0dGVybiwgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIHN0YXRpYyBjb25kaXRpb24oXywgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLnVzZUV4dGVuZGVkU2VhcmNoXG4gIH1cblxuICBzZWFyY2hJbih0ZXh0KSB7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuXG4gICAgaWYgKCFxdWVyeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNNYXRjaDogZmFsc2UsXG4gICAgICAgIHNjb3JlOiAxXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgeyBpbmNsdWRlTWF0Y2hlcywgaXNDYXNlU2Vuc2l0aXZlIH0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0ZXh0ID0gaXNDYXNlU2Vuc2l0aXZlID8gdGV4dCA6IHRleHQudG9Mb3dlckNhc2UoKTtcblxuICAgIGxldCBudW1NYXRjaGVzID0gMDtcbiAgICBsZXQgYWxsSW5kaWNlcyA9IFtdO1xuICAgIGxldCB0b3RhbFNjb3JlID0gMDtcblxuICAgIC8vIE9Sc1xuICAgIGZvciAobGV0IGkgPSAwLCBxTGVuID0gcXVlcnkubGVuZ3RoOyBpIDwgcUxlbjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBzZWFyY2hlcnMgPSBxdWVyeVtpXTtcblxuICAgICAgLy8gUmVzZXQgaW5kaWNlc1xuICAgICAgYWxsSW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgbnVtTWF0Y2hlcyA9IDA7XG5cbiAgICAgIC8vIEFORHNcbiAgICAgIGZvciAobGV0IGogPSAwLCBwTGVuID0gc2VhcmNoZXJzLmxlbmd0aDsgaiA8IHBMZW47IGogKz0gMSkge1xuICAgICAgICBjb25zdCBzZWFyY2hlciA9IHNlYXJjaGVyc1tqXTtcbiAgICAgICAgY29uc3QgeyBpc01hdGNoLCBpbmRpY2VzLCBzY29yZSB9ID0gc2VhcmNoZXIuc2VhcmNoKHRleHQpO1xuXG4gICAgICAgIGlmIChpc01hdGNoKSB7XG4gICAgICAgICAgbnVtTWF0Y2hlcyArPSAxO1xuICAgICAgICAgIHRvdGFsU2NvcmUgKz0gc2NvcmU7XG4gICAgICAgICAgaWYgKGluY2x1ZGVNYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gc2VhcmNoZXIuY29uc3RydWN0b3IudHlwZTtcbiAgICAgICAgICAgIGlmIChNdWx0aU1hdGNoU2V0Lmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgICBhbGxJbmRpY2VzID0gWy4uLmFsbEluZGljZXMsIC4uLmluZGljZXNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWxsSW5kaWNlcy5wdXNoKGluZGljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbFNjb3JlID0gMDtcbiAgICAgICAgICBudW1NYXRjaGVzID0gMDtcbiAgICAgICAgICBhbGxJbmRpY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPUiBjb25kaXRpb24sIHNvIGlmIFRSVUUsIHJldHVyblxuICAgICAgaWYgKG51bU1hdGNoZXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICBpc01hdGNoOiB0cnVlLFxuICAgICAgICAgIHNjb3JlOiB0b3RhbFNjb3JlIC8gbnVtTWF0Y2hlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpbmNsdWRlTWF0Y2hlcykge1xuICAgICAgICAgIHJlc3VsdC5pbmRpY2VzID0gYWxsSW5kaWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOb3RoaW5nIHdhcyBtYXRjaGVkXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzTWF0Y2g6IGZhbHNlLFxuICAgICAgc2NvcmU6IDFcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcmVnaXN0ZXJlZFNlYXJjaGVycyA9IFtdO1xuXG5mdW5jdGlvbiByZWdpc3RlciguLi5hcmdzKSB7XG4gIHJlZ2lzdGVyZWRTZWFyY2hlcnMucHVzaCguLi5hcmdzKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoZXIocGF0dGVybiwgb3B0aW9ucykge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmVnaXN0ZXJlZFNlYXJjaGVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIGxldCBzZWFyY2hlckNsYXNzID0gcmVnaXN0ZXJlZFNlYXJjaGVyc1tpXTtcbiAgICBpZiAoc2VhcmNoZXJDbGFzcy5jb25kaXRpb24ocGF0dGVybiwgb3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBuZXcgc2VhcmNoZXJDbGFzcyhwYXR0ZXJuLCBvcHRpb25zKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgQml0YXBTZWFyY2gocGF0dGVybiwgb3B0aW9ucylcbn1cblxuY29uc3QgTG9naWNhbE9wZXJhdG9yID0ge1xuICBBTkQ6ICckYW5kJyxcbiAgT1I6ICckb3InXG59O1xuXG5jb25zdCBLZXlUeXBlID0ge1xuICBQQVRIOiAnJHBhdGgnLFxuICBQQVRURVJOOiAnJHZhbCdcbn07XG5cbmNvbnN0IGlzRXhwcmVzc2lvbiA9IChxdWVyeSkgPT5cbiAgISEocXVlcnlbTG9naWNhbE9wZXJhdG9yLkFORF0gfHwgcXVlcnlbTG9naWNhbE9wZXJhdG9yLk9SXSk7XG5cbmNvbnN0IGlzUGF0aCA9IChxdWVyeSkgPT4gISFxdWVyeVtLZXlUeXBlLlBBVEhdO1xuXG5jb25zdCBpc0xlYWYgPSAocXVlcnkpID0+XG4gICFpc0FycmF5KHF1ZXJ5KSAmJiBpc09iamVjdChxdWVyeSkgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSk7XG5cbmNvbnN0IGNvbnZlcnRUb0V4cGxpY2l0ID0gKHF1ZXJ5KSA9PiAoe1xuICBbTG9naWNhbE9wZXJhdG9yLkFORF06IE9iamVjdC5rZXlzKHF1ZXJ5KS5tYXAoKGtleSkgPT4gKHtcbiAgICBba2V5XTogcXVlcnlba2V5XVxuICB9KSlcbn0pO1xuXG4vLyBXaGVuIGBhdXRvYCBpcyBgdHJ1ZWAsIHRoZSBwYXJzZSBmdW5jdGlvbiB3aWxsIGluZmVyIGFuZCBpbml0aWFsaXplIGFuZCBhZGRcbi8vIHRoZSBhcHByb3ByaWF0ZSBgU2VhcmNoZXJgIGluc3RhbmNlXG5mdW5jdGlvbiBwYXJzZShxdWVyeSwgb3B0aW9ucywgeyBhdXRvID0gdHJ1ZSB9ID0ge30pIHtcbiAgY29uc3QgbmV4dCA9IChxdWVyeSkgPT4ge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMocXVlcnkpO1xuXG4gICAgY29uc3QgaXNRdWVyeVBhdGggPSBpc1BhdGgocXVlcnkpO1xuXG4gICAgaWYgKCFpc1F1ZXJ5UGF0aCAmJiBrZXlzLmxlbmd0aCA+IDEgJiYgIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICAgIHJldHVybiBuZXh0KGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KSlcbiAgICB9XG5cbiAgICBpZiAoaXNMZWFmKHF1ZXJ5KSkge1xuICAgICAgY29uc3Qga2V5ID0gaXNRdWVyeVBhdGggPyBxdWVyeVtLZXlUeXBlLlBBVEhdIDoga2V5c1swXTtcblxuICAgICAgY29uc3QgcGF0dGVybiA9IGlzUXVlcnlQYXRoID8gcXVlcnlbS2V5VHlwZS5QQVRURVJOXSA6IHF1ZXJ5W2tleV07XG5cbiAgICAgIGlmICghaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKExPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWShrZXkpKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIGtleUlkOiBjcmVhdGVLZXlJZChrZXkpLFxuICAgICAgICBwYXR0ZXJuXG4gICAgICB9O1xuXG4gICAgICBpZiAoYXV0bykge1xuICAgICAgICBvYmouc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihwYXR0ZXJuLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cblxuICAgIGxldCBub2RlID0ge1xuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgb3BlcmF0b3I6IGtleXNbMF1cbiAgICB9O1xuXG4gICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcXVlcnlba2V5XTtcblxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV4dChpdGVtKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBpZiAoIWlzRXhwcmVzc2lvbihxdWVyeSkpIHtcbiAgICBxdWVyeSA9IGNvbnZlcnRUb0V4cGxpY2l0KHF1ZXJ5KTtcbiAgfVxuXG4gIHJldHVybiBuZXh0KHF1ZXJ5KVxufVxuXG4vLyBQcmFjdGljYWwgc2NvcmluZyBmdW5jdGlvblxuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKFxuICByZXN1bHRzLFxuICB7IGlnbm9yZUZpZWxkTm9ybSA9IENvbmZpZy5pZ25vcmVGaWVsZE5vcm0gfVxuKSB7XG4gIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0KSA9PiB7XG4gICAgbGV0IHRvdGFsU2NvcmUgPSAxO1xuXG4gICAgcmVzdWx0Lm1hdGNoZXMuZm9yRWFjaCgoeyBrZXksIG5vcm0sIHNjb3JlIH0pID0+IHtcbiAgICAgIGNvbnN0IHdlaWdodCA9IGtleSA/IGtleS53ZWlnaHQgOiBudWxsO1xuXG4gICAgICB0b3RhbFNjb3JlICo9IE1hdGgucG93KFxuICAgICAgICBzY29yZSA9PT0gMCAmJiB3ZWlnaHQgPyBOdW1iZXIuRVBTSUxPTiA6IHNjb3JlLFxuICAgICAgICAod2VpZ2h0IHx8IDEpICogKGlnbm9yZUZpZWxkTm9ybSA/IDEgOiBub3JtKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJlc3VsdC5zY29yZSA9IHRvdGFsU2NvcmU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXRjaGVzKHJlc3VsdCwgZGF0YSkge1xuICBjb25zdCBtYXRjaGVzID0gcmVzdWx0Lm1hdGNoZXM7XG4gIGRhdGEubWF0Y2hlcyA9IFtdO1xuXG4gIGlmICghaXNEZWZpbmVkKG1hdGNoZXMpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoKSA9PiB7XG4gICAgaWYgKCFpc0RlZmluZWQobWF0Y2guaW5kaWNlcykgfHwgIW1hdGNoLmluZGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IGluZGljZXMsIHZhbHVlIH0gPSBtYXRjaDtcblxuICAgIGxldCBvYmogPSB7XG4gICAgICBpbmRpY2VzLFxuICAgICAgdmFsdWVcbiAgICB9O1xuXG4gICAgaWYgKG1hdGNoLmtleSkge1xuICAgICAgb2JqLmtleSA9IG1hdGNoLmtleS5zcmM7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLmlkeCA+IC0xKSB7XG4gICAgICBvYmoucmVmSW5kZXggPSBtYXRjaC5pZHg7XG4gICAgfVxuXG4gICAgZGF0YS5tYXRjaGVzLnB1c2gob2JqKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNjb3JlKHJlc3VsdCwgZGF0YSkge1xuICBkYXRhLnNjb3JlID0gcmVzdWx0LnNjb3JlO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQoXG4gIHJlc3VsdHMsXG4gIGRvY3MsXG4gIHtcbiAgICBpbmNsdWRlTWF0Y2hlcyA9IENvbmZpZy5pbmNsdWRlTWF0Y2hlcyxcbiAgICBpbmNsdWRlU2NvcmUgPSBDb25maWcuaW5jbHVkZVNjb3JlXG4gIH0gPSB7fVxuKSB7XG4gIGNvbnN0IHRyYW5zZm9ybWVycyA9IFtdO1xuXG4gIGlmIChpbmNsdWRlTWF0Y2hlcykgdHJhbnNmb3JtZXJzLnB1c2godHJhbnNmb3JtTWF0Y2hlcyk7XG4gIGlmIChpbmNsdWRlU2NvcmUpIHRyYW5zZm9ybWVycy5wdXNoKHRyYW5zZm9ybVNjb3JlKTtcblxuICByZXR1cm4gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4ge1xuICAgIGNvbnN0IHsgaWR4IH0gPSByZXN1bHQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgaXRlbTogZG9jc1tpZHhdLFxuICAgICAgcmVmSW5kZXg6IGlkeFxuICAgIH07XG5cbiAgICBpZiAodHJhbnNmb3JtZXJzLmxlbmd0aCkge1xuICAgICAgdHJhbnNmb3JtZXJzLmZvckVhY2goKHRyYW5zZm9ybWVyKSA9PiB7XG4gICAgICAgIHRyYW5zZm9ybWVyKHJlc3VsdCwgZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YVxuICB9KVxufVxuXG5jbGFzcyBGdXNlIHtcbiAgY29uc3RydWN0b3IoZG9jcywgb3B0aW9ucyA9IHt9LCBpbmRleCkge1xuICAgIHRoaXMub3B0aW9ucyA9IHsgLi4uQ29uZmlnLCAuLi5vcHRpb25zIH07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMudXNlRXh0ZW5kZWRTZWFyY2ggJiZcbiAgICAgICF0cnVlXG4gICAgKSB7fVxuXG4gICAgdGhpcy5fa2V5U3RvcmUgPSBuZXcgS2V5U3RvcmUodGhpcy5vcHRpb25zLmtleXMpO1xuXG4gICAgdGhpcy5zZXRDb2xsZWN0aW9uKGRvY3MsIGluZGV4KTtcbiAgfVxuXG4gIHNldENvbGxlY3Rpb24oZG9jcywgaW5kZXgpIHtcbiAgICB0aGlzLl9kb2NzID0gZG9jcztcblxuICAgIGlmIChpbmRleCAmJiAhKGluZGV4IGluc3RhbmNlb2YgRnVzZUluZGV4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKElOQ09SUkVDVF9JTkRFWF9UWVBFKVxuICAgIH1cblxuICAgIHRoaXMuX215SW5kZXggPVxuICAgICAgaW5kZXggfHxcbiAgICAgIGNyZWF0ZUluZGV4KHRoaXMub3B0aW9ucy5rZXlzLCB0aGlzLl9kb2NzLCB7XG4gICAgICAgIGdldEZuOiB0aGlzLm9wdGlvbnMuZ2V0Rm4sXG4gICAgICAgIGZpZWxkTm9ybVdlaWdodDogdGhpcy5vcHRpb25zLmZpZWxkTm9ybVdlaWdodFxuICAgICAgfSk7XG4gIH1cblxuICBhZGQoZG9jKSB7XG4gICAgaWYgKCFpc0RlZmluZWQoZG9jKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fZG9jcy5wdXNoKGRvYyk7XG4gICAgdGhpcy5fbXlJbmRleC5hZGQoZG9jKTtcbiAgfVxuXG4gIHJlbW92ZShwcmVkaWNhdGUgPSAoLyogZG9jLCBpZHggKi8pID0+IGZhbHNlKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX2RvY3MubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGRvYyA9IHRoaXMuX2RvY3NbaV07XG4gICAgICBpZiAocHJlZGljYXRlKGRvYywgaSkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBdChpKTtcbiAgICAgICAgaSAtPSAxO1xuICAgICAgICBsZW4gLT0gMTtcblxuICAgICAgICByZXN1bHRzLnB1c2goZG9jKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgcmVtb3ZlQXQoaWR4KSB7XG4gICAgdGhpcy5fZG9jcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB0aGlzLl9teUluZGV4LnJlbW92ZUF0KGlkeCk7XG4gIH1cblxuICBnZXRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbXlJbmRleFxuICB9XG5cbiAgc2VhcmNoKHF1ZXJ5LCB7IGxpbWl0ID0gLTEgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5jbHVkZU1hdGNoZXMsXG4gICAgICBpbmNsdWRlU2NvcmUsXG4gICAgICBzaG91bGRTb3J0LFxuICAgICAgc29ydEZuLFxuICAgICAgaWdub3JlRmllbGROb3JtXG4gICAgfSA9IHRoaXMub3B0aW9ucztcblxuICAgIGxldCByZXN1bHRzID0gaXNTdHJpbmcocXVlcnkpXG4gICAgICA/IGlzU3RyaW5nKHRoaXMuX2RvY3NbMF0pXG4gICAgICAgID8gdGhpcy5fc2VhcmNoU3RyaW5nTGlzdChxdWVyeSlcbiAgICAgICAgOiB0aGlzLl9zZWFyY2hPYmplY3RMaXN0KHF1ZXJ5KVxuICAgICAgOiB0aGlzLl9zZWFyY2hMb2dpY2FsKHF1ZXJ5KTtcblxuICAgIGNvbXB1dGVTY29yZShyZXN1bHRzLCB7IGlnbm9yZUZpZWxkTm9ybSB9KTtcblxuICAgIGlmIChzaG91bGRTb3J0KSB7XG4gICAgICByZXN1bHRzLnNvcnQoc29ydEZuKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOdW1iZXIobGltaXQpICYmIGxpbWl0ID4gLTEpIHtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNsaWNlKDAsIGxpbWl0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0KHJlc3VsdHMsIHRoaXMuX2RvY3MsIHtcbiAgICAgIGluY2x1ZGVNYXRjaGVzLFxuICAgICAgaW5jbHVkZVNjb3JlXG4gICAgfSlcbiAgfVxuXG4gIF9zZWFyY2hTdHJpbmdMaXN0KHF1ZXJ5KSB7XG4gICAgY29uc3Qgc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihxdWVyeSwgdGhpcy5vcHRpb25zKTtcbiAgICBjb25zdCB7IHJlY29yZHMgfSA9IHRoaXMuX215SW5kZXg7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IHN0cmluZyBpbiB0aGUgaW5kZXhcbiAgICByZWNvcmRzLmZvckVhY2goKHsgdjogdGV4dCwgaTogaWR4LCBuOiBub3JtIH0pID0+IHtcbiAgICAgIGlmICghaXNEZWZpbmVkKHRleHQpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2hlci5zZWFyY2hJbih0ZXh0KTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICBpdGVtOiB0ZXh0LFxuICAgICAgICAgIGlkeCxcbiAgICAgICAgICBtYXRjaGVzOiBbeyBzY29yZSwgdmFsdWU6IHRleHQsIG5vcm0sIGluZGljZXMgfV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9XG5cbiAgX3NlYXJjaExvZ2ljYWwocXVlcnkpIHtcblxuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwYXJzZShxdWVyeSwgdGhpcy5vcHRpb25zKTtcblxuICAgIGNvbnN0IGV2YWx1YXRlID0gKG5vZGUsIGl0ZW0sIGlkeCkgPT4ge1xuICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGNvbnN0IHsga2V5SWQsIHNlYXJjaGVyIH0gPSBub2RlO1xuXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLl9maW5kTWF0Y2hlcyh7XG4gICAgICAgICAga2V5OiB0aGlzLl9rZXlTdG9yZS5nZXQoa2V5SWQpLFxuICAgICAgICAgIHZhbHVlOiB0aGlzLl9teUluZGV4LmdldFZhbHVlRm9ySXRlbUF0S2V5SWQoaXRlbSwga2V5SWQpLFxuICAgICAgICAgIHNlYXJjaGVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgICBtYXRjaGVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBldmFsdWF0ZShjaGlsZCwgaXRlbSwgaWR4KTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgICByZXMucHVzaCguLi5yZXN1bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUub3BlcmF0b3IgPT09IExvZ2ljYWxPcGVyYXRvci5BTkQpIHtcbiAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH07XG5cbiAgICBjb25zdCByZWNvcmRzID0gdGhpcy5fbXlJbmRleC5yZWNvcmRzO1xuICAgIGNvbnN0IHJlc3VsdE1hcCA9IHt9O1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgIHJlY29yZHMuZm9yRWFjaCgoeyAkOiBpdGVtLCBpOiBpZHggfSkgPT4ge1xuICAgICAgaWYgKGlzRGVmaW5lZChpdGVtKSkge1xuICAgICAgICBsZXQgZXhwUmVzdWx0cyA9IGV2YWx1YXRlKGV4cHJlc3Npb24sIGl0ZW0sIGlkeCk7XG5cbiAgICAgICAgaWYgKGV4cFJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gRGVkdXBlIHdoZW4gYWRkaW5nXG4gICAgICAgICAgaWYgKCFyZXN1bHRNYXBbaWR4XSkge1xuICAgICAgICAgICAgcmVzdWx0TWFwW2lkeF0gPSB7IGlkeCwgaXRlbSwgbWF0Y2hlczogW10gfTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHRNYXBbaWR4XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cFJlc3VsdHMuZm9yRWFjaCgoeyBtYXRjaGVzIH0pID0+IHtcbiAgICAgICAgICAgIHJlc3VsdE1hcFtpZHhdLm1hdGNoZXMucHVzaCguLi5tYXRjaGVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG4gIF9zZWFyY2hPYmplY3RMaXN0KHF1ZXJ5KSB7XG4gICAgY29uc3Qgc2VhcmNoZXIgPSBjcmVhdGVTZWFyY2hlcihxdWVyeSwgdGhpcy5vcHRpb25zKTtcbiAgICBjb25zdCB7IGtleXMsIHJlY29yZHMgfSA9IHRoaXMuX215SW5kZXg7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgLy8gTGlzdCBpcyBBcnJheTxPYmplY3Q+XG4gICAgcmVjb3Jkcy5mb3JFYWNoKCh7ICQ6IGl0ZW0sIGk6IGlkeCB9KSA9PiB7XG4gICAgICBpZiAoIWlzRGVmaW5lZChpdGVtKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgbGV0IG1hdGNoZXMgPSBbXTtcblxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGV2ZXJ5IGtleSAoaS5lLCBwYXRoKSwgYW5kIGZldGNoIHRoZSB2YWx1ZSBhdCB0aGF0IGtleVxuICAgICAga2V5cy5mb3JFYWNoKChrZXksIGtleUluZGV4KSA9PiB7XG4gICAgICAgIG1hdGNoZXMucHVzaChcbiAgICAgICAgICAuLi50aGlzLl9maW5kTWF0Y2hlcyh7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogaXRlbVtrZXlJbmRleF0sXG4gICAgICAgICAgICBzZWFyY2hlclxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgaWR4LFxuICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgbWF0Y2hlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHRzXG4gIH1cbiAgX2ZpbmRNYXRjaGVzKHsga2V5LCB2YWx1ZSwgc2VhcmNoZXIgfSkge1xuICAgIGlmICghaXNEZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuXG4gICAgbGV0IG1hdGNoZXMgPSBbXTtcblxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoeyB2OiB0ZXh0LCBpOiBpZHgsIG46IG5vcm0gfSkgPT4ge1xuICAgICAgICBpZiAoIWlzRGVmaW5lZCh0ZXh0KSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyBpc01hdGNoLCBzY29yZSwgaW5kaWNlcyB9ID0gc2VhcmNoZXIuc2VhcmNoSW4odGV4dCk7XG5cbiAgICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgc2NvcmUsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdGV4dCxcbiAgICAgICAgICAgIGlkeCxcbiAgICAgICAgICAgIG5vcm0sXG4gICAgICAgICAgICBpbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IHY6IHRleHQsIG46IG5vcm0gfSA9IHZhbHVlO1xuXG4gICAgICBjb25zdCB7IGlzTWF0Y2gsIHNjb3JlLCBpbmRpY2VzIH0gPSBzZWFyY2hlci5zZWFyY2hJbih0ZXh0KTtcblxuICAgICAgaWYgKGlzTWF0Y2gpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHsgc2NvcmUsIGtleSwgdmFsdWU6IHRleHQsIG5vcm0sIGluZGljZXMgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXNcbiAgfVxufVxuXG5GdXNlLnZlcnNpb24gPSAnNi42LjInO1xuRnVzZS5jcmVhdGVJbmRleCA9IGNyZWF0ZUluZGV4O1xuRnVzZS5wYXJzZUluZGV4ID0gcGFyc2VJbmRleDtcbkZ1c2UuY29uZmlnID0gQ29uZmlnO1xuXG57XG4gIEZ1c2UucGFyc2VRdWVyeSA9IHBhcnNlO1xufVxuXG57XG4gIHJlZ2lzdGVyKEV4dGVuZGVkU2VhcmNoKTtcbn1cblxuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc5MTpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgXCJfX0RPX05PVF9VU0VfX0FjdGlvblR5cGVzXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBBY3Rpb25UeXBlczsgfSxcbiAgXCJhcHBseU1pZGRsZXdhcmVcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGFwcGx5TWlkZGxld2FyZTsgfSxcbiAgXCJiaW5kQWN0aW9uQ3JlYXRvcnNcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGJpbmRBY3Rpb25DcmVhdG9yczsgfSxcbiAgXCJjb21iaW5lUmVkdWNlcnNcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNvbWJpbmVSZWR1Y2VyczsgfSxcbiAgXCJjb21wb3NlXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBjb21wb3NlOyB9LFxuICBcImNyZWF0ZVN0b3JlXCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBjcmVhdGVTdG9yZTsgfSxcbiAgXCJsZWdhY3lfY3JlYXRlU3RvcmVcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGxlZ2FjeV9jcmVhdGVTdG9yZTsgfVxufSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90eXBlb2YuanNcbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBfdHlwZW9mKG9iaik7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9QcmltaXRpdmUuanNcblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1Byb3BlcnR5S2V5LmpzXG5cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzXG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyLmpzXG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvcmVkdXgvZXMvcmVkdXguanNcblxuXG4vKipcbiAqIEFkYXB0ZWQgZnJvbSBSZWFjdDogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLmpzXG4gKlxuICogRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgdGhyb3cgZXJyb3IgY2FsbHMuIFRoZXNlIG1lc3NhZ2VzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBlcnJvciBjb2Rlc1xuICogZHVyaW5nIGJ1aWxkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHJldHVybiBcIk1pbmlmaWVkIFJlZHV4IGVycm9yICNcIiArIGNvZGUgKyBcIjsgdmlzaXQgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvRXJyb3JzP2NvZGU9XCIgKyBjb2RlICsgXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgXCIgKyAndXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycy4gJztcbn1cblxuLy8gSW5saW5lZCB2ZXJzaW9uIG9mIHRoZSBgc3ltYm9sLW9ic2VydmFibGVgIHBvbHlmaWxsXG52YXIgJCRvYnNlcnZhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLm9ic2VydmFibGUgfHwgJ0BAb2JzZXJ2YWJsZSc7XG59KSgpO1xuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIHJhbmRvbVN0cmluZyA9IGZ1bmN0aW9uIHJhbmRvbVN0cmluZygpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xufTtcblxudmFyIEFjdGlvblR5cGVzID0ge1xuICBJTklUOiBcIkBAcmVkdXgvSU5JVFwiICsgcmFuZG9tU3RyaW5nKCksXG4gIFJFUExBQ0U6IFwiQEByZWR1eC9SRVBMQUNFXCIgKyByYW5kb21TdHJpbmcoKSxcbiAgUFJPQkVfVU5LTk9XTl9BQ1RJT046IGZ1bmN0aW9uIFBST0JFX1VOS05PV05fQUNUSU9OKCkge1xuICAgIHJldHVybiBcIkBAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05cIiArIHJhbmRvbVN0cmluZygpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gb2JqO1xuXG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBwcm90bztcbn1cblxuLy8gSW5saW5lZCAvIHNob3J0ZW5lZCB2ZXJzaW9uIG9mIGBraW5kT2ZgIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQva2luZC1vZlxuZnVuY3Rpb24gbWluaUtpbmRPZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gdm9pZCAwKSByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIGlmICh2YWwgPT09IG51bGwpIHJldHVybiAnbnVsbCc7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgcmV0dXJuICdhcnJheSc7XG4gIGlmIChpc0RhdGUodmFsKSkgcmV0dXJuICdkYXRlJztcbiAgaWYgKGlzRXJyb3IodmFsKSkgcmV0dXJuICdlcnJvcic7XG4gIHZhciBjb25zdHJ1Y3Rvck5hbWUgPSBjdG9yTmFtZSh2YWwpO1xuXG4gIHN3aXRjaCAoY29uc3RydWN0b3JOYW1lKSB7XG4gICAgY2FzZSAnU3ltYm9sJzpcbiAgICBjYXNlICdQcm9taXNlJzpcbiAgICBjYXNlICdXZWFrTWFwJzpcbiAgICBjYXNlICdXZWFrU2V0JzpcbiAgICBjYXNlICdNYXAnOlxuICAgIGNhc2UgJ1NldCc6XG4gICAgICByZXR1cm4gY29uc3RydWN0b3JOYW1lO1xuICB9IC8vIG90aGVyXG5cblxuICByZXR1cm4gdHlwZS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMvZywgJycpO1xufVxuXG5mdW5jdGlvbiBjdG9yTmFtZSh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwuY29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicgPyB2YWwuY29uc3RydWN0b3IubmFtZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgdmFsLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIHZhbC5jb25zdHJ1Y3RvciAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLnN0YWNrVHJhY2VMaW1pdCA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gdHlwZW9mIHZhbC50b0RhdGVTdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbC5nZXREYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWwuc2V0RGF0ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICB2YXIgdHlwZU9mVmFsID0gdHlwZW9mIHZhbDtcblxuICBpZiAoZmFsc2UpIHt9XG5cbiAgcmV0dXJuIHR5cGVPZlZhbDtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqICoqV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBgY29uZmlndXJlU3RvcmVgIG1ldGhvZFxuICogb2YgdGhlIGBAcmVkdXhqcy90b29sa2l0YCBwYWNrYWdlKiosIHdoaWNoIHJlcGxhY2VzIGBjcmVhdGVTdG9yZWAuXG4gKlxuICogUmVkdXggVG9vbGtpdCBpcyBvdXIgcmVjb21tZW5kZWQgYXBwcm9hY2ggZm9yIHdyaXRpbmcgUmVkdXggbG9naWMgdG9kYXksXG4gKiBpbmNsdWRpbmcgc3RvcmUgc2V0dXAsIHJlZHVjZXJzLCBkYXRhIGZldGNoaW5nLCBhbmQgbW9yZS5cbiAqXG4gKiAqKkZvciBtb3JlIGRldGFpbHMsIHBsZWFzZSByZWFkIHRoaXMgUmVkdXggZG9jcyBwYWdlOioqXG4gKiAqKmh0dHBzOi8vcmVkdXguanMub3JnL2ludHJvZHVjdGlvbi93aHktcnRrLWlzLXJlZHV4LXRvZGF5KipcbiAqXG4gKiBgY29uZmlndXJlU3RvcmVgIGZyb20gUmVkdXggVG9vbGtpdCBpcyBhbiBpbXByb3ZlZCB2ZXJzaW9uIG9mIGBjcmVhdGVTdG9yZWAgdGhhdFxuICogc2ltcGxpZmllcyBzZXR1cCBhbmQgaGVscHMgYXZvaWQgY29tbW9uIGJ1Z3MuXG4gKlxuICogWW91IHNob3VsZCBub3QgYmUgdXNpbmcgdGhlIGByZWR1eGAgY29yZSBwYWNrYWdlIGJ5IGl0c2VsZiB0b2RheSwgZXhjZXB0IGZvciBsZWFybmluZyBwdXJwb3Nlcy5cbiAqIFRoZSBgY3JlYXRlU3RvcmVgIG1ldGhvZCBmcm9tIHRoZSBjb3JlIGByZWR1eGAgcGFja2FnZSB3aWxsIG5vdCBiZSByZW1vdmVkLCBidXQgd2UgZW5jb3VyYWdlXG4gKiBhbGwgdXNlcnMgdG8gbWlncmF0ZSB0byB1c2luZyBSZWR1eCBUb29sa2l0IGZvciBhbGwgUmVkdXggY29kZS5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byB1c2UgYGNyZWF0ZVN0b3JlYCB3aXRob3V0IHRoaXMgdmlzdWFsIGRlcHJlY2F0aW9uIHdhcm5pbmcsIHVzZVxuICogdGhlIGBsZWdhY3lfY3JlYXRlU3RvcmVgIGltcG9ydCBpbnN0ZWFkOlxuICpcbiAqIGBpbXBvcnQgeyBsZWdhY3lfY3JlYXRlU3RvcmUgYXMgY3JlYXRlU3RvcmV9IGZyb20gJ3JlZHV4J2BcbiAqXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gIHZhciBfcmVmMjtcblxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZW5oYW5jZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvciggdHJ1ZSA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMCkgOiAwKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAndW5kZWZpbmVkJykge1xuICAgIGVuaGFuY2VyID0gcHJlbG9hZGVkU3RhdGU7XG4gICAgcHJlbG9hZGVkU3RhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvciggdHJ1ZSA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvciggdHJ1ZSA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMikgOiAwKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAvKipcbiAgICogVGhpcyBtYWtlcyBhIHNoYWxsb3cgY29weSBvZiBjdXJyZW50TGlzdGVuZXJzIHNvIHdlIGNhbiB1c2VcbiAgICogbmV4dExpc3RlbmVycyBhcyBhIHRlbXBvcmFyeSBsaXN0IHdoaWxlIGRpc3BhdGNoaW5nLlxuICAgKlxuICAgKiBUaGlzIHByZXZlbnRzIGFueSBidWdzIGFyb3VuZCBjb25zdW1lcnMgY2FsbGluZ1xuICAgKiBzdWJzY3JpYmUvdW5zdWJzY3JpYmUgaW4gdGhlIG1pZGRsZSBvZiBhIGRpc3BhdGNoLlxuICAgKi9cblxuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycy5zbGljZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCB0cnVlID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzKSA6IDApO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvciggdHJ1ZSA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNCkgOiAwKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCB0cnVlID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1KSA6IDApO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCB0cnVlID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2KSA6IDApO1xuICAgICAgfVxuXG4gICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICAgIHZhciBpbmRleCA9IG5leHRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBuZXh0TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICBjdXJyZW50TGlzdGVuZXJzID0gbnVsbDtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFuIGFjdGlvbi4gSXQgaXMgdGhlIG9ubHkgd2F5IHRvIHRyaWdnZXIgYSBzdGF0ZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoZSBgcmVkdWNlcmAgZnVuY3Rpb24sIHVzZWQgdG8gY3JlYXRlIHRoZSBzdG9yZSwgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGVcbiAgICogY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgZ2l2ZW4gYGFjdGlvbmAuIEl0cyByZXR1cm4gdmFsdWUgd2lsbFxuICAgKiBiZSBjb25zaWRlcmVkIHRoZSAqKm5leHQqKiBzdGF0ZSBvZiB0aGUgdHJlZSwgYW5kIHRoZSBjaGFuZ2UgbGlzdGVuZXJzXG4gICAqIHdpbGwgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgcGxhaW4gb2JqZWN0IGFjdGlvbnMuIElmIHlvdSB3YW50IHRvXG4gICAqIGRpc3BhdGNoIGEgUHJvbWlzZSwgYW4gT2JzZXJ2YWJsZSwgYSB0aHVuaywgb3Igc29tZXRoaW5nIGVsc2UsIHlvdSBuZWVkIHRvXG4gICAqIHdyYXAgeW91ciBzdG9yZSBjcmVhdGluZyBmdW5jdGlvbiBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIG1pZGRsZXdhcmUuIEZvclxuICAgKiBleGFtcGxlLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIHRoZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UuIEV2ZW4gdGhlXG4gICAqIG1pZGRsZXdhcmUgd2lsbCBldmVudHVhbGx5IGRpc3BhdGNoIHBsYWluIG9iamVjdCBhY3Rpb25zIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWN0aW9uIEEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyDigJx3aGF0IGNoYW5nZWTigJ0uIEl0IGlzXG4gICAqIGEgZ29vZCBpZGVhIHRvIGtlZXAgYWN0aW9ucyBzZXJpYWxpemFibGUgc28geW91IGNhbiByZWNvcmQgYW5kIHJlcGxheSB1c2VyXG4gICAqIHNlc3Npb25zLCBvciB1c2UgdGhlIHRpbWUgdHJhdmVsbGluZyBgcmVkdXgtZGV2dG9vbHNgLiBBbiBhY3Rpb24gbXVzdCBoYXZlXG4gICAqIGEgYHR5cGVgIHByb3BlcnR5IHdoaWNoIG1heSBub3QgYmUgYHVuZGVmaW5lZGAuIEl0IGlzIGEgZ29vZCBpZGVhIHRvIHVzZVxuICAgKiBzdHJpbmcgY29uc3RhbnRzIGZvciBhY3Rpb24gdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEZvciBjb252ZW5pZW5jZSwgdGhlIHNhbWUgYWN0aW9uIG9iamVjdCB5b3UgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0LCBpZiB5b3UgdXNlIGEgY3VzdG9tIG1pZGRsZXdhcmUsIGl0IG1heSB3cmFwIGBkaXNwYXRjaCgpYCB0b1xuICAgKiByZXR1cm4gc29tZXRoaW5nIGVsc2UgKGZvciBleGFtcGxlLCBhIFByb21pc2UgeW91IGNhbiBhd2FpdCkuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvciggdHJ1ZSA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNykgOiAwKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCB0cnVlID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6IDApO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoIHRydWUgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkpIDogMCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCB0cnVlID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMCkgOiAwKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyOyAvLyBUaGlzIGFjdGlvbiBoYXMgYSBzaW1pbGlhciBlZmZlY3QgdG8gQWN0aW9uVHlwZXMuSU5JVC5cbiAgICAvLyBBbnkgcmVkdWNlcnMgdGhhdCBleGlzdGVkIGluIGJvdGggdGhlIG5ldyBhbmQgb2xkIHJvb3RSZWR1Y2VyXG4gICAgLy8gd2lsbCByZWNlaXZlIHRoZSBwcmV2aW91cyBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgICAvLyB0aGUgbmV3IHN0YXRlIHRyZWUgd2l0aCBhbnkgcmVsZXZhbnQgZGF0YSBmcm9tIHRoZSBvbGQgb25lLlxuXG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuUkVQTEFDRVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCB0cnVlID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmWyQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9IC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuXG5cbiAgZGlzcGF0Y2goe1xuICAgIHR5cGU6IEFjdGlvblR5cGVzLklOSVRcbiAgfSk7XG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMlskJG9ic2VydmFibGVdID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBSZWR1eCBzdG9yZSB0aGF0IGhvbGRzIHRoZSBzdGF0ZSB0cmVlLlxuICpcbiAqICoqV2UgcmVjb21tZW5kIHVzaW5nIGBjb25maWd1cmVTdG9yZWAgZnJvbSB0aGVcbiAqIGBAcmVkdXhqcy90b29sa2l0YCBwYWNrYWdlKiosIHdoaWNoIHJlcGxhY2VzIGBjcmVhdGVTdG9yZWA6XG4gKiAqKmh0dHBzOi8vcmVkdXguanMub3JnL2ludHJvZHVjdGlvbi93aHktcnRrLWlzLXJlZHV4LXRvZGF5KipcbiAqXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAqXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gKlxuICogQHBhcmFtIHthbnl9IFtwcmVsb2FkZWRTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2VuaGFuY2VyXSBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cblxudmFyIGxlZ2FjeV9jcmVhdGVTdG9yZSA9IGNyZWF0ZVN0b3JlO1xuXG4vKipcbiAqIFByaW50cyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGUgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cblxuICB0cnkge1xuICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgaWYgeW91IGVuYWJsZVxuICAgIC8vIFwiYnJlYWsgb24gYWxsIGV4Y2VwdGlvbnNcIiBpbiB5b3VyIGNvbnNvbGUsXG4gICAgLy8gaXQgd291bGQgcGF1c2UgdGhlIGV4ZWN1dGlvbiBhdCB0aGlzIGxpbmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG5cbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5JTklUID8gJ3ByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuIFwiVGhlIFwiICsgYXJndW1lbnROYW1lICsgXCIgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcXFwiXCIgKyBraW5kT2YoaW5wdXRTdGF0ZSkgKyBcIlxcXCIuIEV4cGVjdGVkIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgXCIgKyAoXCJrZXlzOiBcXFwiXCIgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArIFwiXFxcIlwiKTtcbiAgfVxuXG4gIHZhciB1bmV4cGVjdGVkS2V5cyA9IE9iamVjdC5rZXlzKGlucHV0U3RhdGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFyZWR1Y2Vycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XTtcbiAgfSk7XG4gIHVuZXhwZWN0ZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IEFjdGlvblR5cGVzLlJFUExBQ0UpIHJldHVybjtcblxuICBpZiAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBcIlVuZXhwZWN0ZWQgXCIgKyAodW5leHBlY3RlZEtleXMubGVuZ3RoID4gMSA/ICdrZXlzJyA6ICdrZXknKSArIFwiIFwiICsgKFwiXFxcIlwiICsgdW5leHBlY3RlZEtleXMuam9pbignXCIsIFwiJykgKyBcIlxcXCIgZm91bmQgaW4gXCIgKyBhcmd1bWVudE5hbWUgKyBcIi4gXCIpICsgXCJFeHBlY3RlZCB0byBmaW5kIG9uZSBvZiB0aGUga25vd24gcmVkdWNlciBrZXlzIGluc3RlYWQ6IFwiICsgKFwiXFxcIlwiICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyBcIlxcXCIuIFVuZXhwZWN0ZWQga2V5cyB3aWxsIGJlIGlnbm9yZWQuXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlZHVjZXJTaGFwZShyZWR1Y2Vycykge1xuICBPYmplY3Qua2V5cyhyZWR1Y2VycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHJlZHVjZXIgPSByZWR1Y2Vyc1trZXldO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSByZWR1Y2VyKHVuZGVmaW5lZCwge1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuSU5JVFxuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoIHRydWUgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IDApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHtcbiAgICAgIHR5cGU6IEFjdGlvblR5cGVzLlBST0JFX1VOS05PV05fQUNUSU9OKClcbiAgICB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvciggdHJ1ZSA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTMpIDogMCk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZGlmZmVyZW50IHJlZHVjZXIgZnVuY3Rpb25zLCBpbnRvIGEgc2luZ2xlXG4gKiByZWR1Y2VyIGZ1bmN0aW9uLiBJdCB3aWxsIGNhbGwgZXZlcnkgY2hpbGQgcmVkdWNlciwgYW5kIGdhdGhlciB0aGVpciByZXN1bHRzXG4gKiBpbnRvIGEgc2luZ2xlIHN0YXRlIG9iamVjdCwgd2hvc2Uga2V5cyBjb3JyZXNwb25kIHRvIHRoZSBrZXlzIG9mIHRoZSBwYXNzZWRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWR1Y2VycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGNvcnJlc3BvbmQgdG8gZGlmZmVyZW50XG4gKiByZWR1Y2VyIGZ1bmN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgY29tYmluZWQgaW50byBvbmUuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluXG4gKiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhcyByZWR1Y2Vyc2Agc3ludGF4LiBUaGUgcmVkdWNlcnMgbWF5IG5ldmVyIHJldHVyblxuICogdW5kZWZpbmVkIGZvciBhbnkgYWN0aW9uLiBJbnN0ZWFkLCB0aGV5IHNob3VsZCByZXR1cm4gdGhlaXIgaW5pdGlhbCBzdGF0ZVxuICogaWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGVtIHdhcyB1bmRlZmluZWQsIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBmb3IgYW55XG4gKiB1bnJlY29nbml6ZWQgYWN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBldmVyeSByZWR1Y2VyIGluc2lkZSB0aGVcbiAqIHBhc3NlZCBvYmplY3QsIGFuZCBidWlsZHMgYSBzdGF0ZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBmaW5hbFJlZHVjZXJzID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcblxuICAgIGlmIChmYWxzZSkge31cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpOyAvLyBUaGlzIGlzIHVzZWQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHdhcm4gYWJvdXQgdGhlIHNhbWVcbiAgLy8ga2V5cyBtdWx0aXBsZSB0aW1lcy5cblxuICB2YXIgdW5leHBlY3RlZEtleUNhY2hlO1xuXG4gIGlmIChmYWxzZSkge31cblxuICB2YXIgc2hhcGVBc3NlcnRpb25FcnJvcjtcblxuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTaGFwZShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSBlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoc2hhcGVBc3NlcnRpb25FcnJvcikge1xuICAgICAgdGhyb3cgc2hhcGVBc3NlcnRpb25FcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoZmFsc2UpIHsgdmFyIHdhcm5pbmdNZXNzYWdlOyB9XG5cbiAgICB2YXIgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0U3RhdGUgPSB7fTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9rZXkgPSBmaW5hbFJlZHVjZXJLZXlzW19pXTtcbiAgICAgIHZhciByZWR1Y2VyID0gZmluYWxSZWR1Y2Vyc1tfa2V5XTtcbiAgICAgIHZhciBwcmV2aW91c1N0YXRlRm9yS2V5ID0gc3RhdGVbX2tleV07XG4gICAgICB2YXIgbmV4dFN0YXRlRm9yS2V5ID0gcmVkdWNlcihwcmV2aW91c1N0YXRlRm9yS2V5LCBhY3Rpb24pO1xuXG4gICAgICBpZiAodHlwZW9mIG5leHRTdGF0ZUZvcktleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIGFjdGlvblR5cGUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvciggdHJ1ZSA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTQpIDogMCk7XG4gICAgICB9XG5cbiAgICAgIG5leHRTdGF0ZVtfa2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG5cbiAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoc3RhdGUpLmxlbmd0aDtcbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhbiBhY3Rpb24gY3JlYXRvciBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZGlzcGF0Y2ggd3JhcHBlZCBmdW5jdGlvbiBpbiByZXR1cm4uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGFjdGlvbkNyZWF0b3JzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvblxuICogY3JlYXRvciBmdW5jdGlvbnMuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzYFxuICogc3ludGF4LiBZb3UgbWF5IGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwYXRjaCBUaGUgYGRpc3BhdGNoYCBmdW5jdGlvbiBhdmFpbGFibGUgb24geW91ciBSZWR1eFxuICogc3RvcmUuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gVGhlIG9iamVjdCBtaW1pY2tpbmcgdGhlIG9yaWdpbmFsIG9iamVjdCwgYnV0IHdpdGhcbiAqIGV2ZXJ5IGFjdGlvbiBjcmVhdG9yIHdyYXBwZWQgaW50byB0aGUgYGRpc3BhdGNoYCBjYWxsLiBJZiB5b3UgcGFzc2VkIGFcbiAqIGZ1bmN0aW9uIGFzIGBhY3Rpb25DcmVhdG9yc2AsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBhbHNvIGJlIGEgc2luZ2xlXG4gKiBmdW5jdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoIHRydWUgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2KSA6IDApO1xuICB9XG5cbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gYWN0aW9uQ3JlYXRvcnMpIHtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuLyoqXG4gKiBDb21wb3NlcyBzaW5nbGUtYXJndW1lbnQgZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC4gVGhlIHJpZ2h0bW9zdFxuICogZnVuY3Rpb24gY2FuIHRha2UgbXVsdGlwbGUgYXJndW1lbnRzIGFzIGl0IHByb3ZpZGVzIHRoZSBzaWduYXR1cmUgZm9yXG4gKiB0aGUgcmVzdWx0aW5nIGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jcyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2UuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gb2J0YWluZWQgYnkgY29tcG9zaW5nIHRoZSBhcmd1bWVudCBmdW5jdGlvbnNcbiAqIGZyb20gcmlnaHQgdG8gbGVmdC4gRm9yIGV4YW1wbGUsIGNvbXBvc2UoZiwgZywgaCkgaXMgaWRlbnRpY2FsIHRvIGRvaW5nXG4gKiAoLi4uYXJncykgPT4gZihnKGgoLi4uYXJncykpKS5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmNzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnO1xuICAgIH07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmNzWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmNzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYShiLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0b3JlIGVuaGFuY2VyIHRoYXQgYXBwbGllcyBtaWRkbGV3YXJlIHRvIHRoZSBkaXNwYXRjaCBtZXRob2RcbiAqIG9mIHRoZSBSZWR1eCBzdG9yZS4gVGhpcyBpcyBoYW5keSBmb3IgYSB2YXJpZXR5IG9mIHRhc2tzLCBzdWNoIGFzIGV4cHJlc3NpbmdcbiAqIGFzeW5jaHJvbm91cyBhY3Rpb25zIGluIGEgY29uY2lzZSBtYW5uZXIsIG9yIGxvZ2dpbmcgZXZlcnkgYWN0aW9uIHBheWxvYWQuXG4gKlxuICogU2VlIGByZWR1eC10aHVua2AgcGFja2FnZSBhcyBhbiBleGFtcGxlIG9mIHRoZSBSZWR1eCBtaWRkbGV3YXJlLlxuICpcbiAqIEJlY2F1c2UgbWlkZGxld2FyZSBpcyBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMsIHRoaXMgc2hvdWxkIGJlIHRoZSBmaXJzdFxuICogc3RvcmUgZW5oYW5jZXIgaW4gdGhlIGNvbXBvc2l0aW9uIGNoYWluLlxuICpcbiAqIE5vdGUgdGhhdCBlYWNoIG1pZGRsZXdhcmUgd2lsbCBiZSBnaXZlbiB0aGUgYGRpc3BhdGNoYCBhbmQgYGdldFN0YXRlYCBmdW5jdGlvbnNcbiAqIGFzIG5hbWVkIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBtaWRkbGV3YXJlcyBUaGUgbWlkZGxld2FyZSBjaGFpbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIHN0b3JlIGVuaGFuY2VyIGFwcGx5aW5nIHRoZSBtaWRkbGV3YXJlLlxuICovXG5cbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1pZGRsZXdhcmVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjcmVhdGVTdG9yZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RvcmUgPSBjcmVhdGVTdG9yZS5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG5cbiAgICAgIHZhciBfZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCB0cnVlID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNSkgOiAwKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBtaWRkbGV3YXJlQVBJID0ge1xuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgIGRpc3BhdGNoOiBmdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgICAgICAgICByZXR1cm4gX2Rpc3BhdGNoLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBjaGFpbiA9IG1pZGRsZXdhcmVzLm1hcChmdW5jdGlvbiAobWlkZGxld2FyZSkge1xuICAgICAgICByZXR1cm4gbWlkZGxld2FyZShtaWRkbGV3YXJlQVBJKTtcbiAgICAgIH0pO1xuICAgICAgX2Rpc3BhdGNoID0gY29tcG9zZS5hcHBseSh2b2lkIDAsIGNoYWluKShzdG9yZS5kaXNwYXRjaCk7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHN0b3JlKSwge30sIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuLypcbiAqIFRoaXMgaXMgYSBkdW1teSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZnVuY3Rpb24gbmFtZSBoYXMgYmVlbiBhbHRlcmVkIGJ5IG1pbmlmaWNhdGlvbi5cbiAqIElmIHRoZSBmdW5jdGlvbiBoYXMgYmVlbiBtaW5pZmllZCBhbmQgTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJywgd2FybiB0aGUgdXNlci5cbiAqL1xuXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxuXG5pZiAoZmFsc2UpIHt9XG5cblxuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0ICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGlzb2xhdGVkIGFnYWluc3Qgb3RoZXIgbW9kdWxlcyBpbiB0aGUgY2h1bmsuXG4hZnVuY3Rpb24oKSB7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NjcmlwdHNfY2hvaWNlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNzMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zY3JpcHRzX2Nob2ljZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc2NyaXB0c19jaG9pY2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zY3JpcHRzX2ludGVyZmFjZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTg3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2NyaXB0c19pbnRlcmZhY2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX3NjcmlwdHNfaW50ZXJmYWNlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2NyaXB0c19jb25zdGFudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODgzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2NyaXB0c19kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3ODkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zY3JpcHRzX3RlbXBsYXRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2ODYpO1xuXG5cblxuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKChfc2NyaXB0c19jaG9pY2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKSk7XG5cbn0oKTtcbl9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXTtcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOlsid2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJyb290IiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJ3aW5kb3ciLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImNsZWFyQ2hvaWNlcyIsImFjdGl2YXRlQ2hvaWNlcyIsImZpbHRlckNob2ljZXMiLCJhZGRDaG9pY2UiLCJjb25zdGFudHNfMSIsIl9hIiwibGFiZWwiLCJpZCIsImdyb3VwSWQiLCJkaXNhYmxlZCIsImVsZW1lbnRJZCIsImN1c3RvbVByb3BlcnRpZXMiLCJwbGFjZWhvbGRlciIsImtleUNvZGUiLCJ0eXBlIiwiQUNUSU9OX1RZUEVTIiwiQUREX0NIT0lDRSIsInJlc3VsdHMiLCJGSUxURVJfQ0hPSUNFUyIsImFjdGl2ZSIsIkFDVElWQVRFX0NIT0lDRVMiLCJDTEVBUl9DSE9JQ0VTIiwiYWRkR3JvdXAiLCJBRERfR1JPVVAiLCJoaWdobGlnaHRJdGVtIiwicmVtb3ZlSXRlbSIsImFkZEl0ZW0iLCJjaG9pY2VJZCIsIkFERF9JVEVNIiwiUkVNT1ZFX0lURU0iLCJoaWdobGlnaHRlZCIsIkhJR0hMSUdIVF9JVEVNIiwic2V0SXNMb2FkaW5nIiwicmVzZXRUbyIsImNsZWFyQWxsIiwiQ0xFQVJfQUxMIiwic3RhdGUiLCJSRVNFVF9UTyIsImlzTG9hZGluZyIsIlNFVF9JU19MT0FESU5HIiwiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsInBhY2siLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJpIiwibCIsImFyIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJjb25jYXQiLCJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiZGVlcG1lcmdlXzEiLCJmdXNlX2pzXzEiLCJjaG9pY2VzXzEiLCJncm91cHNfMSIsIml0ZW1zXzEiLCJtaXNjXzEiLCJjb21wb25lbnRzXzEiLCJkZWZhdWx0c18xIiwidXRpbHNfMSIsInJlZHVjZXJzXzEiLCJzdG9yZV8xIiwidGVtcGxhdGVzXzEiLCJJU19JRTExIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsIlVTRVJfREVGQVVMVFMiLCJDaG9pY2VzIiwiZWxlbWVudCIsInVzZXJDb25maWciLCJfdGhpcyIsImFsbG93SFRNTCIsInVuZGVmaW5lZCIsImNvbnNvbGUiLCJ3YXJuIiwiY29uZmlnIiwiZGVmYXVsdCIsImFsbCIsIkRFRkFVTFRfQ09ORklHIiwiZGVmYXVsdHMiLCJvcHRpb25zIiwiYXJyYXlNZXJnZSIsIl8iLCJzb3VyY2VBcnJheSIsImludmFsaWRDb25maWdPcHRpb25zIiwiZGlmZiIsImpvaW4iLCJwYXNzZWRFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsIkhUTUxJbnB1dEVsZW1lbnQiLCJIVE1MU2VsZWN0RWxlbWVudCIsIlR5cGVFcnJvciIsIl9pc1RleHRFbGVtZW50IiwiVEVYVF9UWVBFIiwiX2lzU2VsZWN0T25lRWxlbWVudCIsIlNFTEVDVF9PTkVfVFlQRSIsIl9pc1NlbGVjdE11bHRpcGxlRWxlbWVudCIsIlNFTEVDVF9NVUxUSVBMRV9UWVBFIiwiX2lzU2VsZWN0RWxlbWVudCIsInNlYXJjaEVuYWJsZWQiLCJpbmNsdWRlcyIsInJlbmRlclNlbGVjdGVkQ2hvaWNlcyIsImFkZEl0ZW1GaWx0ZXIiLCJyZSIsIlJlZ0V4cCIsInRlc3QiLCJiaW5kIiwiV3JhcHBlZElucHV0IiwiY2xhc3NOYW1lcyIsImRlbGltaXRlciIsIldyYXBwZWRTZWxlY3QiLCJ0ZW1wbGF0ZSIsImRhdGEiLCJfdGVtcGxhdGVzIiwib3B0aW9uIiwiaW5pdGlhbGlzZWQiLCJfc3RvcmUiLCJfaW5pdGlhbFN0YXRlIiwiZGVmYXVsdFN0YXRlIiwiX2N1cnJlbnRTdGF0ZSIsIl9wcmV2U3RhdGUiLCJfY3VycmVudFZhbHVlIiwiX2NhblNlYXJjaCIsIl9pc1Njcm9sbGluZ09uSWUiLCJfaGlnaGxpZ2h0UG9zaXRpb24iLCJfd2FzVGFwIiwiX3BsYWNlaG9sZGVyVmFsdWUiLCJfZ2VuZXJhdGVQbGFjZWhvbGRlclZhbHVlIiwiX2Jhc2VJZCIsImdlbmVyYXRlSWQiLCJfZGlyZWN0aW9uIiwiZGlyIiwiZWxlbWVudERpcmVjdGlvbiIsImdldENvbXB1dGVkU3R5bGUiLCJkaXJlY3Rpb24iLCJkb2N1bWVudERpcmVjdGlvbiIsIl9pZE5hbWVzIiwiaXRlbUNob2ljZSIsIl9wcmVzZXRHcm91cHMiLCJvcHRpb25Hcm91cHMiLCJfcHJlc2V0T3B0aW9ucyIsIl9wcmVzZXRDaG9pY2VzIiwiY2hvaWNlcyIsIl9wcmVzZXRJdGVtcyIsIml0ZW1zIiwic3BsaXRWYWx1ZXMiLCJzcGxpdCIsImZvckVhY2giLCJwdXNoIiwiaW5uZXJIVE1MIiwic2VsZWN0ZWQiLCJwYXJlbnROb2RlIiwiaGFzQXR0cmlidXRlIiwicGFyc2VDdXN0b21Qcm9wZXJ0aWVzIiwiZGF0YXNldCIsIl9yZW5kZXIiLCJfb25Gb2N1cyIsIl9vbkJsdXIiLCJfb25LZXlVcCIsIl9vbktleURvd24iLCJfb25DbGljayIsIl9vblRvdWNoTW92ZSIsIl9vblRvdWNoRW5kIiwiX29uTW91c2VEb3duIiwiX29uTW91c2VPdmVyIiwiX29uRm9ybVJlc2V0IiwiX29uU2VsZWN0S2V5IiwiX29uRW50ZXJLZXkiLCJfb25Fc2NhcGVLZXkiLCJfb25EaXJlY3Rpb25LZXkiLCJfb25EZWxldGVLZXkiLCJpc0FjdGl2ZSIsInNpbGVudCIsImluaXQiLCJnZXQiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInRlbXBsYXRlcyIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJfY3JlYXRlVGVtcGxhdGVzIiwiX2NyZWF0ZUVsZW1lbnRzIiwiX2NyZWF0ZVN0cnVjdHVyZSIsInN1YnNjcmliZSIsIl9hZGRFdmVudExpc3RlbmVycyIsInNob3VsZERpc2FibGUiLCJhZGRJdGVtcyIsImRpc2FibGUiLCJjYWxsYmFja09uSW5pdCIsImRlc3Ryb3kiLCJfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMiLCJyZXZlYWwiLCJjb250YWluZXJPdXRlciIsInVud3JhcCIsImNsZWFyU3RvcmUiLCJlbmFibGUiLCJpc0Rpc2FibGVkIiwiaW5wdXQiLCJpdGVtIiwicnVuRXZlbnQiLCJfYiIsIl9jIiwiZ3JvdXAiLCJnZXRHcm91cEJ5SWQiLCJkaXNwYXRjaCIsInRyaWdnZXJFdmVudCIsIkVWRU5UUyIsImdyb3VwVmFsdWUiLCJ1bmhpZ2hsaWdodEl0ZW0iLCJoaWdobGlnaHRBbGwiLCJ1bmhpZ2hsaWdodEFsbCIsInJlbW92ZUFjdGl2ZUl0ZW1zQnlWYWx1ZSIsImFjdGl2ZUl0ZW1zIiwiZmlsdGVyIiwiX3JlbW92ZUl0ZW0iLCJyZW1vdmVBY3RpdmVJdGVtcyIsImV4Y2x1ZGVkSWQiLCJyZW1vdmVIaWdobGlnaHRlZEl0ZW1zIiwiaGlnaGxpZ2h0ZWRBY3RpdmVJdGVtcyIsIl90cmlnZ2VyQ2hhbmdlIiwic2hvd0Ryb3Bkb3duIiwicHJldmVudElucHV0Rm9jdXMiLCJkcm9wZG93biIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNob3ciLCJvcGVuIiwiZGlzdGFuY2VGcm9tVG9wV2luZG93IiwiZm9jdXMiLCJoaWRlRHJvcGRvd24iLCJwcmV2ZW50SW5wdXRCbHVyIiwiaGlkZSIsImNsb3NlIiwicmVtb3ZlQWN0aXZlRGVzY2VuZGFudCIsImJsdXIiLCJnZXRWYWx1ZSIsInZhbHVlT25seSIsInZhbHVlcyIsInJlZHVjZSIsInNlbGVjdGVkSXRlbXMiLCJpdGVtVmFsdWUiLCJzZXRWYWx1ZSIsIl9zZXRDaG9pY2VPckl0ZW0iLCJzZXRDaG9pY2VCeVZhbHVlIiwiY2hvaWNlVmFsdWUiLCJpc0FycmF5IiwidmFsIiwiX2ZpbmRBbmRTZWxlY3RDaG9pY2VCeVZhbHVlIiwic2V0Q2hvaWNlcyIsImNob2ljZXNBcnJheU9yRmV0Y2hlciIsInJlcGxhY2VDaG9pY2VzIiwiUmVmZXJlbmNlRXJyb3IiLCJmZXRjaGVyXzEiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJfaGFuZGxlTG9hZGluZ1N0YXRlIiwiY2F0Y2giLCJlcnIiLCJlcnJvciIsInJlbW92ZUxvYWRpbmdTdGF0ZSIsIl9zdGFydExvYWRpbmciLCJncm91cE9yQ2hvaWNlIiwiX2FkZEdyb3VwIiwicGFyc2VJbnQiLCJ2YWx1ZUtleSIsImxhYmVsS2V5IiwiY2hvaWNlIiwiX2FkZENob2ljZSIsImlzU2VsZWN0ZWQiLCJfc3RvcExvYWRpbmciLCJjbGVhcklucHV0Iiwic2hvdWxkU2V0SW5wdXRXaWR0aCIsImNsZWFyIiwiX2lzU2VhcmNoaW5nIiwic3RhdGVDaGFuZ2VkIiwiZ3JvdXBzIiwic2hvdWxkUmVuZGVyQ2hvaWNlcyIsInNob3VsZFJlbmRlckl0ZW1zIiwiX3JlbmRlckNob2ljZXMiLCJfcmVuZGVySXRlbXMiLCJhY3RpdmVHcm91cHMiLCJhY3RpdmVDaG9pY2VzIiwiY2hvaWNlTGlzdEZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImNob2ljZUxpc3QiLCJyZXNldFNjcm9sbFBvc2l0aW9uIiwic2Nyb2xsVG9Ub3AiLCJhY3RpdmVQbGFjZWhvbGRlcnMiLCJhY3RpdmVDaG9pY2UiLCJfY3JlYXRlQ2hvaWNlc0ZyYWdtZW50IiwiX2NyZWF0ZUdyb3Vwc0ZyYWdtZW50IiwiY2hpbGROb2RlcyIsImNhbkFkZEl0ZW0iLCJfY2FuQWRkSXRlbSIsInJlc3BvbnNlIiwiYXBwZW5kIiwiX2hpZ2hsaWdodENob2ljZSIsIm5vdGljZSIsIl9nZXRUZW1wbGF0ZSIsImRyb3Bkb3duSXRlbSIsIm5vUmVzdWx0c1RleHQiLCJub0Nob2ljZXNUZXh0IiwiaXRlbUxpc3QiLCJpdGVtTGlzdEZyYWdtZW50IiwiX2NyZWF0ZUl0ZW1zRnJhZ21lbnQiLCJmcmFnbWVudCIsImdldEdyb3VwQ2hvaWNlcyIsInNob3VsZFNvcnQiLCJzb3J0Iiwic29ydGVyIiwiZ3JvdXBDaG9pY2VzIiwiZHJvcGRvd25Hcm91cCIsImFwcGVuZENoaWxkIiwid2l0aGluR3JvdXAiLCJzZWFyY2hSZXN1bHRMaW1pdCIsInJlbmRlckNob2ljZUxpbWl0Iiwic29ydEJ5U2NvcmUiLCJhcHBlbmRDaG9pY2UiLCJzaG91bGRSZW5kZXIiLCJpdGVtU2VsZWN0VGV4dCIsInJlbmRlcmVyYWJsZUNob2ljZXMiLCJhY2MiLCJwbGFjZWhvbGRlckNob2ljZXMiLCJub3JtYWxDaG9pY2VzIiwiY2hvaWNlTGltaXQiLCJzb3J0ZWRDaG9pY2VzIiwic2hvdWxkU29ydEl0ZW1zIiwicmVtb3ZlSXRlbUJ1dHRvbiIsIm1hcCIsImFkZEl0ZW1Ub0ZyYWdtZW50IiwibGlzdEl0ZW0iLCJjaGFuZ2UiLCJfc2VsZWN0UGxhY2Vob2xkZXJDaG9pY2UiLCJwbGFjZWhvbGRlckNob2ljZSIsIl9hZGRJdGVtIiwiX2hhbmRsZUJ1dHRvbkFjdGlvbiIsInJlbW92ZUl0ZW1zIiwiaXRlbUlkIiwiaXRlbVRvUmVtb3ZlIiwiZmluZCIsIl9oYW5kbGVJdGVtQWN0aW9uIiwiaGFzU2hpZnRLZXkiLCJwYXNzZWRJZCIsIl9oYW5kbGVDaG9pY2VBY3Rpb24iLCJnZXRDaG9pY2VCeUlkIiwicGFzc2VkS2V5Q29kZSIsImhhc0FjdGl2ZURyb3Bkb3duIiwiX2hhbmRsZUJhY2tzcGFjZSIsImxhc3RJdGVtIiwiaGFzSGlnaGxpZ2h0ZWRJdGVtcyIsInNvbWUiLCJlZGl0SXRlbXMiLCJzZXRXaWR0aCIsInNldExvYWRpbmciLCJwbGFjZWhvbGRlckl0ZW0iLCJnZXRDaGlsZCIsImFkZExvYWRpbmdTdGF0ZSIsImxvYWRpbmdUZXh0IiwiX2hhbmRsZVNlYXJjaCIsImlzRm9jdXNzZWQiLCJzZWFyY2hGbG9vciIsInNlYXJjaENob2ljZXMiLCJoYXNVbmFjdGl2ZUNob2ljZXMiLCJyZXN1bHRDb3VudCIsIl9zZWFyY2hDaG9pY2VzIiwic2VhcmNoIiwiYWRkSXRlbVRleHQiLCJpc0R1cGxpY2F0ZVZhbHVlIiwiZXhpc3RzSW5BcnJheSIsIm1heEl0ZW1Db3VudCIsIm1heEl0ZW1UZXh0IiwiZHVwbGljYXRlSXRlbXNBbGxvd2VkIiwidW5pcXVlSXRlbVRleHQiLCJjdXN0b21BZGRJdGVtVGV4dCIsIm5ld1ZhbHVlIiwidHJpbSIsImN1cnJlbnRWYWx1ZSIsImhheXN0YWNrIiwic2VhcmNoYWJsZUNob2ljZXMiLCJuZWVkbGUiLCJhc3NpZ24iLCJmdXNlT3B0aW9ucyIsImtleXMiLCJzZWFyY2hGaWVsZHMiLCJpbmNsdWRlTWF0Y2hlcyIsImZ1c2UiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsImZvcm0iLCJhZGRFdmVudExpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVycyIsImV2ZW50IiwiaGFzRm9jdXNlZElucHV0IiwiaGFzSXRlbXMiLCJoYXNDaGlsZHJlbiIsImtleVN0cmluZyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIndhc1ByaW50YWJsZUNoYXIiLCJCQUNLX0tFWSIsIktFWV9DT0RFUyIsIkRFTEVURV9LRVkiLCJFTlRFUl9LRVkiLCJBX0tFWSIsIkVTQ19LRVkiLCJVUF9LRVkiLCJET1dOX0tFWSIsIlBBR0VfVVBfS0VZIiwiUEFHRV9ET1dOX0tFWSIsImtleSIsInRvTG93ZXJDYXNlIiwidGFyZ2V0IiwiYmFja0tleSIsImRlbGV0ZUtleSIsImNhblNob3dEcm9wZG93bk5vdGljZSIsIm91dGVySFRNTCIsIndhc1JlbW92YWxLZXlDb2RlIiwidXNlckhhc1JlbW92ZWRWYWx1ZSIsImNhblJlYWN0aXZhdGVDaG9pY2VzIiwiY2FuU2VhcmNoIiwicmF3VmFsdWUiLCJjdHJsS2V5IiwibWV0YUtleSIsImhhc0N0cmxEb3duS2V5UHJlc3NlZCIsInNob3VsZEhpZ2h0bGlnaHRBbGwiLCJhY3RpdmVFbGVtZW50IiwiZW50ZXJLZXkiLCJ0YXJnZXRXYXNCdXR0b24iLCJwcmV2ZW50RGVmYXVsdCIsImhpZ2hsaWdodGVkQ2hvaWNlIiwiaGlnaGxpZ2h0ZWRTdGF0ZSIsImRvd25LZXkiLCJwYWdlVXBLZXkiLCJwYWdlRG93bktleSIsImRpcmVjdGlvbkludCIsInNraXBLZXkiLCJzZWxlY3RhYmxlQ2hvaWNlSWRlbnRpZmllciIsIm5leHRFbCIsImN1cnJlbnRFbCIsImdldEFkamFjZW50RWwiLCJpc1Njcm9sbGVkSW50b1ZpZXciLCJzY3JvbGxUb0NoaWxkRWxlbWVudCIsInRvdWNoZXMiLCJ0b3VjaFdhc1dpdGhpbkNvbnRhaW5lciIsImNvbnRhaW5zIiwiY29udGFpbmVyV2FzRXhhY3RUYXJnZXQiLCJjb250YWluZXJJbm5lciIsInN0b3BQcm9wYWdhdGlvbiIsIkhUTUxFbGVtZW50IiwiZmlyc3RDaG9pY2UiLCJmaXJzdEVsZW1lbnRDaGlsZCIsImlzT25TY3JvbGxiYXIiLCJvZmZzZXRYIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRMZWZ0IiwiY2xvc2VzdCIsInNoaWZ0S2V5IiwiY2xpY2tXYXNXaXRoaW5Db250YWluZXIiLCJyZW1vdmVGb2N1c1N0YXRlIiwiZm9jdXNXYXNXaXRoaW5Db250YWluZXIiLCJmb2N1c0FjdGlvbnMiLCJhZGRGb2N1c1N0YXRlIiwiYmx1cldhc1dpdGhpbkNvbnRhaW5lciIsImhhc0hpZ2hsaWdodGVkSXRlbXNfMSIsImJsdXJBY3Rpb25zIiwiZWwiLCJxdWVyeVNlbGVjdG9yQWxsIiwicGFzc2VkRWwiLCJoaWdobGlnaHRlZENob2ljZXMiLCJjbGFzc0xpc3QiLCJyZW1vdmUiLCJzZXRBdHRyaWJ1dGUiLCJpbmRleE9mIiwiYWRkIiwiaGlnaGxpZ2h0Q2hvaWNlIiwic2V0QWN0aXZlRGVzY2VuZGFudCIsIl9kIiwiX2UiLCJfZiIsIl9nIiwicGFzc2VkVmFsdWUiLCJwYXNzZWRMYWJlbCIsInBhc3NlZE9wdGlvbklkIiwicHJlcGVuZFZhbHVlIiwidG9TdHJpbmciLCJhcHBlbmRWYWx1ZSIsIl9oIiwiY2hvaWNlTGFiZWwiLCJjaG9pY2VFbGVtZW50SWQiLCJpc1R5cGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJ2YWx1ZU9mIiwicmFuZG9tIiwiYWRkR3JvdXBDaG9pY2VzIiwiaXNPcHREaXNhYmxlZCIsImFyZ3MiLCJfaSIsImFwcGx5IiwiY2FsbGJhY2tPbkNyZWF0ZVRlbXBsYXRlcyIsInVzZXJUZW1wbGF0ZXMiLCJzdHJUb0VsIiwiQ29udGFpbmVyIiwibGFiZWxJZCIsInBvc2l0aW9uIiwiSW5wdXQiLCJwcmV2ZW50UGFzdGUiLCJwYXN0ZSIsIkxpc3QiLCJEcm9wZG93biIsImNvbmNlYWwiLCJ3cmFwIiwic2VhcmNoUGxhY2Vob2xkZXJWYWx1ZSIsImluc2VydEJlZm9yZSIsImZpcnN0Q2hpbGQiLCJfYWRkUHJlZGVmaW5lZEdyb3VwcyIsIl9hZGRQcmVkZWZpbmVkQ2hvaWNlcyIsIl9hZGRQcmVkZWZpbmVkSXRlbXMiLCJwbGFjZWhvbGRlck9wdGlvbiIsInRhZ05hbWUiLCJoYXNTZWxlY3RlZENob2ljZSIsImZpcnN0RW5hYmxlZENob2ljZUluZGV4IiwiZmluZEluZGV4IiwiaW5kZXgiLCJzaG91bGRQcmVzZWxlY3QiLCJpdGVtVHlwZSIsImdldFR5cGUiLCJoYW5kbGVUeXBlIiwib2JqZWN0Iiwic3RyaW5nIiwiZm91bmRDaG9pY2UiLCJ2YWx1ZUNvbXBhcmVyIiwidGV4dCIsInBsYWNlaG9sZGVyVmFsdWUiLCJpc09wZW4iLCJpc0ZsaXBwZWQiLCJzaG91bGRGbGlwIiwiZHJvcGRvd25Qb3MiLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsImFjdGl2ZURlc2NlbmRhbnRJRCIsInJlbW92ZUF0dHJpYnV0ZSIsIm9wZW5TdGF0ZSIsImZsaXBwZWRTdGF0ZSIsImZvY3VzU3RhdGUiLCJkaXNhYmxlZFN0YXRlIiwicmVtb3ZlQ2hpbGQiLCJsb2FkaW5nU3RhdGUiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJib3R0b20iLCJzZWxlY3RvciIsImFjdGl2ZVN0YXRlIiwiZHJvcGRvd25fMSIsImNvbnRhaW5lcl8xIiwiaW5wdXRfMSIsImxpc3RfMSIsIndyYXBwZWRfaW5wdXRfMSIsIndyYXBwZWRfc2VsZWN0XzEiLCJpc0VxdWFsTm9kZSIsIl9vblBhc3RlIiwiX29uSW5wdXQiLCJzZXQiLCJzYW5pdGlzZSIsIm1pbldpZHRoIiwid2lkdGgiLCJzY3JvbGxQb3MiLCJzY3JvbGxUb3AiLCJoZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJub2RlIiwiaGFzQ2hpbGROb2RlcyIsImxpc3RIZWlnaHQiLCJsaXN0U2Nyb2xsUG9zaXRpb24iLCJlbGVtZW50SGVpZ2h0IiwiZWxlbWVudFBvcyIsIm9mZnNldFRvcCIsImRlc3RpbmF0aW9uIiwiX2FuaW1hdGVTY3JvbGwiLCJfc2Nyb2xsRG93biIsInN0cmVuZ3RoIiwiZWFzaW5nIiwiZGlzdGFuY2UiLCJfc2Nyb2xsVXAiLCJTQ1JPTExJTkdfU1BFRUQiLCJjaG9pY2VMaXN0U2Nyb2xsVG9wIiwiY29udGludWVBbmltYXRpb24iLCJXcmFwcGVkRWxlbWVudCIsImhpZGRlbiIsInRhYkluZGV4Iiwib3JpZ1N0eWxlIiwiZ2V0QXR0cmlidXRlIiwiZXZlbnRUeXBlIiwiZGlzcGF0Y2hFdmVudCIsIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwicCIsImhhc093blByb3BlcnR5IiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIndyYXBwZWRfZWxlbWVudF8xIiwiX3N1cGVyIiwiYWRkT3B0aW9uVG9GcmFnbWVudCIsIm9wdGlvbkRhdGEiLCJhcHBlbmREb2NGcmFnbWVudCIsIkRFRkFVTFRfQ0xBU1NOQU1FUyIsImlucHV0Q2xvbmVkIiwibGlzdCIsImxpc3RJdGVtcyIsImxpc3RTaW5nbGUiLCJsaXN0RHJvcGRvd24iLCJpdGVtU2VsZWN0YWJsZSIsIml0ZW1EaXNhYmxlZCIsImdyb3VwSGVhZGluZyIsImJ1dHRvbiIsInNlbGVjdGVkU3RhdGUiLCJub1Jlc3VsdHMiLCJub0Nob2ljZXMiLCJzb3J0QnlBbHBoYSIsInZhbHVlMSIsInZhbHVlMiIsImluY2x1ZGVTY29yZSIsIl9fY3JlYXRlQmluZGluZyIsIm8iLCJtIiwiayIsImsyIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIndyaXRhYmxlIiwiX19leHBvcnRTdGFyIiwiY2xvbmVPYmplY3QiLCJnZW5lcmF0ZUNoYXJzIiwiZ2V0UmFuZG9tTnVtYmVyIiwibWluIiwibWF4IiwicHJlZml4IiwibmFtZSIsInJlcGxhY2UiLCJvYmoiLCJ3cmFwcGVyIiwiY3JlYXRlRWxlbWVudCIsIm5leHRTaWJsaW5nIiwic3RhcnRFbCIsInByb3AiLCJzaWJsaW5nIiwicGFyZW50IiwiaXNWaXNpYmxlIiwidG1wRWwiLCJzdHIiLCJjbGVhbmVkSW5wdXQiLCJmaXJsZENoaWxkIiwiY2hpbGRyZW4iLCJsYWJlbDIiLCJsb2NhbGVDb21wYXJlIiwic2Vuc2l0aXZpdHkiLCJpZ25vcmVQdW5jdHVhdGlvbiIsIm51bWVyaWMiLCJhIiwic2NvcmUiLCJzY29yZUEiLCJzY29yZUIiLCJjdXN0b21BcmdzIiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImFycmF5IiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiYUtleXMiLCJiS2V5cyIsImUiLCJhY3Rpb24iLCJhZGRDaG9pY2VBY3Rpb24iLCJhZGRJdGVtQWN0aW9uXzEiLCJyZW1vdmVJdGVtQWN0aW9uXzEiLCJmaWx0ZXJDaG9pY2VzQWN0aW9uXzEiLCJhY3RpdmF0ZUNob2ljZXNBY3Rpb25fMSIsImFkZEdyb3VwQWN0aW9uIiwicmVkdXhfMSIsImxvYWRpbmdfMSIsImxvYWRpbmciLCJhcHBSZWR1Y2VyIiwiY29tYmluZVJlZHVjZXJzIiwicm9vdFJlZHVjZXIiLCJwYXNzZWRTdGF0ZSIsImFkZEl0ZW1BY3Rpb24iLCJuZXdTdGF0ZSIsImhpZ2hsaWdodEl0ZW1BY3Rpb25fMSIsImdlbmVyYWwiLCJpbmRleF8xIiwiU3RvcmUiLCJjcmVhdGVTdG9yZSIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18iLCJvbkNoYW5nZSIsImdldFN0YXRlIiwic2VsZWN0YWJsZUNob2ljZXMiLCJyZXZlcnNlIiwiaGFzQWN0aXZlT3B0aW9ucyIsImlzU2VsZWN0RWxlbWVudCIsImlzU2VsZWN0T25lRWxlbWVudCIsInBhc3NlZEVsZW1lbnRUeXBlIiwiZGl2IiwiY2xhc3NOYW1lIiwiaXNQbGFjZWhvbGRlciIsImRlbGV0YWJsZSIsIlJFTU9WRV9JVEVNX1RFWFQiLCJyZW1vdmVCdXR0b24iLCJjaG9pY2VHcm91cCIsInNlbGVjdFRleHQiLCJjaG9pY2VEaXNhYmxlZCIsImNob2ljZVNlbGVjdGFibGUiLCJpbnAiLCJhdXRvY29tcGxldGUiLCJhdXRvY2FwaXRhbGl6ZSIsInNwZWxsY2hlY2siLCJpbm5lclRleHQiLCJjbGFzc2VzIiwib3B0IiwiT3B0aW9uIiwiaXNNZXJnZWFibGVPYmplY3QiLCJpc05vbk51bGxPYmplY3QiLCJpc1NwZWNpYWwiLCJzdHJpbmdWYWx1ZSIsImlzUmVhY3RFbGVtZW50IiwiY2FuVXNlU3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiJCR0eXBlb2YiLCJlbXB0eVRhcmdldCIsImNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIiwiY2xvbmUiLCJkZWVwbWVyZ2UiLCJkZWZhdWx0QXJyYXlNZXJnZSIsInNvdXJjZSIsImdldE1lcmdlRnVuY3Rpb24iLCJjdXN0b21NZXJnZSIsImdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2wiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImdldEtleXMiLCJwcm9wZXJ0eUlzT25PYmplY3QiLCJwcm9wZXJ0eSIsInByb3BlcnR5SXNVbnNhZmUiLCJtZXJnZU9iamVjdCIsInNvdXJjZUlzQXJyYXkiLCJ0YXJnZXRJc0FycmF5Iiwic291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCIsImRlZXBtZXJnZUFsbCIsIkVycm9yIiwicHJldiIsIm5leHQiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiciIsIkZ1c2UiLCJnZXRUYWciLCJJTkZJTklUWSIsImJhc2VUb1N0cmluZyIsInJlc3VsdCIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc0Jvb2xlYW4iLCJpc09iamVjdExpa2UiLCJpc09iamVjdCIsImlzRGVmaW5lZCIsImlzQmxhbmsiLCJFWFRFTkRFRF9TRUFSQ0hfVU5BVkFJTEFCTEUiLCJJTkNPUlJFQ1RfSU5ERVhfVFlQRSIsIkxPR0lDQUxfU0VBUkNIX0lOVkFMSURfUVVFUllfRk9SX0tFWSIsIlBBVFRFUk5fTEVOR1RIX1RPT19MQVJHRSIsIk1JU1NJTkdfS0VZX1BST1BFUlRZIiwiSU5WQUxJRF9LRVlfV0VJR0hUX1ZBTFVFIiwiaGFzT3duIiwiS2V5U3RvcmUiLCJfa2V5cyIsIl9rZXlNYXAiLCJ0b3RhbFdlaWdodCIsImNyZWF0ZUtleSIsIndlaWdodCIsImtleUlkIiwidG9KU09OIiwicGF0aCIsInNyYyIsImdldEZuIiwiY3JlYXRlS2V5UGF0aCIsImNyZWF0ZUtleUlkIiwiYXJyIiwiZGVlcEdldCIsImxlbiIsIk1hdGNoT3B0aW9ucyIsImZpbmRBbGxNYXRjaGVzIiwibWluTWF0Y2hDaGFyTGVuZ3RoIiwiQmFzaWNPcHRpb25zIiwiaXNDYXNlU2Vuc2l0aXZlIiwic29ydEZuIiwiaWR4IiwiRnV6enlPcHRpb25zIiwibG9jYXRpb24iLCJ0aHJlc2hvbGQiLCJBZHZhbmNlZE9wdGlvbnMiLCJ1c2VFeHRlbmRlZFNlYXJjaCIsImlnbm9yZUxvY2F0aW9uIiwiaWdub3JlRmllbGROb3JtIiwiZmllbGROb3JtV2VpZ2h0IiwiQ29uZmlnIiwiU1BBQ0UiLCJub3JtIiwibWFudGlzc2EiLCJjYWNoZSIsIk1hcCIsInBvdyIsIm51bVRva2VucyIsIm1hdGNoIiwiaGFzIiwibiIsInBhcnNlRmxvYXQiLCJyb3VuZCIsIkZ1c2VJbmRleCIsImlzQ3JlYXRlZCIsInNldEluZGV4UmVjb3JkcyIsInNldFNvdXJjZXMiLCJkb2NzIiwicmVjb3JkcyIsInNldEtleXMiLCJfa2V5c01hcCIsImRvYyIsImRvY0luZGV4IiwiX2FkZFN0cmluZyIsIl9hZGRPYmplY3QiLCJzaXplIiwicmVtb3ZlQXQiLCJzcGxpY2UiLCJnZXRWYWx1ZUZvckl0ZW1BdEtleUlkIiwicmVjb3JkIiwidiIsIiQiLCJrZXlJbmRleCIsInN1YlJlY29yZHMiLCJzdGFjayIsIm5lc3RlZEFyckluZGV4IiwicG9wIiwic3ViUmVjb3JkIiwiY3JlYXRlSW5kZXgiLCJteUluZGV4IiwicGFyc2VJbmRleCIsImNvbXB1dGVTY29yZSQxIiwicGF0dGVybiIsImVycm9ycyIsImN1cnJlbnRMb2NhdGlvbiIsImV4cGVjdGVkTG9jYXRpb24iLCJhY2N1cmFjeSIsInByb3hpbWl0eSIsImFicyIsImNvbnZlcnRNYXNrVG9JbmRpY2VzIiwibWF0Y2htYXNrIiwiaW5kaWNlcyIsInN0YXJ0IiwiZW5kIiwiTUFYX0JJVFMiLCJwYXR0ZXJuQWxwaGFiZXQiLCJwYXR0ZXJuTGVuIiwidGV4dExlbiIsImN1cnJlbnRUaHJlc2hvbGQiLCJiZXN0TG9jYXRpb24iLCJjb21wdXRlTWF0Y2hlcyIsIm1hdGNoTWFzayIsImxhc3RCaXRBcnIiLCJmaW5hbFNjb3JlIiwiYmluTWF4IiwibWFzayIsImJpbk1pbiIsImJpbk1pZCIsImZpbmlzaCIsImJpdEFyciIsImoiLCJjaGFyTWF0Y2giLCJjaGFyQXQiLCJpc01hdGNoIiwiY3JlYXRlUGF0dGVybkFscGhhYmV0IiwiY2hhciIsIkJpdGFwU2VhcmNoIiwiY2h1bmtzIiwiYWRkQ2h1bmsiLCJzdGFydEluZGV4IiwiYWxwaGFiZXQiLCJyZW1haW5kZXIiLCJzdWJzdHIiLCJzZWFyY2hJbiIsImFsbEluZGljZXMiLCJ0b3RhbFNjb3JlIiwiaGFzTWF0Y2hlcyIsIkJhc2VNYXRjaCIsImlzTXVsdGlNYXRjaCIsImdldE1hdGNoIiwibXVsdGlSZWdleCIsImlzU2luZ2xlTWF0Y2giLCJzaW5nbGVSZWdleCIsImV4cCIsIkV4YWN0TWF0Y2giLCJJbnZlcnNlRXhhY3RNYXRjaCIsIlByZWZpeEV4YWN0TWF0Y2giLCJzdGFydHNXaXRoIiwiSW52ZXJzZVByZWZpeEV4YWN0TWF0Y2giLCJTdWZmaXhFeGFjdE1hdGNoIiwiZW5kc1dpdGgiLCJJbnZlcnNlU3VmZml4RXhhY3RNYXRjaCIsIkZ1enp5TWF0Y2giLCJfYml0YXBTZWFyY2giLCJJbmNsdWRlTWF0Y2giLCJzZWFyY2hlcnMiLCJzZWFyY2hlcnNMZW4iLCJTUEFDRV9SRSIsIk9SX1RPS0VOIiwicGFyc2VRdWVyeSIsInF1ZXJ5IiwicXVlcnlJdGVtIiwiZm91bmQiLCJzZWFyY2hlciIsInRva2VuIiwiTXVsdGlNYXRjaFNldCIsIlNldCIsIkV4dGVuZGVkU2VhcmNoIiwiY29uZGl0aW9uIiwibnVtTWF0Y2hlcyIsInFMZW4iLCJwTGVuIiwicmVnaXN0ZXJlZFNlYXJjaGVycyIsInJlZ2lzdGVyIiwiY3JlYXRlU2VhcmNoZXIiLCJzZWFyY2hlckNsYXNzIiwiTG9naWNhbE9wZXJhdG9yIiwiQU5EIiwiT1IiLCJLZXlUeXBlIiwiUEFUSCIsIlBBVFRFUk4iLCJpc0V4cHJlc3Npb24iLCJpc1BhdGgiLCJpc0xlYWYiLCJjb252ZXJ0VG9FeHBsaWNpdCIsImF1dG8iLCJpc1F1ZXJ5UGF0aCIsIm9wZXJhdG9yIiwiY29tcHV0ZVNjb3JlIiwiTnVtYmVyIiwiRVBTSUxPTiIsInRyYW5zZm9ybU1hdGNoZXMiLCJyZWZJbmRleCIsInRyYW5zZm9ybVNjb3JlIiwiZm9ybWF0IiwidHJhbnNmb3JtZXJzIiwidHJhbnNmb3JtZXIiLCJfa2V5U3RvcmUiLCJzZXRDb2xsZWN0aW9uIiwiX2RvY3MiLCJfbXlJbmRleCIsInByZWRpY2F0ZSIsImdldEluZGV4IiwibGltaXQiLCJfc2VhcmNoU3RyaW5nTGlzdCIsIl9zZWFyY2hPYmplY3RMaXN0IiwiX3NlYXJjaExvZ2ljYWwiLCJleHByZXNzaW9uIiwiZXZhbHVhdGUiLCJfZmluZE1hdGNoZXMiLCJyZXMiLCJjaGlsZCIsInJlc3VsdE1hcCIsImV4cFJlc3VsdHMiLCJ2ZXJzaW9uIiwiQWN0aW9uVHlwZXMiLCJhcHBseU1pZGRsZXdhcmUiLCJiaW5kQWN0aW9uQ3JlYXRvcnMiLCJjb21wb3NlIiwibGVnYWN5X2NyZWF0ZVN0b3JlIiwiX3R5cGVvZiIsIml0ZXJhdG9yIiwiX3RvUHJpbWl0aXZlIiwiaGludCIsInByaW0iLCJ0b1ByaW1pdGl2ZSIsIl90b1Byb3BlcnR5S2V5IiwiYXJnIiwiX2RlZmluZVByb3BlcnR5Iiwib3duS2V5cyIsImVudW1lcmFibGVPbmx5Iiwic3ltYm9scyIsInN5bSIsIl9vYmplY3RTcHJlYWQyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwiY29kZSIsIiQkb2JzZXJ2YWJsZSIsIm9ic2VydmFibGUiLCJyYW5kb21TdHJpbmciLCJzdWJzdHJpbmciLCJJTklUIiwiUkVQTEFDRSIsIlBST0JFX1VOS05PV05fQUNUSU9OIiwiaXNQbGFpbk9iamVjdCIsInByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJtaW5pS2luZE9mIiwiaXNEYXRlIiwiaXNFcnJvciIsImNvbnN0cnVjdG9yTmFtZSIsImN0b3JOYW1lIiwibWVzc2FnZSIsInN0YWNrVHJhY2VMaW1pdCIsInRvRGF0ZVN0cmluZyIsImdldERhdGUiLCJzZXREYXRlIiwia2luZE9mIiwidHlwZU9mVmFsIiwicmVkdWNlciIsInByZWxvYWRlZFN0YXRlIiwiZW5oYW5jZXIiLCJfcmVmMiIsImN1cnJlbnRSZWR1Y2VyIiwiY3VycmVudFN0YXRlIiwiY3VycmVudExpc3RlbmVycyIsIm5leHRMaXN0ZW5lcnMiLCJpc0Rpc3BhdGNoaW5nIiwiZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycyIsImxpc3RlbmVyIiwiaXNTdWJzY3JpYmVkIiwidW5zdWJzY3JpYmUiLCJsaXN0ZW5lcnMiLCJyZXBsYWNlUmVkdWNlciIsIm5leHRSZWR1Y2VyIiwiX3JlZiIsIm91dGVyU3Vic2NyaWJlIiwib2JzZXJ2ZXIiLCJvYnNlcnZlU3RhdGUiLCJ3YXJuaW5nIiwiZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZSIsImlucHV0U3RhdGUiLCJyZWR1Y2VycyIsInVuZXhwZWN0ZWRLZXlDYWNoZSIsInJlZHVjZXJLZXlzIiwiYXJndW1lbnROYW1lIiwidW5leHBlY3RlZEtleXMiLCJhc3NlcnRSZWR1Y2VyU2hhcGUiLCJpbml0aWFsU3RhdGUiLCJmaW5hbFJlZHVjZXJzIiwiZmluYWxSZWR1Y2VyS2V5cyIsInNoYXBlQXNzZXJ0aW9uRXJyb3IiLCJjb21iaW5hdGlvbiIsIndhcm5pbmdNZXNzYWdlIiwiaGFzQ2hhbmdlZCIsIm5leHRTdGF0ZSIsIl9rZXkiLCJwcmV2aW91c1N0YXRlRm9yS2V5IiwibmV4dFN0YXRlRm9yS2V5IiwiYWN0aW9uVHlwZSIsImJpbmRBY3Rpb25DcmVhdG9yIiwiYWN0aW9uQ3JlYXRvciIsImFjdGlvbkNyZWF0b3JzIiwiYm91bmRBY3Rpb25DcmVhdG9ycyIsIl9sZW4iLCJmdW5jcyIsIm1pZGRsZXdhcmVzIiwic3RvcmUiLCJfZGlzcGF0Y2giLCJtaWRkbGV3YXJlQVBJIiwiY2hhaW4iLCJtaWRkbGV3YXJlIiwiaXNDcnVzaGVkIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJnZXR0ZXIiLCJkZWZpbml0aW9uIiwidG9TdHJpbmdUYWciLCJfc2NyaXB0c19jaG9pY2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18iLCJfc2NyaXB0c19jaG9pY2VzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsIl9zY3JpcHRzX2ludGVyZmFjZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsIl9zY3JpcHRzX2ludGVyZmFjZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0IiwiX3NjcmlwdHNfY29uc3RhbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJfc2NyaXB0c19kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwiX3NjcmlwdHNfdGVtcGxhdGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/choices.js/public/assets/scripts/choices.js\n");

/***/ })

};
;